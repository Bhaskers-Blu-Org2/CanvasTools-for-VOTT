# CanvasTools librarary for VoTT

CanvasTools is one of the UI modules used in the [VoTT project](https://github.com/Microsoft/VoTT/). The library impelements the following core features:

* Region (box) selection & manipulation
* Filters pipeline for underlaying canvas element
* Toolbar for all available tools

## Dependencies

* CanvasTools heavily uses the [Snap.Svg](https://github.com/adobe-webplatform/Snap.svg) library. In the webpack-eged version it is bundled with CanvasTools into one `ct.js` file, including also styles.
* Current version of the library depends on some features (e.g., masks-support in SVG) that are not fully cross-browser, but targeting Electron (Chromium).

## How to use

### Install npm package

Install package from npm:

```node
npm i vott-ct
```

The package structure:

```txt
dist/
    ct.d.ts -- bundled typings
    ct.dev.js -- webpack bundle for development (incl source map)
    ct.js -- webpack bundle for production ({tsc->commonjs, snapsvg, styles} -> umd)
    ct.js.map -- source map for ct.js
    ct.min.js -- webpack minimized bundle for production
    ct.min.js.map -- source map for ct.min.js
lib/
    css/
        canvastools.css
    icons/
        {*.png, *.svg} - collection of icons for toolbar and cursor
    js/
        ct.d.ts -- typings generated by tcs
        ct.js -- AMD module generated by tcs
        ct.js.map -- map file generated by tcs
        snapsvg.cjs.d.ts -- typings for the snapsvg-cjs package
        CanvasTools/
            {*.js, *.d.ts} -- compilied js and typings files
```

### Add library to the app

Add the `ct.js` file to your web-app (e.g., an Electron-based app).

```html
<script src="ct.js"></script>
<!-- OR -->
<script src="ct.min.js"></script>

```

Copy toolbar icons from the [`src` folder](https://github.com/kichinsky/CanvasTools-for-VOTT/tree/master/src/canvastools/icons) to your project.

Create a reference to the CanvasTools (or use directrly the `CanvasTools` object).

```js
let ct = CanvasTools;
```

### Add Editor to the page

Add container elements to host SVG elements for the toolbar and the editor.

```html
<div id="canvasTiilsDiv">
    <div id="toolbarDiv"></div>
    <div id="selectionDiv">
        <div id="editorDiv"></div>
    </div>
</div>
```

Initiate Editor-object from the CanvasTools.

```js
var sz = document.getElementById("editorDiv");
var tz = document.getElementById("toolbarDiv");

var editor = new ct.Editor(sz).api;
editor.addToolbar(tz, ct.Editor.FullToolbarSet, "./images/icons/");
```

The editor will auto-adjust to available space in provided container block.
`FullToolbarSet` icons set is used by default and exposes all available tools. The `RectToolbarSet` set contains only box-creation tools.
Correct the path to toolbar icons based on the structure of your project.

### Add callbacks to the Editor

Add a callback for the `onSelectionEnd` event to define what should happen when a new region is selected (created). Usually at the end of processing the new `regionData` you also want to add it to the screen with some tags applyed. Use the `addRegion` method for that.

```js
// Create some ID for regions
let incrementalRegionID = 100;

// Set callback for onSelectionEnd
editor.onSelectionEnd = (regionData) => {
    let id = (incrementalRegionID++).toString();
    let tags = getTagDescriptor();            
    editor.addRegion(id, regionData, tags);
};        

// Generate tags
function getTagDescriptor() {
    // use hue value
    let primaryTag = new ct.Core.Tag("Awesome", 300);
    // use string color to automatically extract hue value
    let secondaryTag = new ct.Core.Tag("Yes", "#e53");
    // extract hue value from string color 
    let ternaryTag = new ct.Core.Tag("one", ct.Core.Tag.getHueFromColor("#3fef66"));
    return new ct.Core.TagsDescriptor(primaryTag, [secondaryTag, ternaryTag]);
}
```

### Update background
Once the background image for tagging task is loaded (or a video element is ready, or a canvas element is created), pass it to the editor as a new content source.

```js
let imagePath = "./../images/background-forest-v.jpg";
let image = new Image();
image.addEventListener("load", (e) => {
    editor.addContentSource(e.target);
});
image.src = imagePath;
```

## Changelog

### 2.1.4

1. Added a new `api` proxy to the `Editor` class. It wraps accessing to all the public methods of `Editor`, `RegionsManager`, `AreaSelector` and `FilterPipeline`. So instead of writing `editor.RM.addRegion(...)`, you can use the following approach:
    ```js
    var editor = new ct.Editor(editorDiv).api;
    editor.addRegion(...)
    editor.setSelectionMode(...)
    ```

2. Removed from the `Editor` class itself the `setSelectionMode` method. Use instead the approach above or `editor.AS.setSelectionMode(...)`.

3. Added new overloads for the `Editor` class `constructor`. You can now also provide custom components (`AreaSelector`, `RegionsManager` or `FilterPipeline`). E.g., to create `Editor` with custom `RegionsManager`:
    ```js
    let editor = new ct.Editor(sz, null, regionsManager);
    ```
    Note: editor will override the `callbacks` properties for `AreaSelector` and `RegionsManager` to ensure they crossreference and can work together.  