(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/canvastools/ts/ct.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/canvastools/css/canvastools.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader!./src/canvastools/css/canvastools.css ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/* CanvasTools.css */\r\n\r\n/* 1. Editor */\r\n/* 1.1. Cursors */\r\n.CanvasToolsEditor {\r\n    --cursor-pointer: -webkit-image-set(url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABUklEQVRoQ+3YMW6EMBAF0NkTmNOkTkVtCjdUcIFcAY4CNQ1HSNqkSx8JpBwATpDIllhptezCekg8XzIVErI1bz62JZ+MMa9d1z0T6HMioh9jzBsqwgFs81ERDqCUonmeIREOUFUVDcNAbdvCIc6Auq6pKAo4xAXArgU0xBUADbEKQELcBKAg7gIQEJsA6YhdAMmI3QCpiIcAEhEPA6QhvACSEN4AKQgWQAKCDQiNOAQQEnEYIBTiUEAIxOGA/0bsApRlSU3TeN0c/fVtxyZgKT5N0y+l1LePIsuylzzPP33Gbo25C1iK11p/9H3/tDVZiO83AQjF24atAlCKXwUgFX8FQCv+AjCOo9sqJS/YtU3CrYEkSWiaJrjizwnYF7TOL2m4BFCLdwlord+lHlJ7DkabAPQTAaHjiwnEBJgdiL8Qs4Hs4TEBdguZE8QEmA1kD/8FUOpiQO9zcnQAAAAASUVORK5CYII=') 2x), pointer;\r\n    --cursor-move: -webkit-image-set(url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACgElEQVRoQ+2ZS27CMBCGyQFygnZJb1Ep6SY3yJpHeweWQNVjVAHWvkE2hXtQVlwAcQCqiQhygsceP8bqAkuoqpqM/88ez/wuySDwmE6n38fjMavr+iVwaGW4JOQkIL6qqneIWRTFPgZEMIBW/Gg0atZks9lEgQgCIItfr9cNwHg8jgLhDaAS36ZlDAgvAJ34WBDOABTxMSCcAGzEc0NYA7iI54SwApDrvKp/zOfzwWKxaP4EP5fLJdpmQvUJMsBsNns9HA5fmCIhRKYCKMtyh72Tpum+qqoPn2ZKAoCVP5/PQyFErpnsguwAOkdZltvT6fTk07GNAG3awEpyAMDO+aSTFkDOeU4AH++EAsjVBnwNJwD4J1fvpATol8okSVgBLpeLs3e6A1DV+RgArgawA4A1qVgALhA3AF2HBQDKsGlkcjxIIXnYuNhGmcketN3VBJHn+QA+MLbbbfOhDFV8KkRiEk8RwPUMBeIGAA+vVisuLU5xJ5PJAG54RVH81nU9VAXppBAGoTNlctAsyzoptNuhNqijBc5Of1DEwzt3h1gFEfsQU8V3AOTD3IeIWUZtxN8BYBCxAGzFKwFUEDEAXMSjAH0IqAScZg5S1lRtsDL2n+w0Wip1NdjoESJdaJzEa1NIpma+Uj5jTYrS/Yw70Aa5Xuo/saBCiDfkUv+DvZOm6SHKpb4VEPjfKs5pIy8IeQf6EC7eybVUeh1i1cvtTthAcIgnH2JfCC7xXgA67yQDc4r3BjBBcIsPAoBBxBAfDKAPAb+7ehtK8/Iqo7oJel+zBqnzJiDrPmAKeP2iO/exB6Y52HbAZuJQzwbfgVDCqHEeANSV4nrusQNcK0uN+wdgZhRePQu00wAAAABJRU5ErkJggg==') 2x) 8 8, move;\r\n    --cursor-resize: -webkit-image-set(url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADKElEQVRoQ+2ZK6waQRSGB8W25iJBgWiTrQKNKWo1ZF1LwuM2teARgMCDbxdIqCSgUSgsoLqiTWhCAhLUBbXN2bBkgN15MWy5KVjm8X9zHvMPBJDkT7FY/LZcLj+ORqP3kpd2XS4gcxMQbxjGM6ypadovPyCkATjic7mcfSbdbtcXCCkAuPhOp2MD5PN5XyCuBnAT76SlHxBXAZDE+wUhDMAi3g8IIQBHfCgUQuVymamRNZtNtNlspBc2NwDeKpmUuwyS2WK5AURF32reA+BWJ8u6LjUCh5z/wrqgyLhDTbwTmUsEwAqWCiqyOTbHEi1sT2Fn3ebmAKIG0FWYI/7p6Qltt1tYmwoAcyaTySfTNN/ABFVVX5LJZM8wjK8M0bGcvXgjcSEMv2FjsRiq1+tEgEqlEu33+z9BeDweR6lUytY7Ho/RfD63QXRd/9BoNP4QQKxqtYoWiwW3ATwBOLcHtVqNCgACV6uVAi40nU6faBwOh7YrjUQiL6ZpvqUBwH68BvAI4OZtaADZbHbQ6/XSg8HgQrwjFiAymQwqFovfDcPw6mZ2BGA/XituA3gZMxoAnH4wGFRmsxkxzROJBNrv96QonADwQARIrpIGgBCySqUSAqNG+oDha7VapFq6AGCFOAJA7rXb7RMddwTwezQauV50Jyl0DkEDgBRSFEWZTqcsKbRzWqzLYFIKeYo/CamTSjgEDcCHIiaKv8jJcwgagHNhrddrBdLPrY0WCgUUDodJpw/LHCOAtVGqeNeiwiGi0Sj1HjhcZKZpmgp0G/wig+6kqupO13WV8yJjEu/ZFfAnIzwDOazEZwA5RGaXTCZ/EHo/XgoWPE8PT05m8URh/8jMcYmnnqzPdppbPBUAu6Vf54OG2Nzv5Euqz78TnZ4y/j8AST9sCRWsWxiEIoDfE+BGWT7gWOF5qmmaNPFMXchLnJt38hrLaw9YDsQZIxQBZzILxC3FXxUBFohbi5cCgF12z7gV90O8NIBzCMuynJ9HpBastC5EK2z4Xna38drzqiJ2W/TwR3fK6w3L02FYxkoHYNlU5pgHgMzTFFnrEQGRU5M559VH4C9ocYlPRB5IuQAAAABJRU5ErkJggg==') 2x) 8 8, nesw-resize;\r\n    --cursor-delete: -webkit-image-set(url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABn0lEQVRoQ+3YMW6EMBAAwL0XmNekhYraFG6o4AP5AvATqGl4ArRJlz4SSHkAvIDIljjlBHesAQevhKuTzpidXa8R3IQQdVmWHhAdNwAYhRANVYQCyORTRSgAYwyGYSCJUIAkSaBtWyiKghziDkjTFKIoIod4AMhe0ESo/tk45L13jxlAEzG6rguehz+F67qGpmnkbcwBNBCqf+T2ww45N8sy8wAkwm4AAjHK7aO7heQ2Mr6F/m6JF41tZxMv7WfN0wnbErvnLZ5Cz1a1EaEFQPTE7ozqLqANsA2xCWATYjPAFsQugA2I3YCzEYcAzkQcBjgLcSjgDMThgP9GoABxHEOe57oPSTXf9NeOVcAUvO/734yxny2KIAjewzD82nLt2jUvAVPwnPPPqqre1hY74/+nAArBT29Fs9dCKsEvAigFPwNQC/4B0HWdOiptbtilQ0I1seM40Pc9ueDvFZA/qGV+qoaqANXgVQU45x+2PqQwD8ZDPrBibmRqzgUwlVnsulcFsJkyNe+qgKnMYte9KoDNlKl5VwVMZRa7LvkK/AIya4BAvmH9YQAAAABJRU5ErkJggg==') 2x), pointer;\r\n    --cursor-add: -webkit-image-set(url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACEElEQVRoQ+2YsW7CMBCGnZEs4Wm6hol2DEOkKkMEL9BXAN4EmCqxMLZbsrZb90og9QFggTHVWZgGY+JLbNexlJOQIsU+33f/ne3gxXGcrdfrAXHUPEJIEcdxrgNitVo9H4/HRz4Xvu+/p2n6aiJHFAAc64A4qxnygerwfQ+eAgRBQA6HgzIEAygKmhNqnucp+61SjgJMp1Oy3W7JcrlUWswqwGw2I+PxWAnCOgBIVRPir1ZKOvMldKcEQH1lu5QQKMCsBkQRhiEZDK534bKv8jP4z7KM5HlO20M5+rMT2gP8QkgI4dyqwGCd+XxuHgBZTu0GQEAUUD58CYGizCDjsJUygxKCn/ESKpdBRTm1s4lFNYzpiVZso1UNKINoPYCsJ5wAqIKwdpkTnQOyQ0ZUTnCdPp1OT/zcXq/3ZvQ63QRAVk6yBOh6L7xK1HEua+w6vpqMVQawrYQWAJsQ2gBsQWgFsAGhHeC/IVAAk8mELBaLJpuE0jc2ZkEpAAt+OBx+B0Hwg3HKjxmNRi9Jknw1mSubUwnAgo+i6HOz2TzInNl4fxfAheDZV9HNZ6ErwQsBXAr+BsC14K8Adrsd3Srb3LCiTYI2cb/fJ/v93rngLwrAg2uZZ2pQBVwNnioQRdFHWw8pzMGo5Q9WzEKmxnQApjKL9dspgM2UqXGdAqYyi/XbKYDNlKlxnQKmMov167wCv7Mu7kBLP7biAAAAAElFTkSuQmCC') 2x), pointer;\r\n}\r\n\r\n/* 1.2. Layout */\r\n.CanvasToolsEditor {\r\n    display: grid;\r\n    grid-template-rows: 1fr;\r\n    grid-template-columns: 1fr; \r\n    width: 100%;\r\n    height: 100%;\r\n    box-sizing: content-box;\r\n}\r\n\r\n.CanvasToolsEditor * {\r\n    box-sizing: content-box;\r\n}\r\n\r\n.CanvasToolsEditor canvas {\r\n    position: relative;\r\n    grid-row: 1;\r\n    grid-column: 1;\r\n    z-index: 100;\r\n    width: 100%;\r\n    height: 100%;\r\n    pointer-events: none;\r\n    background-color: #111;\r\n}\r\n\r\n.CanvasToolsEditor svg {\r\n    position: relative;\r\n    grid-row: 1;\r\n    grid-column: 1;\r\n    z-index: 101;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.CanvasToolsEditor svg {\r\n    cursor: var(--cursor-pointer);\r\n}\r\n\r\n/* 2. RegionsManager\r\n\r\n.regionManager\r\n-->.regionStyle\r\n    --> .tagsLayer\r\n    --> .dragLayer\r\n    --> .anchorsLayer\r\n    \r\n--> .menuLayer\r\n    --> .menuRectStyle\r\n*/\r\n\r\n/* 2.1. General settings and layout */\r\n.regionManager {\r\n    pointer-events: none;\r\n}\r\n\r\n.regionStyle {\r\n    pointer-events: visiblePainted;\r\n}\r\n\r\n.dragRectStyle {\r\n    fill: transparent; \r\n    stroke-width: 0;\r\n    pointer-events: all;\r\n    cursor: var(--cursor-move);\r\n}\r\n\r\n.dragPointStyle {\r\n    stroke-width: 0;\r\n    pointer-events: all;\r\n    cursor: var(--cursor-move);\r\n    filter: url(#black-glow);\r\n}\r\n\r\n.tagsLayer {\r\n    pointer-events: none;\r\n}\r\n\r\n.primaryTagRectStyle {\r\n    stroke-width: 2;\r\n    stroke-dasharray: 0.5 4;\r\n    stroke-linecap: round;\r\n    filter: url(#black-glow);\r\n}\r\n\r\n.primaryTagPointStyle {\r\n    stroke-width: 1; \r\n}\r\n\r\n.primaryTagTextStyle {\r\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n    font-size: 9pt;\r\n    fill: #fff;\r\n    user-select: none;\r\n}\r\n\r\n.secondaryTagStyle {\r\n    stroke-width: 0;\r\n    pointer-events: none;\r\n}\r\n\r\n.anchorStyle {\r\n    stroke-width: 2;\r\n}\r\n\r\n.anchorStyle.ghost {\r\n    cursor: var(--cursor-resize);\r\n}\r\n\r\n.anchorStyle.ghost.delete {\r\n    cursor: var(--cursor-delete);\r\n}\r\n\r\n.anchorStyle.ghost.add {\r\n    cursor: var(--cursor-add);\r\n}\r\n\r\n.anchorStyle.ghost {\r\n    stroke-width: 0;\r\n}\r\n\r\n.primaryTagBoundRectStyle {\r\n    stroke-width: 0.5;\r\n}\r\n\r\n.primaryTagPolylineStyle, .primaryTagPolygonStyle {\r\n    stroke-width: 2;\r\n    stroke-linecap: round;\r\n    stroke-dasharray: 0.5 4;\r\n}\r\n\r\n/* 2.2. Default colors */\r\n.regionManager {\r\n    --default-color-pure: rgb(128, 128, 128);\r\n    --default-color-accent: rgba(128, 128, 128, 0.8);\r\n    --default-color-dark: rgba(64, 64, 64, 0.8);\r\n    --default-color-shadow: rgba(128, 128, 128, 0.4);\r\n    --default-color-highlight: rgba(128, 128, 128, 0.2);\r\n    --default-color-white: rgb(255, 255, 255);\r\n    --default-color-transparent: rgb(255, 255, 255, 0);\r\n    --default-color-ghost: rgb(255, 255, 255, 0.5);\r\n    --default-color-delete: rgba(216, 24, 65, 1.0);\r\n    --default-color-add: rgba(21, 127, 240, 1.0);\r\n}\r\n\r\n/* 2.2.1. Shared colors */\r\n.secondaryTagStyle {\r\n    fill: var(--default-color-accent);\r\n}\r\n\r\n.anchorStyle {\r\n    stroke: var(--default-color-dark);\r\n    fill: var(--default-color-pure);\r\n}\r\n\r\n.regionStyle:hover .anchorStyle {\r\n    stroke: var(--default-color-white);\r\n}\r\n\r\n.anchorStyle.ghost {\r\n    fill: var(--default-color-transparent);\r\n}\r\n\r\n.anchorStyle.ghost:hover,\r\n.regionStyle.selected .anchorStyle.ghost,\r\n.regionStyle.selected .anchorStyle.ghost:hover {\r\n    fill: var(--default-color-ghost);\r\n}\r\n\r\n.anchorStyle:hover {\r\n    stroke: var(--default-color-white);\r\n}\r\n\r\n/* 2.2.2. Rect region colors */\r\n.primaryTagRectStyle {\r\n    fill: var(--default-color-shadow);\r\n    stroke:var(--default-color-accent);\r\n}\r\n\r\n.regionStyle:hover .primaryTagRectStyle {\r\n    fill: var(--default-color-highlight);\r\n    stroke: var(--default-color-white);\r\n}\r\n\r\n.regionStyle.selected .primaryTagRectStyle {\r\n    fill: var(--default-color-highlight);\r\n    stroke-dasharray: none;\r\n}\r\n\r\n.primaryTagTextBGStyle {\r\n    fill: var(--default-color-dark);\r\n}\r\n\r\n.anchorBoneStyle {\r\n    fill: var(--default-color-transparent);\r\n}\r\n\r\n/* 2.2.3. Point region  colors */\r\n.primaryTagPointStyle {\r\n    fill: var(--default-color-pure);\r\n    stroke:var(--default-color-white);\r\n}\r\n\r\n.dragPointStyle {\r\n    fill: var(--default-color-ghost);\r\n    opacity: 0.5;\r\n}\r\n\r\n.regionStyle:hover .dragPointStyle,\r\n.regionStyle.selected .dragPointStyle {\r\n    fill: var(--default-color-ghost);\r\n    opacity: 1.0;\r\n}\r\n\r\n/* 2.2.4. Polyline, polygon region colors */\r\n.primaryTagBoundRectStyle {\r\n    fill: var(--default-color-shadow);\r\n    stroke:var(--default-color-accent);\r\n    opacity: 0.25;\r\n}\r\n\r\n.regionStyle.selected .primaryTagBoundRectStyle {\r\n    fill: var(--default-color-highlight);\r\n}\r\n\r\n.regionStyle:hover .primaryTagBoundRectStyle {\r\n    fill: var(--default-color-highlight);\r\n    stroke: var(--default-color-white);\r\n}\r\n\r\n.primaryTagPolylineStyle {\r\n    fill: var(--default-color-transparent);\r\n    stroke: var(--default-color-pure);\r\n}\r\n\r\n.regionStyle.selected .primaryTagPolylineStyle {\r\n    filter: url(#black-glow);\r\n    stroke-dasharray: none;\r\n}\r\n\r\n.primaryTagPolygonStyle {\r\n    fill: var(--default-color-shadow);\r\n    stroke: var(--default-color-pure);\r\n}\r\n\r\n.regionStyle.selected .primaryTagPolygonStyle {\r\n    fill: var(--default-color-highlight);\r\n    filter: url(#black-glow);\r\n    stroke-dasharray: none;\r\n}\r\n\r\n.regionStyle:hover .primaryTagPolygonStyle {\r\n    fill: var(--default-color-highlight);\r\n}\r\n\r\n.regionStyle:hover .anchorStyle.ghost.delete,\r\n.regionStyle.selected .anchorStyle.ghost.delete,\r\n.anchorStyle.ghost.delete,\r\n.anchorStyle.ghost.delete:hover {\r\n    stroke: var(--default-color-delete);\r\n    stroke-width: 2px;\r\n    fill: var(--default-color-transparent);\r\n}\r\n\r\n.regionStyle:hover .anchorStyle.ghost.add,\r\n.regionStyle.selected .anchorStyle.ghost.add,\r\n.anchorStyle.ghost.add,\r\n.anchorStyle.ghost.add:hover {\r\n    stroke: var(--default-color-add);\r\n    stroke-width: 2px;\r\n    fill: var(--default-color-transparent);\r\n}\r\n\r\n.anchorLineStyle {\r\n    fill: none;\r\n    stroke-width: 5;\r\n    stroke: var(--default-color-transparent);  \r\n}\r\n\r\nsvg:not(:root) .menuLayer {\r\n    overflow: visible;\r\n}\r\n\r\n.menuRectStyle { \r\n    stroke-width:0;\r\n    fill: rgba(64, 64, 64, 0.8);\r\n    filter: url(#black-glow); \r\n}\r\n\r\n.menuItemBack {\r\n    stroke-width: 1.5;\r\n    stroke: rgba(198, 198, 198, 0.2);\r\n    fill:  rgb(32, 32, 32);\r\n}\r\n\r\n.menuIcon {\r\n    font-family: 'Segoe UI Emoji', Tahoma, Geneva, Verdana, sans-serif;\r\n    font-size: 10pt;\r\n    fill: rgb(64, 64, 64);\r\n}\r\n\r\n.menuItem {\r\n    stroke-width: 1.5;\r\n    stroke: rgba(198, 198, 198, 0.2);\r\n    fill:transparent;\r\n}\r\n\r\n.menuItem:hover {\r\n    stroke: rgba(198, 198, 198, 0.8);\r\n}\r\n\r\n/* Freezing regions */ \r\n\r\n.regionManager.frozen .regionStyle.old,\r\n.regionManager.frozen .regionStyle.old .dragRectStyle,\r\n.regionManager.frozen .regionStyle.old .dragPointStyle {\r\n    pointer-events: none;\r\n}\r\n\r\n.regionManager.frozen .regionStyle.old .dragRectStyle, \r\n.regionManager.frozen .regionStyle.old .anchorStyle.TL, \r\n.regionManager.frozen .regionStyle.old .anchorStyle.BR, \r\n.regionManager.frozen .regionStyle.old .anchorStyle.TR, \r\n.regionManager.frozen .regionStyle.old .anchorStyle.BL {\r\n    cursor: default; \r\n}\r\n\r\n.regionManager.frozen .anchorStyle.ghost {\r\n    display: none;\r\n}\r\n\r\n.regionManager.frozen .regionStyle.old, \r\n.regionManager.frozen .regionStyle.old:hover{\r\n    opacity: 0.5;\r\n}\r\n\r\n.regionManager.frozen .regionStyle.old .primaryTagRectStyle,\r\n.regionManager.frozen .regionStyle.old .primaryTagPointStyle,\r\n.regionManager.frozen .regionStyle.old .primaryTagPolylineStyle,\r\n.regionManager.frozen .regionStyle.old .primaryTagPolygonStyle {\r\n    stroke-width: 1;\r\n    stroke-dasharray: 0 0;\r\n}\r\n\r\n.regionManager.frozen .regionStyle.old .anchorStyle {\r\n    display: none;\r\n}\r\n\r\n.regionManager.frozen .regionStyle.old .primaryTagTextStyle,\r\n.regionManager.frozen .regionStyle.old .primaryTagTextBGStyle {\r\n    opacity: 0.25;\r\n}\r\n\r\n/* AreaSelector\r\n\r\n.areaSelector\r\n-->.rectSelector\r\n    --> .maskStyle\r\n        [mask]\r\n            .maskInStyle\r\n            .maskOutStyle\r\n        .crossStyle\r\n            line\r\n            line\r\n-->.rectCopySelector\r\n    --> .crossStyle\r\n            line\r\n            line\r\n        .copyRectStyle\r\n-->.pointSelector\r\n    --> .crossStyle\r\n        .pointStyle\r\n-->.polylineSelector\r\n    --> .polylineStyle\r\n        .polylineGroupStyle\r\n        --> .polylinePointStyle\r\n        .nextSegmentStyle\r\n        .nextPointStyle\r\n-->.polygonSelector\r\n    --> .polygonStyle\r\n        .polygonGroupStyle\r\n        --> .polygonPointStyle\r\n        .nextSegmentStyle\r\n        .nextPointStyle\r\n*/\r\n\r\n*/\r\n#selectionOverlay {\r\n    position: relative;\r\n    width: 100%;\r\n    height: 100%;\r\n    pointer-events: none;\r\n}\r\n\r\n.crossStyle line {\r\n    stroke-width:1;\r\n    stroke-dasharray: 3 3;\r\n    stroke: #666;\r\n    pointer-events: none; \r\n}\r\n\r\n.rectSelector .maskStyle {\r\n    fill: #000;\r\n    fill-opacity: 0.5;\r\n    stroke-width: 0;\r\n    pointer-events: none;\r\n}\r\n\r\n.maskInStyle {\r\n    fill: #fff;\r\n    stroke-width: 0;\r\n    visibility: visible;\r\n    pointer-events: none;\r\n}\r\n\r\n.maskOutStyle {\r\n    /* Transparent crop*/\r\n    fill: #000;\r\n    stroke-width: 0;\r\n    visibility: visible;\r\n    pointer-events: none;\r\n}\r\n\r\n.rectCopySelector .copyRectStyle {\r\n    stroke-width:1;\r\n    stroke: #666;\r\n    fill: transparent;\r\n    pointer-events: none; \r\n}\r\n\r\n.pointSelector .pointStyle {\r\n    stroke-width:2;\r\n    stroke: rgba(21, 127, 240, 1.0);\r\n    fill: transparent;\r\n    pointer-events: none; \r\n}\r\n\r\n.polylineSelector .polylineStyle {\r\n    fill: transparent;\r\n    stroke-width: 2px;\r\n    stroke:  rgba(21, 127, 240, 0.5);\r\n    pointer-events: none;\r\n}\r\n\r\n.polylineSelector .polylinePointStyle {\r\n    fill:  rgba(21, 127, 240, 1.0);\r\n    stroke-width: 0;\r\n    pointer-events: none;\r\n}\r\n\r\n.polylineSelector .nextSegmentStyle {\r\n    stroke-width:2;\r\n    stroke-dasharray: 3 3;\r\n    stroke: rgba(21, 127, 240, 1.0);\r\n    pointer-events: none;\r\n}\r\n.polylineSelector .nextPointStyle {\r\n    stroke-width:2;\r\n    r: 6px;\r\n    stroke: rgba(21, 127, 240, 1.0);\r\n    fill: transparent;\r\n    pointer-events: none;\r\n}\r\n\r\n.polygonSelector .polygonStyle {\r\n    fill: rgba(255,255,255, 0.2);\r\n    stroke-width: 2px;\r\n    stroke:  rgba(21, 127, 240, 0.5);\r\n    pointer-events: none;\r\n}\r\n\r\n.polygonSelector .polygonPointStyle {\r\n    fill:  rgba(21, 127, 240, 1.0);\r\n    stroke-width: 0;\r\n    pointer-events: none;\r\n}\r\n\r\n.polygonSelector .nextSegmentStyle {\r\n    stroke-width:2;\r\n    stroke-dasharray: 3 3;\r\n    stroke: rgba(21, 127, 240, 1.0);\r\n    pointer-events: none;\r\n}\r\n.polygonSelector .nextPointStyle {\r\n    stroke-width:2;\r\n    r: 6px;\r\n    stroke: rgba(21, 127, 240, 1.0);\r\n    fill: transparent;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Toolbar \r\n\r\n.toolbarLayer\r\n--> .toolbarBGStyle\r\n--> .iconsLayerStyle\r\n    --> .iconStyle\r\n        --> .iconBGRectStyle\r\n            .iconImageStyle\r\n*/\r\n.toolbarBGStyle {\r\n    fill: #666;\r\n}\r\n\r\n.iconStyle {\r\n    pointer-events: all;\r\n}\r\n\r\n.iconStyle.selector .iconBGRectStyle{\r\n    fill: transparent;\r\n}\r\n\r\n.iconStyle.selector:hover .iconBGRectStyle{\r\n    fill: rgba(68, 68, 68, 0.5);\r\n}\r\n\r\n.iconStyle.selector.selected .iconBGRectStyle {\r\n    fill: #333;\r\n}\r\n\r\n.iconStyle .iconImageStyle * {\r\n    stroke: #fff;\r\n}\r\n\r\n\r\n.iconStyle.switch .iconBGRectStyle{\r\n    fill: transparent;\r\n}\r\n\r\n.iconStyle.switch:hover .iconBGRectStyle{\r\n    fill: rgba(68, 68, 68, 0.5);\r\n}\r\n\r\n.iconStyle.switch .iconImageStyle * {\r\n    stroke: #333;\r\n}\r\n\r\n.iconStyle.switch.selected .iconImageStyle * {\r\n    stroke: rgb(14, 186, 253);\r\n    stroke-width: 1.5;\r\n}\r\n\r\n.iconStyle .iconImageStyle .accent-f {\r\n    fill: rgba(21, 127, 240, 1.0);\r\n}\r\n\r\n.iconStyle .iconImageStyle .accent-s {\r\n    stroke: rgba(21, 127, 240, 1.0);\r\n}\r\n\r\n.iconStyle.separator line {\r\n    stroke: #333;\r\n    stroke-width: 0.5px;\r\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/eve/eve.js":
/*!*********************************!*\
  !*** ./node_modules/eve/eve.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.5.4 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.5.4",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
        firstDefined = function () {
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        lastDefined = function () {
            var i = this.length;
            while (--i) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        objtos = Object.prototype.toString,
        Str = String,
        isArray = Array.isArray || function (ar) {
            return ar instanceof Array || objtos.call(ar) == "[object Array]";
        },
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
        eve = function (name, scope) {
            var oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event;
            out.firstDefined = firstDefined;
            out.lastDefined = lastDefined;
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out;
        };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = isArray(name) ? name : name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
     * eve.separator
     [ method ]

     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
     * here. Be aware that if you pass a string longer than one character it will be treated as
     * a list of characters.

     - separator (string) new separator. Empty string resets to default: `.` or `/`.
    \*/
    eve.separator = function (sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else {
            separator = /[\.\/]/;
        }
    };
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     - name (array) if you don’t want to use separators, you can use array of strings
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
        if (typeof f != "function") {
            return function () {};
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = isArray(name) ? name : Str(name).split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                    exist = true;
                    break;
                }
                !exist && e.f.push(f);
            }(names[i]));
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        }
        return cur;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events],
            inodes = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                        inodes.unshift({
                            n: e,
                            name: names[i]
                        });
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                        inodes.unshift({
                            n: e,
                            name: key
                        });
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for (i = 0, ii = inodes.length; i < ii; i++) {
            e = inodes[i];
            for (key in e.n[e.name].f) {
                // not empty (has listeners)
                continue prune;
            }
            for (key in e.n[e.name].n) {
                // not empty (has children)
                continue prune;
            }
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    glob.eve = eve;
     true && module.exports ? module.exports = eve :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return eve; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(typeof window != "undefined" ? window : this);


/***/ }),

/***/ "./node_modules/snapsvg-cjs/dist/snap.svg-cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/snapsvg-cjs/dist/snap.svg-cjs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

window.eve = __webpack_require__(/*! eve */ "./node_modules/eve/eve.js")

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var mina = (function (eve) {
    var animations = {},
    requestAnimFrame = window.requestAnimationFrame       ||
                       window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame    ||
                       window.oRequestAnimationFrame      ||
                       window.msRequestAnimationFrame     ||
                       function (callback) {
                           setTimeout(callback, 16, new Date().getTime());
                           return true;
                       },
    requestID,
    isArray = Array.isArray || function (a) {
        return a instanceof Array ||
            Object.prototype.toString.call(a) == "[object Array]";
    },
    idgen = 0,
    idprefix = "M" + (+new Date).toString(36),
    ID = function () {
        return idprefix + (idgen++).toString(36);
    },
    diff = function (a, b, A, B) {
        if (isArray(a)) {
            res = [];
            for (var i = 0, ii = a.length; i < ii; i++) {
                res[i] = diff(a[i], b, A[i], B);
            }
            return res;
        }
        var dif = (A - a) / (B - b);
        return function (bb) {
            return a + dif * (bb - b);
        };
    },
    timer = Date.now || function () {
        return +new Date;
    },
    sta = function (val) {
        var a = this;
        if (val == null) {
            return a.s;
        }
        var ds = a.s - val;
        a.b += a.dur * ds;
        a.B += a.dur * ds;
        a.s = val;
    },
    speed = function (val) {
        var a = this;
        if (val == null) {
            return a.spd;
        }
        a.spd = val;
    },
    duration = function (val) {
        var a = this;
        if (val == null) {
            return a.dur;
        }
        a.s = a.s * val / a.dur;
        a.dur = val;
    },
    stopit = function () {
        var a = this;
        delete animations[a.id];
        a.update();
        eve("mina.stop." + a.id, a);
    },
    pause = function () {
        var a = this;
        if (a.pdif) {
            return;
        }
        delete animations[a.id];
        a.update();
        a.pdif = a.get() - a.b;
    },
    resume = function () {
        var a = this;
        if (!a.pdif) {
            return;
        }
        a.b = a.get() - a.pdif;
        delete a.pdif;
        animations[a.id] = a;
        frame();
    },
    update = function () {
        var a = this,
            res;
        if (isArray(a.start)) {
            res = [];
            for (var j = 0, jj = a.start.length; j < jj; j++) {
                res[j] = +a.start[j] +
                    (a.end[j] - a.start[j]) * a.easing(a.s);
            }
        } else {
            res = +a.start + (a.end - a.start) * a.easing(a.s);
        }
        a.set(res);
    },
    frame = function (timeStamp) {
        // Manual invokation?
        if (!timeStamp) {
            // Frame loop stopped?
            if (!requestID) {
                // Start frame loop...
                requestID = requestAnimFrame(frame);
            }
            return;
        }
        var len = 0;
        for (var i in animations) if (animations.hasOwnProperty(i)) {
            var a = animations[i],
                b = a.get(),
                res;
            len++;
            a.s = (b - a.b) / (a.dur / a.spd);
            if (a.s >= 1) {
                delete animations[i];
                a.s = 1;
                len--;
                (function (a) {
                    setTimeout(function () {
                        eve("mina.finish." + a.id, a);
                    });
                }(a));
            }
            a.update();
        }
        requestID = len ? requestAnimFrame(frame) : false;
    },
    /*\
     * mina
     [ method ]
     **
     * Generic animation of numbers
     **
     - a (number) start _slave_ number
     - A (number) end _slave_ number
     - b (number) start _master_ number (start time in general case)
     - B (number) end _master_ number (end time in general case)
     - get (function) getter of _master_ number (see @mina.time)
     - set (function) setter of _slave_ number
     - easing (function) #optional easing function, default is @mina.linear
     = (object) animation descriptor
     o {
     o         id (string) animation id,
     o         start (number) start _slave_ number,
     o         end (number) end _slave_ number,
     o         b (number) start _master_ number,
     o         s (number) animation status (0..1),
     o         dur (number) animation duration,
     o         spd (number) animation speed,
     o         get (function) getter of _master_ number (see @mina.time),
     o         set (function) setter of _slave_ number,
     o         easing (function) easing function, default is @mina.linear,
     o         status (function) status getter/setter,
     o         speed (function) speed getter/setter,
     o         duration (function) duration getter/setter,
     o         stop (function) animation stopper
     o         pause (function) pauses the animation
     o         resume (function) resumes the animation
     o         update (function) calles setter with the right value of the animation
     o }
    \*/
    mina = function (a, A, b, B, get, set, easing) {
        var anim = {
            id: ID(),
            start: a,
            end: A,
            b: b,
            s: 0,
            dur: B - b,
            spd: 1,
            get: get,
            set: set,
            easing: easing || mina.linear,
            status: sta,
            speed: speed,
            duration: duration,
            stop: stopit,
            pause: pause,
            resume: resume,
            update: update
        };
        animations[anim.id] = anim;
        var len = 0, i;
        for (i in animations) if (animations.hasOwnProperty(i)) {
            len++;
            if (len == 2) {
                break;
            }
        }
        len == 1 && frame();
        return anim;
    };
    /*\
     * mina.time
     [ method ]
     **
     * Returns the current time. Equivalent to:
     | function () {
     |     return (new Date).getTime();
     | }
    \*/
    mina.time = timer;
    /*\
     * mina.getById
     [ method ]
     **
     * Returns an animation by its id
     - id (string) animation's id
     = (object) See @mina
    \*/
    mina.getById = function (id) {
        return animations[id] || null;
    };

    /*\
     * mina.linear
     [ method ]
     **
     * Default linear easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.linear = function (n) {
        return n;
    };
    /*\
     * mina.easeout
     [ method ]
     **
     * Easeout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeout = function (n) {
        return Math.pow(n, 1.7);
    };
    /*\
     * mina.easein
     [ method ]
     **
     * Easein easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easein = function (n) {
        return Math.pow(n, .48);
    };
    /*\
     * mina.easeinout
     [ method ]
     **
     * Easeinout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeinout = function (n) {
        if (n == 1) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        var q = .48 - n / 1.04,
            Q = Math.sqrt(.1734 + q * q),
            x = Q - q,
            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
        return (1 - t) * 3 * t * t + t * t * t;
    };
    /*\
     * mina.backin
     [ method ]
     **
     * Backin easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backin = function (n) {
        if (n == 1) {
            return 1;
        }
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
    };
    /*\
     * mina.backout
     [ method ]
     **
     * Backout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backout = function (n) {
        if (n == 0) {
            return 0;
        }
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
    };
    /*\
     * mina.elastic
     [ method ]
     **
     * Elastic easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.elastic = function (n) {
        if (n == !!n) {
            return n;
        }
        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
            (2 * Math.PI) / .3) + 1;
    };
    /*\
     * mina.bounce
     [ method ]
     **
     * Bounce easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.bounce = function (n) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (n < 1 / p) {
            l = s * n * n;
        } else {
            if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + .75;
            } else {
                if (n < 2.5 / p) {
                    n -= 2.25 / p;
                    l = s * n * n + .9375;
                } else {
                    n -= 2.625 / p;
                    l = s * n * n + .984375;
                }
            }
        }
        return l;
    };
    window.mina = mina;
    return mina;
})(typeof eve == "undefined" ? function () {} : eve);

// Copyright (c) 2013 - 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var Snap = (function(root) {
Snap.version = "0.5.1";
/*\
 * Snap
 [ method ]
 **
 * Creates a drawing surface or wraps existing SVG element.
 **
 - width (number|string) width of surface
 - height (number|string) height of surface
 * or
 - DOM (SVGElement) element to be wrapped into Snap structure
 * or
 - array (array) array of elements (will return set of elements)
 * or
 - query (string) CSS query selector
 = (object) @Element
\*/
function Snap(w, h) {
    if (w) {
        if (w.nodeType) {
            return wrap(w);
        }
        if (is(w, "array") && Snap.set) {
            return Snap.set.apply(Snap, w);
        }
        if (w instanceof Element) {
            return w;
        }
        if (h == null) {
            try {
                w = glob.doc.querySelector(String(w));
                return wrap(w);
            } catch (e) {
                return null;
            }
        }
    }
    w = w == null ? "100%" : w;
    h = h == null ? "100%" : h;
    return new Paper(w, h);
}
Snap.toString = function () {
    return "Snap v" + this.version;
};
Snap._ = {};
var glob = {
    win: root.window,
    doc: root.window.document
};
Snap._.glob = glob;
var has = "hasOwnProperty",
    Str = String,
    toFloat = parseFloat,
    toInt = parseInt,
    math = Math,
    mmax = math.max,
    mmin = math.min,
    abs = math.abs,
    pow = math.pow,
    PI = math.PI,
    round = math.round,
    E = "",
    S = " ",
    objectToString = Object.prototype.toString,
    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    separator = Snap._.separator = /[,\s]+/,
    whitespace = /[\s]/g,
    commaSpaces = /[\s]*,[\s]*/,
    hsrg = {hs: 1, rg: 1},
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\s]*,?[\s]*/ig,
    idgen = 0,
    idprefix = "S" + (+new Date).toString(36),
    ID = function (el) {
        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
    },
    xlink = "http://www.w3.org/1999/xlink",
    xmlns = "http://www.w3.org/2000/svg",
    hub = {},
    /*\
     * Snap.url
     [ method ]
     **
     * Wraps path into `"url('<path>')"`.
     - value (string) path
     = (string) wrapped path
    \*/
    URL = Snap.url = function (url) {
        return "url('#" + url + "')";
    };

function $(el, attr) {
    if (attr) {
        if (el == "#text") {
            el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
        }
        if (el == "#comment") {
            el = glob.doc.createComment(attr.text || attr["#text"] || "");
        }
        if (typeof el == "string") {
            el = $(el);
        }
        if (typeof attr == "string") {
            if (el.nodeType == 1) {
                if (attr.substring(0, 6) == "xlink:") {
                    return el.getAttributeNS(xlink, attr.substring(6));
                }
                if (attr.substring(0, 4) == "xml:") {
                    return el.getAttributeNS(xmlns, attr.substring(4));
                }
                return el.getAttribute(attr);
            } else if (attr == "text") {
                return el.nodeValue;
            } else {
                return null;
            }
        }
        if (el.nodeType == 1) {
            for (var key in attr) if (attr[has](key)) {
                var val = Str(attr[key]);
                if (val) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), val);
                    } else if (key.substring(0, 4) == "xml:") {
                        el.setAttributeNS(xmlns, key.substring(4), val);
                    } else {
                        el.setAttribute(key, val);
                    }
                } else {
                    el.removeAttribute(key);
                }
            }
        } else if ("text" in attr) {
            el.nodeValue = attr.text;
        }
    } else {
        el = glob.doc.createElementNS(xmlns, el);
    }
    return el;
}
Snap._.$ = $;
Snap._.id = ID;
function getAttrs(el) {
    var attrs = el.attributes,
        name,
        out = {};
    for (var i = 0; i < attrs.length; i++) {
        if (attrs[i].namespaceURI == xlink) {
            name = "xlink:";
        } else {
            name = "";
        }
        name += attrs[i].name;
        out[name] = attrs[i].textContent;
    }
    return out;
}
function is(o, type) {
    type = Str.prototype.toLowerCase.call(type);
    if (type == "finite") {
        return isFinite(o);
    }
    if (type == "array" &&
        (o instanceof Array || Array.isArray && Array.isArray(o))) {
        return true;
    }
    return  type == "null" && o === null ||
            type == typeof o && o !== null ||
            type == "object" && o === Object(o) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
}
/*\
 * Snap.format
 [ method ]
 **
 * Replaces construction of type `{<name>}` to the corresponding argument
 **
 - token (string) string to format
 - json (object) object which properties are used as a replacement
 = (string) formatted string
 > Usage
 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
 |     x: 10,
 |     y: 20,
 |     dim: {
 |         width: 40,
 |         height: 50,
 |         "negative width": -40
 |     }
 | }));
\*/
Snap.format = (function () {
    var tokenRegex = /\{([^\}]+)\}/g,
        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
        replacer = function (all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == "function" && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + "";
            return res;
        };
    return function (str, obj) {
        return Str(str).replace(tokenRegex, function (all, key) {
            return replacer(all, key, obj);
        });
    };
})();
function clone(obj) {
    if (typeof obj == "function" || Object(obj) !== obj) {
        return obj;
    }
    var res = new obj.constructor;
    for (var key in obj) if (obj[has](key)) {
        res[key] = clone(obj[key]);
    }
    return res;
}
Snap._.clone = clone;
function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
    }
}
function cacher(f, scope, postprocessor) {
    function newf() {
        var arg = Array.prototype.slice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = newf.cache = newf.cache || {},
            count = newf.count = newf.count || [];
        if (cache[has](args)) {
            repush(count, args);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        count.length >= 1e3 && delete cache[count.shift()];
        count.push(args);
        cache[args] = f.apply(scope, arg);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
}
Snap._.cacher = cacher;
function angle(x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
        var x = x1 - x2,
            y = y1 - y2;
        if (!x && !y) {
            return 0;
        }
        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
    } else {
        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
    }
}
function rad(deg) {
    return deg % 360 * PI / 180;
}
function deg(rad) {
    return rad * 180 / PI % 360;
}
function x_y() {
    return this.x + S + this.y;
}
function x_y_w_h() {
    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
}

/*\
 * Snap.rad
 [ method ]
 **
 * Transform angle to radians
 - deg (number) angle in degrees
 = (number) angle in radians
\*/
Snap.rad = rad;
/*\
 * Snap.deg
 [ method ]
 **
 * Transform angle to degrees
 - rad (number) angle in radians
 = (number) angle in degrees
\*/
Snap.deg = deg;
/*\
 * Snap.sin
 [ method ]
 **
 * Equivalent to `Math.sin()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) sin
\*/
Snap.sin = function (angle) {
    return math.sin(Snap.rad(angle));
};
/*\
 * Snap.tan
 [ method ]
 **
 * Equivalent to `Math.tan()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) tan
\*/
Snap.tan = function (angle) {
    return math.tan(Snap.rad(angle));
};
/*\
 * Snap.cos
 [ method ]
 **
 * Equivalent to `Math.cos()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) cos
\*/
Snap.cos = function (angle) {
    return math.cos(Snap.rad(angle));
};
/*\
 * Snap.asin
 [ method ]
 **
 * Equivalent to `Math.asin()` only works with degrees, not radians.
 - num (number) value
 = (number) asin in degrees
\*/
Snap.asin = function (num) {
    return Snap.deg(math.asin(num));
};
/*\
 * Snap.acos
 [ method ]
 **
 * Equivalent to `Math.acos()` only works with degrees, not radians.
 - num (number) value
 = (number) acos in degrees
\*/
Snap.acos = function (num) {
    return Snap.deg(math.acos(num));
};
/*\
 * Snap.atan
 [ method ]
 **
 * Equivalent to `Math.atan()` only works with degrees, not radians.
 - num (number) value
 = (number) atan in degrees
\*/
Snap.atan = function (num) {
    return Snap.deg(math.atan(num));
};
/*\
 * Snap.atan2
 [ method ]
 **
 * Equivalent to `Math.atan2()` only works with degrees, not radians.
 - num (number) value
 = (number) atan2 in degrees
\*/
Snap.atan2 = function (num) {
    return Snap.deg(math.atan2(num));
};
/*\
 * Snap.angle
 [ method ]
 **
 * Returns an angle between two or three points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 - x3 (number) #optional x coord of third point
 - y3 (number) #optional y coord of third point
 = (number) angle in degrees
\*/
Snap.angle = angle;
/*\
 * Snap.len
 [ method ]
 **
 * Returns distance between two points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 = (number) distance
\*/
Snap.len = function (x1, y1, x2, y2) {
    return Math.sqrt(Snap.len2(x1, y1, x2, y2));
};
/*\
 * Snap.len2
 [ method ]
 **
 * Returns squared distance between two points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 = (number) distance
\*/
Snap.len2 = function (x1, y1, x2, y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
};
/*\
 * Snap.closestPoint
 [ method ]
 **
 * Returns closest point to a given one on a given path.
 - path (Element) path element
 - x (number) x coord of a point
 - y (number) y coord of a point
 = (object) in format
 {
    x (number) x coord of the point on the path
    y (number) y coord of the point on the path
    length (number) length of the path to the point
    distance (number) distance from the given point to the path
 }
\*/
// Copied from http://bl.ocks.org/mbostock/8027637
Snap.closestPoint = function (path, x, y) {
    function distance2(p) {
        var dx = p.x - x,
            dy = p.y - y;
        return dx * dx + dy * dy;
    }
    var pathNode = path.node,
        pathLength = pathNode.getTotalLength(),
        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
        best,
        bestLength,
        bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
            best = scan;
            bestLength = scanLength;
            bestDistance = scanDistance;
        }
    }

    // binary search for precise estimate
    precision *= .5;
    while (precision > .5) {
        var before,
            after,
            beforeLength,
            afterLength,
            beforeDistance,
            afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
            best = before;
            bestLength = beforeLength;
            bestDistance = beforeDistance;
        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
            best = after;
            bestLength = afterLength;
            bestDistance = afterDistance;
        } else {
            precision *= .5;
        }
    }

    best = {
        x: best.x,
        y: best.y,
        length: bestLength,
        distance: Math.sqrt(bestDistance)
    };
    return best;
}
/*\
 * Snap.is
 [ method ]
 **
 * Handy replacement for the `typeof` operator
 - o (…) any object or primitive
 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
 = (boolean) `true` if given value is of given type
\*/
Snap.is = is;
/*\
 * Snap.snapTo
 [ method ]
 **
 * Snaps given value to given grid
 - values (array|number) given array of values or step of the grid
 - value (number) value to adjust
 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
 = (number) adjusted value
\*/
Snap.snapTo = function (values, value, tolerance) {
    tolerance = is(tolerance, "finite") ? tolerance : 10;
    if (is(values, "array")) {
        var i = values.length;
        while (i--) if (abs(values[i] - value) <= tolerance) {
            return values[i];
        }
    } else {
        values = +values;
        var rem = value % values;
        if (rem < tolerance) {
            return value - rem;
        }
        if (rem > values - tolerance) {
            return value - rem + values;
        }
    }
    return value;
};
// Colour
/*\
 * Snap.getRGB
 [ method ]
 **
 * Parses color string as RGB object
 - color (string) color string in one of the following formats:
 # <ul>
 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
 # </ul>
 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) true if string can't be parsed
 o }
\*/
Snap.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    if (colour == "none") {
        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
    if (!colour) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    var res,
        red,
        green,
        blue,
        opacity,
        t,
        values,
        rgb = colour.match(colourRegExp);
    if (rgb) {
        if (rgb[2]) {
            blue = toInt(rgb[2].substring(5), 16);
            green = toInt(rgb[2].substring(3, 5), 16);
            red = toInt(rgb[2].substring(1, 3), 16);
        }
        if (rgb[3]) {
            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
            green = toInt((t = rgb[3].charAt(2)) + t, 16);
            red = toInt((t = rgb[3].charAt(1)) + t, 16);
        }
        if (rgb[4]) {
            values = rgb[4].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        }
        if (rgb[5]) {
            values = rgb[5].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsb2rgb(red, green, blue, opacity);
        }
        if (rgb[6]) {
            values = rgb[6].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsl2rgb(red, green, blue, opacity);
        }
        red = mmin(math.round(red), 255);
        green = mmin(math.round(green), 255);
        blue = mmin(math.round(blue), 255);
        opacity = mmin(mmax(opacity, 0), 1);
        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
        rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
        rgb.opacity = is(opacity, "finite") ? opacity : 1;
        return rgb;
    }
    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
}, Snap);
/*\
 * Snap.hsb
 [ method ]
 **
 * Converts HSB values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - b (number) value or brightness
 = (string) hex representation of the color
\*/
Snap.hsb = cacher(function (h, s, b) {
    return Snap.hsb2rgb(h, s, b).hex;
});
/*\
 * Snap.hsl
 [ method ]
 **
 * Converts HSL values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (string) hex representation of the color
\*/
Snap.hsl = cacher(function (h, s, l) {
    return Snap.hsl2rgb(h, s, l).hex;
});
/*\
 * Snap.rgb
 [ method ]
 **
 * Converts RGB values to a hex representation of the color
 - r (number) red
 - g (number) green
 - b (number) blue
 = (string) hex representation of the color
\*/
Snap.rgb = cacher(function (r, g, b, o) {
    if (is(o, "finite")) {
        var round = math.round;
        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
    }
    return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
});
var toHex = function (color) {
    var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
        red = "rgb(255, 0, 0)";
    toHex = cacher(function (color) {
        if (color.toLowerCase() == "red") {
            return red;
        }
        i.style.color = red;
        i.style.color = color;
        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        return out == red ? null : out;
    });
    return toHex(color);
},
hsbtoString = function () {
    return "hsb(" + [this.h, this.s, this.b] + ")";
},
hsltoString = function () {
    return "hsl(" + [this.h, this.s, this.l] + ")";
},
rgbtoString = function () {
    return this.opacity == 1 || this.opacity == null ?
            this.hex :
            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
},
prepareRGB = function (r, g, b) {
    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
        b = r.b;
        g = r.g;
        r = r.r;
    }
    if (g == null && is(r, string)) {
        var clr = Snap.getRGB(r);
        r = clr.r;
        g = clr.g;
        b = clr.b;
    }
    if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
    }

    return [r, g, b];
},
packageRGB = function (r, g, b, o) {
    r = math.round(r * 255);
    g = math.round(g * 255);
    b = math.round(b * 255);
    var rgb = {
        r: r,
        g: g,
        b: b,
        opacity: is(o, "finite") ? o : 1,
        hex: Snap.rgb(r, g, b),
        toString: rgbtoString
    };
    is(o, "finite") && (rgb.opacity = o);
    return rgb;
};
/*\
 * Snap.color
 [ method ]
 **
 * Parses the color string and returns an object featuring the color's component values
 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
 = (object) Combined RGB/HSB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) `true` if string can't be parsed,
 o     h (number) hue,
 o     s (number) saturation,
 o     v (number) value (brightness),
 o     l (number) lightness
 o }
\*/
Snap.color = function (clr) {
    var rgb;
    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
        rgb = Snap.hsb2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
        rgb = Snap.hsl2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else {
        if (is(clr, "string")) {
            clr = Snap.getRGB(clr);
        }
        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
            rgb = Snap.rgb2hsl(clr);
            clr.h = rgb.h;
            clr.s = rgb.s;
            clr.l = rgb.l;
            rgb = Snap.rgb2hsb(clr);
            clr.v = rgb.b;
        } else {
            clr = {hex: "none"};
            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            clr.error = 1;
        }
    }
    clr.toString = rgbtoString;
    return clr;
};
/*\
 * Snap.hsb2rgb
 [ method ]
 **
 * Converts HSB values to an RGB object
 - h (number) hue
 - s (number) saturation
 - v (number) value or brightness
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsb2rgb = function (h, s, v, o) {
    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
        v = h.b;
        s = h.s;
        o = h.o;
        h = h.h;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = v * s;
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = v - C;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.hsl2rgb
 [ method ]
 **
 * Converts HSL values to an RGB object
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsl2rgb = function (h, s, l, o) {
    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
        l = h.l;
        s = h.s;
        h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
        h /= 360;
        s /= 100;
        l /= 100;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = 2 * s * (l < .5 ? l : 1 - l);
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = l - C / 2;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.rgb2hsb
 [ method ]
 **
 * Converts RGB values to an HSB object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSB object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     b (number) brightness
 o }
\*/
Snap.rgb2hsb = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, V, C;
    V = mmax(r, g, b);
    C = V - mmin(r, g, b);
    H = C == 0 ? null :
        V == r ? (g - b) / C :
        V == g ? (b - r) / C + 2 :
                 (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    S = C == 0 ? 0 : C / V;
    return {h: H, s: S, b: V, toString: hsbtoString};
};
/*\
 * Snap.rgb2hsl
 [ method ]
 **
 * Converts RGB values to an HSL object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSL object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     l (number) luminosity
 o }
\*/
Snap.rgb2hsl = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, L, M, m, C;
    M = mmax(r, g, b);
    m = mmin(r, g, b);
    C = M - m;
    H = C == 0 ? null :
        M == r ? (g - b) / C :
        M == g ? (b - r) / C + 2 :
                 (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    L = (M + m) / 2;
    S = C == 0 ? 0 :
         L < .5 ? C / (2 * L) :
                  C / (2 - 2 * L);
    return {h: H, s: S, l: L, toString: hsltoString};
};

// Transformations
/*\
 * Snap.parsePathString
 [ method ]
 **
 * Utility method
 **
 * Parses given path string into an array of arrays of path segments
 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
 = (array) array of segments
\*/
Snap.parsePathString = function (pathString) {
    if (!pathString) {
        return null;
    }
    var pth = Snap.path(pathString);
    if (pth.arr) {
        return Snap.path.clone(pth.arr);
    }

    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
        data = [];
    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
        data = Snap.path.clone(pathString);
    }
    if (!data.length) {
        Str(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b].concat(params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "o" && params.length == 1) {
                data.push([b, params[0]]);
            }
            if (name == "r") {
                data.push([b].concat(params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
    }
    data.toString = Snap.path.toString;
    pth.arr = Snap.path.clone(data);
    return data;
};
/*\
 * Snap.parseTransformString
 [ method ]
 **
 * Utility method
 **
 * Parses given transform string into an array of transformations
 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
 = (array) array of transformations
\*/
var parseTransformString = Snap.parseTransformString = function (TString) {
    if (!TString) {
        return null;
    }
    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
        data = [];
    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
        data = Snap.path.clone(TString);
    }
    if (!data.length) {
        Str(TString).replace(tCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            data.push([b].concat(params));
        });
    }
    data.toString = Snap.path.toString;
    return data;
};
function svgTransform2string(tstr) {
    var res = [];
    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
        params = params.split(/\s*,\s*|\s+/);
        if (name == "rotate" && params.length == 1) {
            params.push(0, 0);
        }
        if (name == "scale") {
            if (params.length > 2) {
                params = params.slice(0, 2);
            } else if (params.length == 2) {
                params.push(0, 0);
            }
            if (params.length == 1) {
                params.push(params[0], 0, 0);
            }
        }
        if (name == "skewX") {
            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
        } else if (name == "skewY") {
            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
        } else {
            res.push([name.charAt(0)].concat(params));
        }
        return all;
    });
    return res;
}
Snap._.svgTransform2string = svgTransform2string;
Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
function transform2matrix(tstr, bbox) {
    var tdata = parseTransformString(tstr),
        m = new Snap.Matrix;
    if (tdata) {
        for (var i = 0, ii = tdata.length; i < ii; i++) {
            var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
            if (command == "t" && tlen == 2){
                m.translate(t[1], 0);
            } else if (command == "t" && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else {
                    m.translate(t[1], t[2]);
                }
            } else if (command == "r") {
                if (tlen == 2) {
                    bb = bb || bbox;
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else {
                        m.rotate(t[1], t[2], t[3]);
                    }
                }
            } else if (command == "s") {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || bbox;
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.scale(t[1], t[1], x2, y2);
                    } else {
                        m.scale(t[1], t[1], t[2], t[3]);
                    }
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else {
                        m.scale(t[1], t[2], t[3], t[4]);
                    }
                }
            } else if (command == "m" && tlen == 7) {
                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            }
        }
    }
    return m;
}
Snap._.transform2matrix = transform2matrix;
Snap._unit2px = unit2px;
var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
    function (a, b) {
        var adown = a.nodeType == 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a == bup || !!(bup && bup.nodeType == 1 && (
                adown.contains ?
                    adown.contains(bup) :
                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
            ));
    } :
    function (a, b) {
        if (b) {
            while (b) {
                b = b.parentNode;
                if (b == a) {
                    return true;
                }
            }
        }
        return false;
    };
function getSomeDefs(el) {
    var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) ||
            el.node.parentNode && wrap(el.node.parentNode) ||
            Snap.select("svg") ||
            Snap(0, 0),
        pdefs = p.select("defs"),
        defs  = pdefs == null ? false : pdefs.node;
    if (!defs) {
        defs = make("defs", p.node).node;
    }
    return defs;
}
function getSomeSVG(el) {
    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
}
Snap._.getSomeDefs = getSomeDefs;
Snap._.getSomeSVG = getSomeSVG;
function unit2px(el, name, value) {
    var svg = getSomeSVG(el).node,
        out = {},
        mgr = svg.querySelector(".svg---mgr");
    if (!mgr) {
        mgr = $("rect");
        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
        svg.appendChild(mgr);
    }
    function getW(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {width: val});
        try {
            return mgr.getBBox().width;
        } catch (e) {
            return 0;
        }
    }
    function getH(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {height: val});
        try {
            return mgr.getBBox().height;
        } catch (e) {
            return 0;
        }
    }
    function set(nam, f) {
        if (name == null) {
            out[nam] = f(el.attr(nam) || 0);
        } else if (nam == name) {
            out = f(value == null ? el.attr(nam) || 0 : value);
        }
    }
    switch (el.type) {
        case "rect":
            set("rx", getW);
            set("ry", getH);
        case "image":
            set("width", getW);
            set("height", getH);
        case "text":
            set("x", getW);
            set("y", getH);
        break;
        case "circle":
            set("cx", getW);
            set("cy", getH);
            set("r", getW);
        break;
        case "ellipse":
            set("cx", getW);
            set("cy", getH);
            set("rx", getW);
            set("ry", getH);
        break;
        case "line":
            set("x1", getW);
            set("x2", getW);
            set("y1", getH);
            set("y2", getH);
        break;
        case "marker":
            set("refX", getW);
            set("markerWidth", getW);
            set("refY", getH);
            set("markerHeight", getH);
        break;
        case "radialGradient":
            set("fx", getW);
            set("fy", getH);
        break;
        case "tspan":
            set("dx", getW);
            set("dy", getH);
        break;
        default:
            set(name, getW);
    }
    svg.removeChild(mgr);
    return out;
}
/*\
 * Snap.select
 [ method ]
 **
 * Wraps a DOM element specified by CSS selector as @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.select = function (query) {
    query = Str(query).replace(/([^\\]):/g, "$1\\:");
    return wrap(glob.doc.querySelector(query));
};
/*\
 * Snap.selectAll
 [ method ]
 **
 * Wraps DOM elements specified by CSS selector as set or array of @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.selectAll = function (query) {
    var nodelist = glob.doc.querySelectorAll(query),
        set = (Snap.set || Array)();
    for (var i = 0; i < nodelist.length; i++) {
        set.push(wrap(nodelist[i]));
    }
    return set;
};

function add2group(list) {
    if (!is(list, "array")) {
        list = Array.prototype.slice.call(arguments, 0);
    }
    var i = 0,
        j = 0,
        node = this.node;
    while (this[i]) delete this[i++];
    for (i = 0; i < list.length; i++) {
        if (list[i].type == "set") {
            list[i].forEach(function (el) {
                node.appendChild(el.node);
            });
        } else {
            node.appendChild(list[i].node);
        }
    }
    var children = node.childNodes;
    for (i = 0; i < children.length; i++) {
        this[j++] = wrap(children[i]);
    }
    return this;
}
// Hub garbage collector every 10s
setInterval(function () {
    for (var key in hub) if (hub[has](key)) {
        var el = hub[key],
            node = el.node;
        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
            delete hub[key];
        }
    }
}, 1e4);
function Element(el) {
    if (el.snap in hub) {
        return hub[el.snap];
    }
    var svg;
    try {
        svg = el.ownerSVGElement;
    } catch(e) {}
    /*\
     * Element.node
     [ property (object) ]
     **
     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
     > Usage
     | // draw a circle at coordinate 10,10 with radius of 10
     | var c = paper.circle(10, 10, 10);
     | c.node.onclick = function () {
     |     c.attr("fill", "red");
     | };
    \*/
    this.node = el;
    if (svg) {
        this.paper = new Paper(svg);
    }
    /*\
     * Element.type
     [ property (string) ]
     **
     * SVG tag name of the given element.
    \*/
    this.type = el.tagName || el.nodeName;
    var id = this.id = ID(this);
    this.anims = {};
    this._ = {
        transform: []
    };
    el.snap = id;
    hub[id] = this;
    if (this.type == "g") {
        this.add = add2group;
    }
    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
            this[method] = Paper.prototype[method];
        }
    }
}
   /*\
     * Element.attr
     [ method ]
     **
     * Gets or sets given attributes of the element.
     **
     - params (object) contains key-value pairs of attributes you want to set
     * or
     - param (string) name of the attribute
     = (Element) the current element
     * or
     = (string) value of attribute
     > Usage
     | el.attr({
     |     fill: "#fc0",
     |     stroke: "#000",
     |     strokeWidth: 2, // CamelCase...
     |     "fill-opacity": 0.5, // or dash-separated names
     |     width: "*=2" // prefixed values
     | });
     | console.log(el.attr("fill")); // #fc0
     * Prefixed values in format `"+=10"` supported. All four operations
     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
     * and `-`: `"+=2em"`.
    \*/
    Element.prototype.attr = function (params, value) {
        var el = this,
            node = el.node;
        if (!params) {
            if (node.nodeType != 1) {
                return {
                    text: node.nodeValue
                };
            }
            var attr = node.attributes,
                out = {};
            for (var i = 0, ii = attr.length; i < ii; i++) {
                out[attr[i].nodeName] = attr[i].nodeValue;
            }
            return out;
        }
        if (is(params, "string")) {
            if (arguments.length > 1) {
                var json = {};
                json[params] = value;
                params = json;
            } else {
                return eve("snap.util.getattr." + params, el).firstDefined();
            }
        }
        for (var att in params) {
            if (params[has](att)) {
                eve("snap.util.attr." + att, el, params[att]);
            }
        }
        return el;
    };
/*\
 * Snap.parse
 [ method ]
 **
 * Parses SVG fragment and converts it into a @Fragment
 **
 - svg (string) SVG string
 = (Fragment) the @Fragment
\*/
Snap.parse = function (svg) {
    var f = glob.doc.createDocumentFragment(),
        full = true,
        div = glob.doc.createElement("div");
    svg = Str(svg);
    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
        svg = "<svg>" + svg + "</svg>";
        full = false;
    }
    div.innerHTML = svg;
    svg = div.getElementsByTagName("svg")[0];
    if (svg) {
        if (full) {
            f = svg;
        } else {
            while (svg.firstChild) {
                f.appendChild(svg.firstChild);
            }
        }
    }
    return new Fragment(f);
};
function Fragment(frag) {
    this.node = frag;
}
/*\
 * Snap.fragment
 [ method ]
 **
 * Creates a DOM fragment from a given list of elements or strings
 **
 - varargs (…) SVG string
 = (Fragment) the @Fragment
\*/
Snap.fragment = function () {
    var args = Array.prototype.slice.call(arguments, 0),
        f = glob.doc.createDocumentFragment();
    for (var i = 0, ii = args.length; i < ii; i++) {
        var item = args[i];
        if (item.node && item.node.nodeType) {
            f.appendChild(item.node);
        }
        if (item.nodeType) {
            f.appendChild(item);
        }
        if (typeof item == "string") {
            f.appendChild(Snap.parse(item).node);
        }
    }
    return new Fragment(f);
};

function make(name, parent) {
    var res = $(name);
    parent.appendChild(res);
    var el = wrap(res);
    return el;
}
function Paper(w, h) {
    var res,
        desc,
        defs,
        proto = Paper.prototype;
    if (w && w.tagName && w.tagName.toLowerCase() == "svg") {
        if (w.snap in hub) {
            return hub[w.snap];
        }
        var doc = w.ownerDocument;
        res = new Element(w);
        desc = w.getElementsByTagName("desc")[0];
        defs = w.getElementsByTagName("defs")[0];
        if (!desc) {
            desc = $("desc");
            desc.appendChild(doc.createTextNode("Created with Snap"));
            res.node.appendChild(desc);
        }
        if (!defs) {
            defs = $("defs");
            res.node.appendChild(defs);
        }
        res.defs = defs;
        for (var key in proto) if (proto[has](key)) {
            res[key] = proto[key];
        }
        res.paper = res.root = res;
    } else {
        res = make("svg", glob.doc.body);
        $(res.node, {
            height: h,
            version: 1.1,
            width: w,
            xmlns: xmlns
        });
    }
    return res;
}
function wrap(dom) {
    if (!dom) {
        return dom;
    }
    if (dom instanceof Element || dom instanceof Fragment) {
        return dom;
    }
    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
        return new Paper(dom);
    }
    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
    }
    return new Element(dom);
}

Snap._.make = make;
Snap._.wrap = wrap;
/*\
 * Paper.el
 [ method ]
 **
 * Creates an element on paper with a given name and no attributes
 **
 - name (string) tag name
 - attr (object) attributes
 = (Element) the current element
 > Usage
 | var c = paper.circle(10, 10, 10); // is the same as...
 | var c = paper.el("circle").attr({
 |     cx: 10,
 |     cy: 10,
 |     r: 10
 | });
 | // and the same as
 | var c = paper.el("circle", {
 |     cx: 10,
 |     cy: 10,
 |     r: 10
 | });
\*/
Paper.prototype.el = function (name, attr) {
    var el = make(name, this.node);
    attr && el.attr(attr);
    return el;
};
/*\
 * Element.children
 [ method ]
 **
 * Returns array of all the children of the element.
 = (array) array of Elements
\*/
Element.prototype.children = function () {
    var out = [],
        ch = this.node.childNodes;
    for (var i = 0, ii = ch.length; i < ii; i++) {
        out[i] = Snap(ch[i]);
    }
    return out;
};
function jsonFiller(root, o) {
    for (var i = 0, ii = root.length; i < ii; i++) {
        var item = {
                type: root[i].type,
                attr: root[i].attr()
            },
            children = root[i].children();
        o.push(item);
        if (children.length) {
            jsonFiller(children, item.childNodes = []);
        }
    }
}
/*\
 * Element.toJSON
 [ method ]
 **
 * Returns object representation of the given element and all its children.
 = (object) in format
 o {
 o     type (string) this.type,
 o     attr (object) attributes map,
 o     childNodes (array) optional array of children in the same format
 o }
\*/
Element.prototype.toJSON = function () {
    var out = [];
    jsonFiller([this], out);
    return out[0];
};
// default
eve.on("snap.util.getattr", function () {
    var att = eve.nt();
    att = att.substring(att.lastIndexOf(".") + 1);
    var css = att.replace(/[A-Z]/g, function (letter) {
        return "-" + letter.toLowerCase();
    });
    if (cssAttr[has](css)) {
        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
    } else {
        return $(this.node, att);
    }
});
var cssAttr = {
    "alignment-baseline": 0,
    "baseline-shift": 0,
    "clip": 0,
    "clip-path": 0,
    "clip-rule": 0,
    "color": 0,
    "color-interpolation": 0,
    "color-interpolation-filters": 0,
    "color-profile": 0,
    "color-rendering": 0,
    "cursor": 0,
    "direction": 0,
    "display": 0,
    "dominant-baseline": 0,
    "enable-background": 0,
    "fill": 0,
    "fill-opacity": 0,
    "fill-rule": 0,
    "filter": 0,
    "flood-color": 0,
    "flood-opacity": 0,
    "font": 0,
    "font-family": 0,
    "font-size": 0,
    "font-size-adjust": 0,
    "font-stretch": 0,
    "font-style": 0,
    "font-variant": 0,
    "font-weight": 0,
    "glyph-orientation-horizontal": 0,
    "glyph-orientation-vertical": 0,
    "image-rendering": 0,
    "kerning": 0,
    "letter-spacing": 0,
    "lighting-color": 0,
    "marker": 0,
    "marker-end": 0,
    "marker-mid": 0,
    "marker-start": 0,
    "mask": 0,
    "opacity": 0,
    "overflow": 0,
    "pointer-events": 0,
    "shape-rendering": 0,
    "stop-color": 0,
    "stop-opacity": 0,
    "stroke": 0,
    "stroke-dasharray": 0,
    "stroke-dashoffset": 0,
    "stroke-linecap": 0,
    "stroke-linejoin": 0,
    "stroke-miterlimit": 0,
    "stroke-opacity": 0,
    "stroke-width": 0,
    "text-anchor": 0,
    "text-decoration": 0,
    "text-rendering": 0,
    "unicode-bidi": 0,
    "visibility": 0,
    "word-spacing": 0,
    "writing-mode": 0
};

eve.on("snap.util.attr", function (value) {
    var att = eve.nt(),
        attr = {};
    att = att.substring(att.lastIndexOf(".") + 1);
    attr[att] = value;
    var style = att.replace(/-(\w)/gi, function (all, letter) {
            return letter.toUpperCase();
        }),
        css = att.replace(/[A-Z]/g, function (letter) {
            return "-" + letter.toLowerCase();
        });
    if (cssAttr[has](css)) {
        this.node.style[style] = value == null ? E : value;
    } else {
        $(this.node, attr);
    }
});
(function (proto) {}(Paper.prototype));

// simple ajax
/*\
 * Snap.ajax
 [ method ]
 **
 * Simple implementation of Ajax
 **
 - url (string) URL
 - postData (object|string) data for post request
 - callback (function) callback
 - scope (object) #optional scope of callback
 * or
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
 = (XMLHttpRequest) the XMLHttpRequest object, just in case
\*/
Snap.ajax = function (url, postData, callback, scope){
    var req = new XMLHttpRequest,
        id = ID();
    if (req) {
        if (is(postData, "function")) {
            scope = callback;
            callback = postData;
            postData = null;
        } else if (is(postData, "object")) {
            var pd = [];
            for (var key in postData) if (postData.hasOwnProperty(key)) {
                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
            }
            postData = pd.join("&");
        }
        req.open(postData ? "POST" : "GET", url, true);
        if (postData) {
            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
        if (callback) {
            eve.once("snap.ajax." + id + ".0", callback);
            eve.once("snap.ajax." + id + ".200", callback);
            eve.once("snap.ajax." + id + ".304", callback);
        }
        req.onreadystatechange = function() {
            if (req.readyState != 4) return;
            eve("snap.ajax." + id + "." + req.status, scope, req);
        };
        if (req.readyState == 4) {
            return req;
        }
        req.send(postData);
        return req;
    }
};
/*\
 * Snap.load
 [ method ]
 **
 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
 **
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
\*/
Snap.load = function (url, callback, scope) {
    Snap.ajax(url, function (req) {
        var f = Snap.parse(req.responseText);
        scope ? callback.call(scope, f) : callback(f);
    });
};
var getOffset = function (elem) {
    var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
    return {
        y: top,
        x: left
    };
};
/*\
 * Snap.getElementByPoint
 [ method ]
 **
 * Returns you topmost element under given point.
 **
 = (object) Snap element object
 - x (number) x coordinate from the top left corner of the window
 - y (number) y coordinate from the top left corner of the window
 > Usage
 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
\*/
Snap.getElementByPoint = function (x, y) {
    var paper = this,
        svg = paper.canvas,
        target = glob.doc.elementFromPoint(x, y);
    if (glob.win.opera && target.tagName == "svg") {
        var so = getOffset(target),
            sr = target.createSVGRect();
        sr.x = x - so.x;
        sr.y = y - so.y;
        sr.width = sr.height = 1;
        var hits = target.getIntersectionList(sr, null);
        if (hits.length) {
            target = hits[hits.length - 1];
        }
    }
    if (!target) {
        return null;
    }
    return wrap(target);
};
/*\
 * Snap.plugin
 [ method ]
 **
 * Let you write plugins. You pass in a function with five arguments, like this:
 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
 |     Snap.newmethod = function () {};
 |     Element.prototype.newmethod = function () {};
 |     Paper.prototype.newmethod = function () {};
 | });
 * Inside the function you have access to all main objects (and their
 * prototypes). This allow you to extend anything you want.
 **
 - f (function) your plugin body
\*/
Snap.plugin = function (f) {
    f(Snap, Element, Paper, glob, Fragment);
};
glob.win.Snap = Snap;
return Snap;
}(window || this));

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        unit2px = Snap._unit2px,
        $ = Snap._.$,
        make = Snap._.make,
        getSomeDefs = Snap._.getSomeDefs,
        has = "hasOwnProperty",
        wrap = Snap._.wrap;
    /*\
     * Element.getBBox
     [ method ]
     **
     * Returns the bounding box descriptor for the given element
     **
     = (object) bounding box descriptor:
     o {
     o     cx: (number) x of the center,
     o     cy: (number) x of the center,
     o     h: (number) height,
     o     height: (number) height,
     o     path: (string) path command for the box,
     o     r0: (number) radius of a circle that fully encloses the box,
     o     r1: (number) radius of the smallest circle that can be enclosed,
     o     r2: (number) radius of the largest circle that can be enclosed,
     o     vb: (string) box as a viewbox command,
     o     w: (number) width,
     o     width: (number) width,
     o     x2: (number) x of the right side,
     o     x: (number) x of the left side,
     o     y2: (number) y of the bottom edge,
     o     y: (number) y of the top edge
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.type == "tspan") {
            return Snap._.box(this.node.getClientRects().item(0));
        }
        if (!Snap.Matrix || !Snap.path) {
            return this.node.getBBox();
        }
        var el = this,
            m = new Snap.Matrix;
        if (el.removed) {
            return Snap._.box();
        }
        while (el.type == "use") {
            if (!isWithoutTransform) {
                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
            }
            if (el.original) {
                el = el.original;
            } else {
                var href = el.attr("xlink:href");
                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
            }
        }
        var _ = el._,
            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
        try {
            if (isWithoutTransform) {
                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                return Snap._.box(_.bboxwt);
            } else {
                el.realPath = pathfinder(el);
                el.matrix = el.transform().localMatrix;
                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                return Snap._.box(_.bbox);
            }
        } catch (e) {
            // Firefox doesn’t give you bbox of hidden element
            return Snap._.box();
        }
    };
    var propString = function () {
        return this.string;
    };
    function extractTransform(el, tstr) {
        if (tstr == null) {
            var doReturn = true;
            if (el.type == "linearGradient" || el.type == "radialGradient") {
                tstr = el.node.getAttribute("gradientTransform");
            } else if (el.type == "pattern") {
                tstr = el.node.getAttribute("patternTransform");
            } else {
                tstr = el.node.getAttribute("transform");
            }
            if (!tstr) {
                return new Snap.Matrix;
            }
            tstr = Snap._.svgTransform2string(tstr);
        } else {
            if (!Snap._.rgTransform.test(tstr)) {
                tstr = Snap._.svgTransform2string(tstr);
            } else {
                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
            }
            if (is(tstr, "array")) {
                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
            }
            el._.transform = tstr;
        }
        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
        if (doReturn) {
            return m;
        } else {
            el.matrix = m;
        }
    }
    /*\
     * Element.transform
     [ method ]
     **
     * Gets or sets transformation of the element
     **
     - tstr (string) transform string in Snap or SVG format
     = (Element) the current element
     * or
     = (object) transformation descriptor:
     o {
     o     string (string) transform string,
     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
     o     localMatrix (Matrix) matrix of transformations applied only to the element,
     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
     o     global (string) global transformation as string,
     o     local (string) local transformation as string,
     o     toString (function) returns `string` property
     o }
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            var papa = this,
                global = new Snap.Matrix(this.node.getCTM()),
                local = extractTransform(this),
                ms = [local],
                m = new Snap.Matrix,
                i,
                localString = local.toTransformString(),
                string = Str(local) == Str(this.matrix) ?
                            Str(_.transform) : localString;
            while (papa.type != "svg" && (papa = papa.parent())) {
                ms.push(extractTransform(papa));
            }
            i = ms.length;
            while (i--) {
                m.add(ms[i]);
            }
            return {
                string: string,
                globalMatrix: global,
                totalMatrix: m,
                localMatrix: local,
                diffMatrix: global.clone().add(local.invert()),
                global: global.toTransformString(),
                total: m.toTransformString(),
                local: localString,
                toString: propString
            };
        }
        if (tstr instanceof Snap.Matrix) {
            this.matrix = tstr;
            this._.transform = tstr.toTransformString();
        } else {
            extractTransform(this, tstr);
        }

        if (this.node) {
            if (this.type == "linearGradient" || this.type == "radialGradient") {
                $(this.node, {gradientTransform: this.matrix});
            } else if (this.type == "pattern") {
                $(this.node, {patternTransform: this.matrix});
            } else {
                $(this.node, {transform: this.matrix});
            }
        }

        return this;
    };
    /*\
     * Element.parent
     [ method ]
     **
     * Returns the element's parent
     **
     = (Element) the parent element
    \*/
    elproto.parent = function () {
        return wrap(this.node.parentNode);
    };
    /*\
     * Element.append
     [ method ]
     **
     * Appends the given element to current one
     **
     - el (Element|Set) element to append
     = (Element) the parent element
    \*/
    /*\
     * Element.add
     [ method ]
     **
     * See @Element.append
    \*/
    elproto.append = elproto.add = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    it.add(el);
                });
                return this;
            }
            el = wrap(el);
            this.node.appendChild(el.node);
            el.paper = this.paper;
        }
        return this;
    };
    /*\
     * Element.appendTo
     [ method ]
     **
     * Appends the current element to the given one
     **
     - el (Element) parent element to append to
     = (Element) the child element
    \*/
    elproto.appendTo = function (el) {
        if (el) {
            el = wrap(el);
            el.append(this);
        }
        return this;
    };
    /*\
     * Element.prepend
     [ method ]
     **
     * Prepends the given element to the current one
     **
     - el (Element) element to prepend
     = (Element) the parent element
    \*/
    elproto.prepend = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this,
                    first;
                el.forEach(function (el) {
                    if (first) {
                        first.after(el);
                    } else {
                        it.prepend(el);
                    }
                    first = el;
                });
                return this;
            }
            el = wrap(el);
            var parent = el.parent();
            this.node.insertBefore(el.node, this.node.firstChild);
            this.add && this.add();
            el.paper = this.paper;
            this.parent() && this.parent().add();
            parent && parent.add();
        }
        return this;
    };
    /*\
     * Element.prependTo
     [ method ]
     **
     * Prepends the current element to the given one
     **
     - el (Element) parent element to prepend to
     = (Element) the child element
    \*/
    elproto.prependTo = function (el) {
        el = wrap(el);
        el.prepend(this);
        return this;
    };
    /*\
     * Element.before
     [ method ]
     **
     * Inserts given element before the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.before = function (el) {
        if (el.type == "set") {
            var it = this;
            el.forEach(function (el) {
                var parent = el.parent();
                it.node.parentNode.insertBefore(el.node, it.node);
                parent && parent.add();
            });
            this.parent().add();
            return this;
        }
        el = wrap(el);
        var parent = el.parent();
        this.node.parentNode.insertBefore(el.node, this.node);
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.after
     [ method ]
     **
     * Inserts given element after the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.after = function (el) {
        el = wrap(el);
        var parent = el.parent();
        if (this.node.nextSibling) {
            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
        } else {
            this.node.parentNode.appendChild(el.node);
        }
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertBefore = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertAfter = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the DOM
     = (Element) the detached element
    \*/
    elproto.remove = function () {
        var parent = this.parent();
        this.node.parentNode && this.node.parentNode.removeChild(this.node);
        delete this.paper;
        this.removed = true;
        parent && parent.add();
        return this;
    };
    /*\
     * Element.select
     [ method ]
     **
     * Gathers the nested @Element matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Element) result of query selection
    \*/
    elproto.select = function (query) {
        return wrap(this.node.querySelector(query));
    };
    /*\
     * Element.selectAll
     [ method ]
     **
     * Gathers nested @Element objects matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Set|array) result of query selection
    \*/
    elproto.selectAll = function (query) {
        var nodelist = this.node.querySelectorAll(query),
            set = (Snap.set || Array)();
        for (var i = 0; i < nodelist.length; i++) {
            set.push(wrap(nodelist[i]));
        }
        return set;
    };
    /*\
     * Element.asPX
     [ method ]
     **
     * Returns given attribute of the element as a `px` value (not %, em, etc.)
     **
     - attr (string) attribute name
     - value (string) #optional attribute value
     = (Element) result of query selection
    \*/
    elproto.asPX = function (attr, value) {
        if (value == null) {
            value = this.attr(attr);
        }
        return +unit2px(this, attr, value);
    };
    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
    /*\
     * Element.use
     [ method ]
     **
     * Creates a `<use>` element linked to the current element
     **
     = (Element) the `<use>` element
    \*/
    elproto.use = function () {
        var use,
            id = this.node.id;
        if (!id) {
            id = this.id;
            $(this.node, {
                id: id
            });
        }
        if (this.type == "linearGradient" || this.type == "radialGradient" ||
            this.type == "pattern") {
            use = make(this.type, this.node.parentNode);
        } else {
            use = make("use", this.node.parentNode);
        }
        $(use.node, {
            "xlink:href": "#" + id
        });
        use.original = this;
        return use;
    };
    function fixids(el) {
        var els = el.selectAll("*"),
            it,
            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
            ids = [],
            uses = {};
        function urltest(it, name) {
            var val = $(it.node, name);
            val = val && val.match(url);
            val = val && val[2];
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    var attr = {};
                    attr[name] = Snap.url(id);
                    $(it.node, attr);
                });
            }
        }
        function linktest(it) {
            var val = $(it.node, "xlink:href");
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    it.attr("xlink:href", "#" + id);
                });
            }
        }
        for (var i = 0, ii = els.length; i < ii; i++) {
            it = els[i];
            urltest(it, "fill");
            urltest(it, "stroke");
            urltest(it, "filter");
            urltest(it, "mask");
            urltest(it, "clip-path");
            linktest(it);
            var oldid = $(it.node, "id");
            if (oldid) {
                $(it.node, {id: it.id});
                ids.push({
                    old: oldid,
                    id: it.id
                });
            }
        }
        for (i = 0, ii = ids.length; i < ii; i++) {
            var fs = uses[ids[i].old];
            if (fs) {
                for (var j = 0, jj = fs.length; j < jj; j++) {
                    fs[j](ids[i].id);
                }
            }
        }
    }
    /*\
     * Element.clone
     [ method ]
     **
     * Creates a clone of the element and inserts it after the element
     **
     = (Element) the clone
    \*/
    elproto.clone = function () {
        var clone = wrap(this.node.cloneNode(true));
        if ($(clone.node, "id")) {
            $(clone.node, {id: clone.id});
        }
        fixids(clone);
        clone.insertAfter(this);
        return clone;
    };
    /*\
     * Element.toDefs
     [ method ]
     **
     * Moves element to the shared `<defs>` area
     **
     = (Element) the element
    \*/
    elproto.toDefs = function () {
        var defs = getSomeDefs(this);
        defs.appendChild(this.node);
        return this;
    };
    /*\
     * Element.toPattern
     [ method ]
     **
     * Creates a `<pattern>` element from the current element
     **
     * To create a pattern you have to specify the pattern rect:
     - x (string|number)
     - y (string|number)
     - width (string|number)
     - height (string|number)
     = (Element) the `<pattern>` element
     * You can use pattern later on as an argument for `fill` attribute:
     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
     |         fill: "none",
     |         stroke: "#bada55",
     |         strokeWidth: 5
     |     }).pattern(0, 0, 10, 10),
     |     c = paper.circle(200, 200, 100);
     | c.attr({
     |     fill: p
     | });
    \*/
    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
        var p = make("pattern", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        $(p.node, {
            x: x,
            y: y,
            width: width,
            height: height,
            patternUnits: "userSpaceOnUse",
            id: p.id,
            viewBox: [x, y, width, height].join(" ")
        });
        p.node.appendChild(this.node);
        return p;
    };
// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
    /*\
     * Element.marker
     [ method ]
     **
     * Creates a `<marker>` element from the current element
     **
     * To create a marker you have to specify the bounding rect and reference point:
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - refX (number)
     - refY (number)
     = (Element) the `<marker>` element
     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
    \*/
    // TODO add usage for markers
    elproto.marker = function (x, y, width, height, refX, refY) {
        var p = make("marker", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            refX = x.refX || x.cx;
            refY = x.refY || x.cy;
            x = x.x;
        }
        $(p.node, {
            viewBox: [x, y, width, height].join(" "),
            markerWidth: width,
            markerHeight: height,
            orient: "auto",
            refX: refX || 0,
            refY: refY || 0,
            id: p.id
        });
        p.node.appendChild(this.node);
        return p;
    };
    var eldata = {};
    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value associated with given key. (Don’t confuse
     * with `data-` attributes)
     *
     * See also @Element.removeData
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0){
            eve("snap.data.get." + this.id, this, data, null);
            return data;
        }
        if (arguments.length == 1) {
            if (Snap.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("snap.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("snap.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.outerSVG
     [ method ]
     **
     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
     *
     * See also @Element.innerSVG
     = (string) SVG code for the element
    \*/
    /*\
     * Element.toString
     [ method ]
     **
     * See @Element.outerSVG
    \*/
    elproto.outerSVG = elproto.toString = toString(1);
    /*\
     * Element.innerSVG
     [ method ]
     **
     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
     = (string) SVG code for the element
    \*/
    elproto.innerSVG = toString();
    function toString(type) {
        return function () {
            var res = type ? "<" + this.type : "",
                attr = this.node.attributes,
                chld = this.node.childNodes;
            if (type) {
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    res += " " + attr[i].name + '="' +
                            attr[i].value.replace(/"/g, '\\"') + '"';
                }
            }
            if (chld.length) {
                type && (res += ">");
                for (i = 0, ii = chld.length; i < ii; i++) {
                    if (chld[i].nodeType == 3) {
                        res += chld[i].nodeValue;
                    } else if (chld[i].nodeType == 1) {
                        res += wrap(chld[i]).toString();
                    }
                }
                type && (res += "</" + this.type + ">");
            } else {
                type && (res += "/>");
            }
            return res;
        };
    }
    elproto.toDataURL = function () {
        if (window && window.btoa) {
            var bb = this.getBBox(),
                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                x: +bb.x.toFixed(3),
                y: +bb.y.toFixed(3),
                width: +bb.width.toFixed(3),
                height: +bb.height.toFixed(3),
                contents: this.outerSVG()
            });
            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
        }
    };
    /*\
     * Fragment.select
     [ method ]
     **
     * See @Element.select
    \*/
    Fragment.prototype.select = elproto.select;
    /*\
     * Fragment.selectAll
     [ method ]
     **
     * See @Element.selectAll
    \*/
    Fragment.prototype.selectAll = elproto.selectAll;
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var objectToString = Object.prototype.toString,
        Str = String,
        math = Math,
        E = "";
    function Matrix(a, b, c, d, e, f) {
        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.d = a.d;
            this.e = a.e;
            this.f = a.f;
            return;
        }
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds the given matrix to existing one
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.add(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + b * this.c,
                bNew = a * this.b + b * this.d;
            this.e += e * this.a + f * this.c;
            this.f += e * this.b + f * this.d;
            this.c = c * this.a + d * this.c;
            this.d = c * this.b + d * this.d;

            this.a = aNew;
            this.b = bNew;
            return this;
        };
        /*\
         * Matrix.multLeft
         [ method ]
         **
         * Multiplies a passed affine transform to the left: M * this.
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        Matrix.prototype.multLeft = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.multLeft(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + c * this.b,
                cNew = a * this.c + c * this.d,
                eNew = a * this.e + c * this.f + e;
            this.b = b * this.a + d * this.b;
            this.d = b * this.c + d * this.d;
            this.f = b * this.e + d * this.f + f;

            this.a = aNew;
            this.c = cNew;
            this.e = eNew;
            return this;
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns an inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns a copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         - x (number) horizontal offset distance
         - y (number) vertical offset distance
        \*/
        matrixproto.translate = function (x, y) {
            this.e += x * this.a + y * this.c;
            this.f += x * this.b + y * this.d;
            return this;
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         - x (number) amount to be scaled, with `1` resulting in no change
         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
         - cx (number) #optional horizontal origin point from which to scale
         - cy (number) #optional vertical origin point from which to scale
         * Default cx, cy is the middle point of the element.
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.translate(cx, cy);
            this.a *= x;
            this.b *= x;
            this.c *= y;
            this.d *= y;
            (cx || cy) && this.translate(-cx, -cy);
            return this;
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         - a (number) angle of rotation, in degrees
         - x (number) horizontal origin point from which to rotate
         - y (number) vertical origin point from which to rotate
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = Snap.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            return this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.skewX
         [ method ]
         **
         * Skews the matrix along the x-axis
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skewX = function (x) {
            return this.skew(x, 0);
        };
        /*\
         * Matrix.skewY
         [ method ]
         **
         * Skews the matrix along the y-axis
         - y (number) Angle to skew along the y-axis (in degrees).
        \*/
        matrixproto.skewY = function (y) {
            return this.skew(0, y);
        };
        /*\
         * Matrix.skew
         [ method ]
         **
         * Skews the matrix
         - y (number) Angle to skew along the y-axis (in degrees).
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skew = function (x, y) {
            x = x || 0;
            y = y || 0;
            x = Snap.rad(x);
            y = Snap.rad(y);
            var c = math.tan(x).toFixed(9);
            var b = math.tan(y).toFixed(9);
            return this.add(1, b, c, 1, 0, 0);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.determinant
         [ method ]
         **
         * Finds determinant of the given matrix.
         = (number) determinant
        \*/
        matrixproto.determinant = function () {
            return this.a * this.d - this.b * this.c;
        };
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.b], [this.c, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            if (this.determinant() < 0) {
                out.scalex = -out.scalex;
            }

            // rotation
            var sin = row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = Snap.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = Snap.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Returns transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this.split();
            if (!+s.shear.toFixed(9)) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +
                        (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E) +
                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);
    /*\
     * Snap.Matrix
     [ method ]
     **
     * Matrix constructor, extend on your own risk.
     * To create matrices use @Snap.matrix.
    \*/
    Snap.Matrix = Matrix;
    /*\
     * Snap.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns a matrix based on the given parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     * or
     - svgMatrix (SVGMatrix)
     = (object) @Matrix
    \*/
    Snap.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var has = "hasOwnProperty",
        make = Snap._.make,
        wrap = Snap._.wrap,
        is = Snap.is,
        getSomeDefs = Snap._.getSomeDefs,
        reURLValue = /^url\((['"]?)([^)]+)\1\)$/,
        $ = Snap._.$,
        URL = Snap.url,
        Str = String,
        separator = Snap._.separator,
        E = "";
    /*\
     * Snap.deurl
     [ method ]
     **
     * Unwraps path from `"url(<path>)"`.
     - value (string) url path
     = (string) unwrapped path
    \*/
    Snap.deurl = function (value) {
        var res = String(value).match(reURLValue);
        return res ? res[2] : value;
    }
    // Attributes event handlers
    eve.on("snap.util.attr.mask", function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value.type == "mask") {
                var mask = value;
            } else {
                mask = make("mask", getSomeDefs(this));
                mask.node.appendChild(value.node);
            }
            !mask.node.id && $(mask.node, {
                id: mask.id
            });
            $(this.node, {
                mask: URL(mask.id)
            });
        }
    });
    (function (clipIt) {
        eve.on("snap.util.attr.clip", clipIt);
        eve.on("snap.util.attr.clip-path", clipIt);
        eve.on("snap.util.attr.clipPath", clipIt);
    }(function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            var clip,
                node = value.node;
            while (node) {
                if (node.nodeName === "clipPath") {
                    clip = new Element(node);
                    break;
                }
                if (node.nodeName === "svg") {
                    clip = undefined;
                    break;
                }
                node = node.parentNode;
            }
            if (!clip) {
                clip = make("clipPath", getSomeDefs(this));
                clip.node.appendChild(value.node);
                !clip.node.id && $(clip.node, {
                    id: clip.id
                });
            }
            $(this.node, {
                "clip-path": URL(clip.node.id || clip.id)
            });
        }
    }));
    function fillStroke(name) {
        return function (value) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1 &&
                (value.node.firstChild.tagName == "radialGradient" ||
                value.node.firstChild.tagName == "linearGradient" ||
                value.node.firstChild.tagName == "pattern")) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value instanceof Element) {
                if (value.type == "radialGradient" || value.type == "linearGradient"
                   || value.type == "pattern") {
                    if (!value.node.id) {
                        $(value.node, {
                            id: value.id
                        });
                    }
                    var fill = URL(value.node.id);
                } else {
                    fill = value.attr(name);
                }
            } else {
                fill = Snap.color(value);
                if (fill.error) {
                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                    if (grad) {
                        if (!grad.node.id) {
                            $(grad.node, {
                                id: grad.id
                            });
                        }
                        fill = URL(grad.node.id);
                    } else {
                        fill = value;
                    }
                } else {
                    fill = Str(fill);
                }
            }
            var attrs = {};
            attrs[name] = fill;
            $(this.node, attrs);
            this.node.style[name] = E;
        };
    }
    eve.on("snap.util.attr.fill", fillStroke("fill"));
    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
    eve.on("snap.util.grad.parse", function parseGrad(string) {
        string = Str(string);
        var tokens = string.match(gradrg);
        if (!tokens) {
            return null;
        }
        var type = tokens[1],
            params = tokens[2],
            stops = tokens[3];
        params = params.split(/\s*,\s*/).map(function (el) {
            return +el == el ? +el : el;
        });
        if (params.length == 1 && params[0] == 0) {
            params = [];
        }
        stops = stops.split("-");
        stops = stops.map(function (el) {
            el = el.split(":");
            var out = {
                color: el[0]
            };
            if (el[1]) {
                out.offset = parseFloat(el[1]);
            }
            return out;
        });
        var len = stops.length,
            start = 0,
            j = 0;
        function seed(i, end) {
            var step = (end - start) / (i - j);
            for (var k = j; k < i; k++) {
                stops[k].offset = +(+start + step * (k - j)).toFixed(2);
            }
            j = i;
            start = end;
        }
        len--;
        for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
            seed(i, stops[i].offset);
        }
        stops[len].offset = stops[len].offset || 100;
        seed(len, stops[len].offset);
        return {
            type: type,
            params: params,
            stops: stops
        };
    });

    eve.on("snap.util.attr.d", function (value) {
        eve.stop();
        if (is(value, "array") && is(value[0], "array")) {
            value = Snap.path.toString.call(value);
        }
        value = Str(value);
        if (value.match(/[ruo]/i)) {
            value = Snap.path.toAbsolute(value);
        }
        $(this.node, {d: value});
    })(-1);
    eve.on("snap.util.attr.#text", function (value) {
        eve.stop();
        value = Str(value);
        var txt = glob.doc.createTextNode(value);
        while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
        }
        this.node.appendChild(txt);
    })(-1);
    eve.on("snap.util.attr.path", function (value) {
        eve.stop();
        this.attr({d: value});
    })(-1);
    eve.on("snap.util.attr.class", function (value) {
        eve.stop();
        this.node.className.baseVal = value;
    })(-1);
    eve.on("snap.util.attr.viewBox", function (value) {
        var vb;
        if (is(value, "object") && "x" in value) {
            vb = [value.x, value.y, value.width, value.height].join(" ");
        } else if (is(value, "array")) {
            vb = value.join(" ");
        } else {
            vb = value;
        }
        $(this.node, {
            viewBox: vb
        });
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.transform", function (value) {
        this.transform(value);
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.r", function (value) {
        if (this.type == "rect") {
            eve.stop();
            $(this.node, {
                rx: value,
                ry: value
            });
        }
    })(-1);
    eve.on("snap.util.attr.textpath", function (value) {
        eve.stop();
        if (this.type == "text") {
            var id, tp, node;
            if (!value && this.textPath) {
                tp = this.textPath;
                while (tp.node.firstChild) {
                    this.node.appendChild(tp.node.firstChild);
                }
                tp.remove();
                delete this.textPath;
                return;
            }
            if (is(value, "string")) {
                var defs = getSomeDefs(this),
                    path = wrap(defs.parentNode).path(value);
                defs.appendChild(path.node);
                id = path.id;
                path.attr({id: id});
            } else {
                value = wrap(value);
                if (value instanceof Element) {
                    id = value.attr("id");
                    if (!id) {
                        id = value.id;
                        value.attr({id: id});
                    }
                }
            }
            if (id) {
                tp = this.textPath;
                node = this.node;
                if (tp) {
                    tp.attr({"xlink:href": "#" + id});
                } else {
                    tp = $("textPath", {
                        "xlink:href": "#" + id
                    });
                    while (node.firstChild) {
                        tp.appendChild(node.firstChild);
                    }
                    node.appendChild(tp);
                    this.textPath = wrap(tp);
                }
            }
        }
    })(-1);
    eve.on("snap.util.attr.text", function (value) {
        if (this.type == "text") {
            var i = 0,
                node = this.node,
                tuner = function (chunk) {
                    var out = $("tspan");
                    if (is(chunk, "array")) {
                        for (var i = 0; i < chunk.length; i++) {
                            out.appendChild(tuner(chunk[i]));
                        }
                    } else {
                        out.appendChild(glob.doc.createTextNode(chunk));
                    }
                    out.normalize && out.normalize();
                    return out;
                };
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var tuned = tuner(value);
            while (tuned.firstChild) {
                node.appendChild(tuned.firstChild);
            }
        }
        eve.stop();
    })(-1);
    function setFontSize(value) {
        eve.stop();
        if (value == +value) {
            value += "px";
        }
        this.node.style.fontSize = value;
    }
    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
    eve.on("snap.util.attr.font-size", setFontSize)(-1);


    eve.on("snap.util.getattr.transform", function () {
        eve.stop();
        return this.transform();
    })(-1);
    eve.on("snap.util.getattr.textpath", function () {
        eve.stop();
        return this.textPath;
    })(-1);
    // Markers
    (function () {
        function getter(end) {
            return function () {
                eve.stop();
                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                if (style == "none") {
                    return style;
                } else {
                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                }
            };
        }
        function setter(end) {
            return function (value) {
                eve.stop();
                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                if (value == "" || !value) {
                    this.node.style[name] = "none";
                    return;
                }
                if (value.type == "marker") {
                    var id = value.node.id;
                    if (!id) {
                        $(value.node, {id: value.id});
                    }
                    this.node.style[name] = URL(id);
                    return;
                }
            };
        }
        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
    }());
    eve.on("snap.util.getattr.r", function () {
        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
            eve.stop();
            return $(this.node, "rx");
        }
    })(-1);
    function textExtract(node) {
        var out = [];
        var children = node.childNodes;
        for (var i = 0, ii = children.length; i < ii; i++) {
            var chi = children[i];
            if (chi.nodeType == 3) {
                out.push(chi.nodeValue);
            }
            if (chi.tagName == "tspan") {
                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                    out.push(chi.firstChild.nodeValue);
                } else {
                    out.push(textExtract(chi));
                }
            }
        }
        return out;
    }
    eve.on("snap.util.getattr.text", function () {
        if (this.type == "text" || this.type == "tspan") {
            eve.stop();
            var out = textExtract(this.node);
            return out.length == 1 ? out[0] : out;
        }
    })(-1);
    eve.on("snap.util.getattr.#text", function () {
        return this.node.textContent;
    })(-1);
    eve.on("snap.util.getattr.fill", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.fill", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.stroke", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.stroke", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.viewBox", function () {
        eve.stop();
        var vb = $(this.node, "viewBox");
        if (vb) {
            vb = vb.split(separator);
            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.points", function () {
        var p = $(this.node, "points");
        eve.stop();
        if (p) {
            return p.split(separator);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.path", function () {
        var p = $(this.node, "d");
        eve.stop();
        return p;
    })(-1);
    eve.on("snap.util.getattr.class", function () {
        return this.node.className.baseVal;
    })(-1);
    function getFontSize() {
        eve.stop();
        return this.node.style.fontSize;
    }
    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var rgNotSpace = /\S+/g,
        rgBadSpace = /[\t\r\n\f]/g,
        rgTrim = /(^\s+|\s+$)/g,
        Str = String,
        elproto = Element.prototype;
    /*\
     * Element.addClass
     [ method ]
     **
     * Adds given class name or list of class names to the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.addClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;

        if (classes.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (!~pos) {
                    curClasses.push(clazz);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.removeClass
     [ method ]
     **
     * Removes given class name or list of class names from the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.removeClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        if (curClasses.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (~pos) {
                    curClasses.splice(pos, 1);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.hasClass
     [ method ]
     **
     * Checks if the element has a given class name in the list of class names applied to it.
     - value (string) class name
     **
     = (boolean) `true` if the element has given class
    \*/
    elproto.hasClass = function (value) {
        var elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [];
        return !!~curClasses.indexOf(value);
    };
    /*\
     * Element.toggleClass
     [ method ]
     **
     * Add or remove one or more classes from the element, depending on either
     * the class’s presence or the value of the `flag` argument.
     - value (string) class name or space separated list of class names
     - flag (boolean) value to determine whether the class should be added or removed
     **
     = (Element) original element.
    \*/
    elproto.toggleClass = function (value, flag) {
        if (flag != null) {
            if (flag) {
                return this.addClass(value);
            } else {
                return this.removeClass(value);
            }
        }
        var classes = (value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        j = 0;
        while (clazz = classes[j++]) {
            pos = curClasses.indexOf(clazz);
            if (~pos) {
                curClasses.splice(pos, 1);
            } else {
                curClasses.push(clazz);
            }
        }

        finalValue = curClasses.join(" ");
        if (className != finalValue) {
            elem.className.baseVal = finalValue;
        }
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var operators = {
            "+": function (x, y) {
                    return x + y;
                },
            "-": function (x, y) {
                    return x - y;
                },
            "/": function (x, y) {
                    return x / y;
                },
            "*": function (x, y) {
                    return x * y;
                }
        },
        Str = String,
        reUnit = /[a-z]+$/i,
        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    eve.on("snap.util.attr", function (val) {
        var plus = Str(val).match(reAddon);
        if (plus) {
            var evnt = eve.nt(),
                name = evnt.substring(evnt.lastIndexOf(".") + 1),
                a = this.attr(name),
                atr = {};
            eve.stop();
            var unit = plus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[plus[1]];
            if (aUnit && aUnit == unit) {
                val = op(parseFloat(a), +plus[2]);
            } else {
                a = this.asPX(name);
                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
            }
            if (isNaN(a) || isNaN(val)) {
                return;
            }
            atr[name] = val;
            this.attr(atr);
        }
    })(-10);
    eve.on("snap.util.equal", function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this,
            bplus = Str(b).match(reAddon);
        if (bplus) {
            eve.stop();
            var unit = bplus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[bplus[1]];
            if (aUnit && aUnit == unit) {
                return {
                    from: parseFloat(a),
                    to: op(parseFloat(a), +bplus[2]),
                    f: getUnit(aUnit)
                };
            } else {
                a = this.asPX(name);
                return {
                    from: a,
                    to: op(a, this.asPX(name, bplus[2] + unit)),
                    f: getNumber
                };
            }
        }
    })(-10);
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var proto = Paper.prototype,
        is = Snap.is;
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - rx (number) #optional horizontal radius for rounded corners, default is 0
     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
     = (object) the `rect` element
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    proto.rect = function (x, y, w, h, rx, ry) {
        var attr;
        if (ry == null) {
            ry = rx;
        }
        if (is(x, "object") && x == "[object Object]") {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                width: w,
                height: h
            };
            if (rx != null) {
                attr.rx = rx;
                attr.ry = ry;
            }
        }
        return this.el("rect", attr);
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) the `circle` element
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    proto.circle = function (cx, cy, r) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr = {
                cx: cx,
                cy: cy,
                r: r
            };
        }
        return this.el("circle", attr);
    };

    var preload = (function () {
        function onerror() {
            this.parentNode.removeChild(this);
        }
        return function (src, f) {
            var img = glob.doc.createElement("img"),
                body = glob.doc.body;
            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
            img.onload = function () {
                f.call(img);
                img.onload = img.onerror = null;
                body.removeChild(img);
            };
            img.onerror = onerror;
            body.appendChild(img);
            img.src = src;
        };
    }());

    /*\
     * Paper.image
     [ method ]
     **
     * Places an image on the surface
     **
     - src (string) URI of the source image
     - x (number) x offset position
     - y (number) y offset position
     - width (number) width of the image
     - height (number) height of the image
     = (object) the `image` element
     * or
     = (object) Snap element object with type `image`
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    proto.image = function (src, x, y, width, height) {
        var el = this.el("image");
        if (is(src, "object") && "src" in src) {
            el.attr(src);
        } else if (src != null) {
            var set = {
                "xlink:href": src,
                preserveAspectRatio: "none"
            };
            if (x != null && y != null) {
                set.x = x;
                set.y = y;
            }
            if (width != null && height != null) {
                set.width = width;
                set.height = height;
            } else {
                preload(src, function () {
                    Snap._.$(el.node, {
                        width: this.offsetWidth,
                        height: this.offsetHeight
                    });
                });
            }
            Snap._.$(el.node, set);
        }
        return el;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) the `ellipse` element
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    proto.ellipse = function (cx, cy, rx, ry) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr ={
                cx: cx,
                cy: cy,
                rx: rx,
                ry: ry
            };
        }
        return this.el("ellipse", attr);
    };
    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a `<path>` element using the given string as the path's definition
     - pathString (string) #optional path string in SVG format
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
     | "M10,20L30,40"
     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
    \*/
    proto.path = function (d) {
        var attr;
        if (is(d, "object") && !is(d, "array")) {
            attr = d;
        } else if (d) {
            attr = {d: d};
        }
        return this.el("path", attr);
    };
    /*\
     * Paper.g
     [ method ]
     **
     * Creates a group element
     **
     - varargs (…) #optional elements to nest within the group
     = (object) the `g` element
     **
     > Usage
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g(c2, c1); // note that the order of elements is different
     * or
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g();
     | g.add(c2, c1);
    \*/
    /*\
     * Paper.group
     [ method ]
     **
     * See @Paper.g
    \*/
    proto.group = proto.g = function (first) {
        var attr,
            el = this.el("g");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.svg
     [ method ]
     **
     * Creates a nested SVG element.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `svg` element
     **
    \*/
    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
        var attrs = {};
        if (is(x, "object") && y == null) {
            attrs = x;
        } else {
            if (x != null) {
                attrs.x = x;
            }
            if (y != null) {
                attrs.y = y;
            }
            if (width != null) {
                attrs.width = width;
            }
            if (height != null) {
                attrs.height = height;
            }
            if (vbx != null && vby != null && vbw != null && vbh != null) {
                attrs.viewBox = [vbx, vby, vbw, vbh];
            }
        }
        return this.el("svg", attrs);
    };
    /*\
     * Paper.mask
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except it’s a mask.
     **
     = (object) the `mask` element
     **
    \*/
    proto.mask = function (first) {
        var attr,
            el = this.el("mask");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.ptrn
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except it’s a pattern.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `pattern` element
     **
    \*/
    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
        if (is(x, "object")) {
            var attr = x;
        } else {
            attr = {patternUnits: "userSpaceOnUse"};
            if (x) {
                attr.x = x;
            }
            if (y) {
                attr.y = y;
            }
            if (width != null) {
                attr.width = width;
            }
            if (height != null) {
                attr.height = height;
            }
            if (vx != null && vy != null && vw != null && vh != null) {
                attr.viewBox = [vx, vy, vw, vh];
            } else {
                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
            }
        }
        return this.el("pattern", attr);
    };
    /*\
     * Paper.use
     [ method ]
     **
     * Creates a <use> element.
     - id (string) @optional id of element to link
     * or
     - id (Element) @optional element to link
     **
     = (object) the `use` element
     **
    \*/
    proto.use = function (id) {
        if (id != null) {
            if (id instanceof Element) {
                if (!id.attr("id")) {
                    id.attr({id: Snap._.id(id)});
                }
                id = id.attr("id");
            }
            if (String(id).charAt() == "#") {
                id = id.substring(1);
            }
            return this.el("use", {"xlink:href": "#" + id});
        } else {
            return Element.prototype.use.call(this);
        }
    };
    /*\
     * Paper.symbol
     [ method ]
     **
     * Creates a <symbol> element.
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     = (object) the `symbol` element
     **
    \*/
    proto.symbol = function (vx, vy, vw, vh) {
        var attr = {};
        if (vx != null && vy != null && vw != null && vh != null) {
            attr.viewBox = [vx, vy, vw, vh];
        }

        return this.el("symbol", attr);
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
     = (object) the `text` element
     **
     > Usage
     | var t1 = paper.text(50, 50, "Snap");
     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
     | // Text path usage
     | t1.attr({textpath: "M10,10L100,100"});
     | // or
     | var pth = paper.path("M10,10L100,100");
     | t1.attr({textpath: pth});
    \*/
    proto.text = function (x, y, text) {
        var attr = {};
        if (is(x, "object")) {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                text: text || ""
            };
        }
        return this.el("text", attr);
    };
    /*\
     * Paper.line
     [ method ]
     **
     * Draws a line
     **
     - x1 (number) x coordinate position of the start
     - y1 (number) y coordinate position of the start
     - x2 (number) x coordinate position of the end
     - y2 (number) y coordinate position of the end
     = (object) the `line` element
     **
     > Usage
     | var t1 = paper.line(50, 50, 100, 100);
    \*/
    proto.line = function (x1, y1, x2, y2) {
        var attr = {};
        if (is(x1, "object")) {
            attr = x1;
        } else if (x1 != null) {
            attr = {
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2
            };
        }
        return this.el("line", attr);
    };
    /*\
     * Paper.polyline
     [ method ]
     **
     * Draws a polyline
     **
     - points (array) array of points
     * or
     - varargs (…) points
     = (object) the `polyline` element
     **
     > Usage
     | var p1 = paper.polyline([10, 10, 100, 100]);
     | var p2 = paper.polyline(10, 10, 100, 100);
    \*/
    proto.polyline = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = {points: points};
        }
        return this.el("polyline", attr);
    };
    /*\
     * Paper.polygon
     [ method ]
     **
     * Draws a polygon. See @Paper.polyline
    \*/
    proto.polygon = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = {points: points};
        }
        return this.el("polygon", attr);
    };
    // gradients
    (function () {
        var $ = Snap._.$;
        // gradients' helpers
        /*\
         * Element.stops
         [ method ]
         **
         * Only for gradients!
         * Returns array of gradient stops elements.
         = (array) the stops array.
        \*/
        function Gstops() {
            return this.selectAll("stop");
        }
        /*\
         * Element.addStop
         [ method ]
         **
         * Only for gradients!
         * Adds another stop to the gradient.
         - color (string) stops color
         - offset (number) stops offset 0..100
         = (object) gradient element
        \*/
        function GaddStop(color, offset) {
            var stop = $("stop"),
                attr = {
                    offset: +offset + "%"
                };
            color = Snap.color(color);
            attr["stop-color"] = color.hex;
            if (color.opacity < 1) {
                attr["stop-opacity"] = color.opacity;
            }
            $(stop, attr);
            var stops = this.stops(),
                inserted;
            for (var i = 0; i < stops.length; i++) {
                var stopOffset = parseFloat(stops[i].attr("offset"));
                if (stopOffset > offset) {
                    this.node.insertBefore(stop, stops[i].node);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                this.node.appendChild(stop);
            }
            return this;
        }
        function GgetBBox() {
            if (this.type == "linearGradient") {
                var x1 = $(this.node, "x1") || 0,
                    x2 = $(this.node, "x2") || 1,
                    y1 = $(this.node, "y1") || 0,
                    y2 = $(this.node, "y2") || 0;
                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
            } else {
                var cx = this.node.cx || .5,
                    cy = this.node.cy || .5,
                    r = this.node.r || 0;
                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
            }
        }
        /*\
         * Element.setStops
         [ method ]
         **
         * Only for gradients!
         * Updates stops of the gradient based on passed gradient descriptor. See @Ppaer.gradient
         - str (string) gradient descriptor part after `()`.
         = (object) gradient element
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         | g.setStops("#fff-#000-#f00-#fc0");
        \*/
        function GsetStops(str) {
            var grad = str,
                stops = this.stops();
            if (typeof str == "string") {
                grad = eve("snap.util.grad.parse", null, "l(0,0,0,1)" + str).firstDefined().stops;
            }
            if (!Snap.is(grad, "array")) {
                return;
            }
            for (var i = 0; i < stops.length; i++) {
                if (grad[i]) {
                    var color = Snap.color(grad[i].color),
                        attr = {"offset": grad[i].offset + "%"};
                    attr["stop-color"] = color.hex;
                    if (color.opacity < 1) {
                        attr["stop-opacity"] = color.opacity;
                    }
                    stops[i].attr(attr);
                } else {
                    stops[i].remove();
                }
            }
            for (i = stops.length; i < grad.length; i++) {
                this.addStop(grad[i].color, grad[i].offset);
            }
            return this;
        }
        function gradient(defs, str) {
            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                el;
            if (!grad) {
                return null;
            }
            grad.params.unshift(defs);
            if (grad.type.toLowerCase() == "l") {
                el = gradientLinear.apply(0, grad.params);
            } else {
                el = gradientRadial.apply(0, grad.params);
            }
            if (grad.type != grad.type.toLowerCase()) {
                $(el.node, {
                    gradientUnits: "userSpaceOnUse"
                });
            }
            var stops = grad.stops,
                len = stops.length;
            for (var i = 0; i < len; i++) {
                var stop = stops[i];
                el.addStop(stop.color, stop.offset);
            }
            return el;
        }
        function gradientLinear(defs, x1, y1, x2, y2) {
            var el = Snap._.make("linearGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            el.setStops = GsetStops;
            if (x1 != null) {
                $(el.node, {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                });
            }
            return el;
        }
        function gradientRadial(defs, cx, cy, r, fx, fy) {
            var el = Snap._.make("radialGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            if (cx != null) {
                $(el.node, {
                    cx: cx,
                    cy: cy,
                    r: r
                });
            }
            if (fx != null && fy != null) {
                $(el.node, {
                    fx: fx,
                    fy: fy
                });
            }
            return el;
        }
        /*\
         * Paper.gradient
         [ method ]
         **
         * Creates a gradient element
         **
         - gradient (string) gradient descriptor
         > Gradient Descriptor
         * The gradient descriptor is an expression formatted as
         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
         * either linear or radial.  The uppercase `L` or `R` letters
         * indicate absolute coordinates offset from the SVG surface.
         * Lowercase `l` or `r` letters indicate coordinates
         * calculated relative to the element to which the gradient is
         * applied.  Coordinates specify a linear gradient vector as
         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
         * `r` and optional `fx`, `fy` specifying a focal point away
         * from the center of the circle. Specify `<colors>` as a list
         * of dash-separated CSS color values.  Each color may be
         * followed by a custom offset value, separated with a colon
         * character.
         > Examples
         * Linear gradient, relative from top-left corner to bottom-right
         * corner, from black through red to white:
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         * Linear gradient, absolute from (0, 0) to (100, 100), from black
         * through red at 25% to white:
         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
         * Radial gradient, relative from the center of the element with radius
         * half the width, from black to white:
         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
         * To apply the gradient:
         | paper.circle(50, 50, 40).attr({
         |     fill: g
         | });
         = (object) the `gradient` element
        \*/
        proto.gradient = function (str) {
            return gradient(this.defs, str);
        };
        proto.gradientLinear = function (x1, y1, x2, y2) {
            return gradientLinear(this.defs, x1, y1, x2, y2);
        };
        proto.gradientRadial = function (cx, cy, r, fx, fy) {
            return gradientRadial(this.defs, cx, cy, r, fx, fy);
        };
        /*\
         * Paper.toString
         [ method ]
         **
         * Returns SVG code for the @Paper
         = (string) SVG code for the @Paper
        \*/
        proto.toString = function () {
            var doc = this.node.ownerDocument,
                f = doc.createDocumentFragment(),
                d = doc.createElement("div"),
                svg = this.node.cloneNode(true),
                res;
            f.appendChild(d);
            d.appendChild(svg);
            Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
            res = d.innerHTML;
            f.removeChild(f.firstChild);
            return res;
        };
        /*\
         * Paper.toDataURL
         [ method ]
         **
         * Returns SVG code for the @Paper as Data URI string.
         = (string) Data URI string
        \*/
        proto.toDataURL = function () {
            if (window && window.btoa) {
                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
            }
        };
        /*\
         * Paper.clear
         [ method ]
         **
         * Removes all child nodes of the paper, except <defs>.
        \*/
        proto.clear = function () {
            var node = this.node.firstChild,
                next;
            while (node) {
                next = node.nextSibling;
                if (node.tagName != "defs") {
                    node.parentNode.removeChild(node);
                } else {
                    proto.clear.call({node: node});
                }
                node = next;
            }
        };
    }());
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        is = Snap.is,
        clone = Snap._.clone,
        has = "hasOwnProperty",
        p2s = /,?([a-z]),?/gi,
        toFloat = parseFloat,
        math = Math,
        PI = math.PI,
        mmin = math.min,
        mmax = math.max,
        pow = math.pow,
        abs = math.abs;
    function paths(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    }
    function box(x, y, width, height) {
        if (x == null) {
            x = y = width = height = 0;
        }
        if (y == null) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        return {
            x: x,
            y: y,
            width: width,
            w: width,
            height: height,
            h: height,
            x2: x + width,
            y2: y + height,
            cx: x + width / 2,
            cy: y + height / 2,
            r1: math.min(width, height) / 2,
            r2: math.max(width, height) / 2,
            r0: math.sqrt(width * width + height * height) / 2,
            path: rectPath(x, y, width, height),
            vb: [x, y, width, height].join(" ")
        };
    }
    function toString() {
        return this.join(",").replace(p2s, "$1");
    }
    function pathClone(pathArray) {
        var res = clone(pathArray);
        res.toString = toString;
        return res;
    }
    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    }
    function getLengthFactory(istotal, subpath) {
        function O(val) {
            return +(+val).toFixed(3);
        }
        return Snap._.cacher(function (path, length, onlystart) {
            if (path instanceof Element) {
                path = path.attr("d");
            }
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                "C" + O(point.start.x),
                                O(point.start.y),
                                O(point.m.x),
                                O(point.m.y),
                                O(point.x),
                                O(point.y)
                            ];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = [
                                "M" + O(point.x),
                                O(point.y) + "C" + O(point.n.x),
                                O(point.n.y),
                                O(point.end.x),
                                O(point.end.y),
                                O(p[5]),
                                O(p[6])
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return point;
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            return point;
        }, null, Snap._.clone);
    }
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        // (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    }
    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!Snap.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return box(
            bbox.min.x,
            bbox.min.y,
            bbox.max.x - bbox.min.x,
            bbox.max.y - bbox.min.y
        );
    }
    function isPointInsideBBox(bbox, x, y) {
        return  x >= bbox.x &&
                x <= bbox.x + bbox.width &&
                y >= bbox.y &&
                y <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1),
            bbox2 = bezierBBox(bez2);
        if (!isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 8),
            n2 = ~~(l2 / 8),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
    }
    function pathIntersectionNumber(path1, path2) {
        return interPathHelper(path1, path2, 1);
    }
    function interPathHelper(path1, path2, justCount) {
        path1 = path2curve(path1);
        path2 = path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    function isPointInsidePath(path, x, y) {
        var bbox = pathBBox(path);
        return isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    }
    function pathBBox(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return box();
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X.concat(dim.min.x, dim.max.x);
                Y = Y.concat(dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin.apply(0, X),
            ymin = mmin.apply(0, Y),
            xmax = mmax.apply(0, X),
            ymax = mmax.apply(0, Y),
            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
        pth.bbox = clone(bb);
        return bb;
    }
    function rectPath(x, y, w, h, r) {
        if (r) {
            return [
                ["M", +x + +r, y],
                ["l", w - r * 2, 0],
                ["a", r, r, 0, 0, 1, r, r],
                ["l", 0, h - r * 2],
                ["a", r, r, 0, 0, 1, -r, r],
                ["l", r * 2 - w, 0],
                ["a", r, r, 0, 0, 1, -r, -r],
                ["l", 0, r * 2 - h],
                ["a", r, r, 0, 0, 1, r, -r],
                ["z"]
            ];
        }
        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        res.toString = toString;
        return res;
    }
    function ellipsePath(x, y, rx, ry, a) {
        if (a == null && ry == null) {
            ry = rx;
        }
        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;
        if (a != null) {
            var rad = Math.PI / 180,
                x1 = x + rx * Math.cos(-ry * rad),
                x2 = x + rx * Math.cos(-a * rad),
                y1 = y + rx * Math.sin(-ry * rad),
                y2 = y + rx * Math.sin(-a * rad),
                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
            res = [
                ["M", x, y],
                ["m", 0, -ry],
                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
                ["z"]
            ];
        }
        res.toString = toString;
        return res;
    }
    var unit2px = Snap._unit2px,
        getPath = {
        path: function (el) {
            return el.attr("path");
        },
        circle: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx, attr.cy, attr.r);
        },
        ellipse: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
        },
        rect: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
        },
        image: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
        },
        line: function (el) {
            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
        },
        polyline: function (el) {
            return "M" + el.attr("points");
        },
        polygon: function (el) {
            return "M" + el.attr("points") + "z";
        },
        deflt: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    function pathToRelative(pathArray) {
        var pth = paths(pathArray),
            lowerCase = String.prototype.toLowerCase;
        if (pth.rel) {
            return pathClone(pth.rel);
        }
        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
            pathArray = Snap.parsePathString(pathArray);
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push(["M", x, y]);
        }
        for (var i = start, ii = pathArray.length; i < ii; i++) {
            var r = res[i] = [],
                pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch (r[0]) {
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for (var j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                        }
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    res[i][k] = pa[k];
                }
            }
            var len = res[i].length;
            switch (res[i][0]) {
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = toString;
        pth.rel = pathClone(res);
        return res;
    }
    function pathToAbsolute(pathArray) {
        var pth = paths(pathArray);
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
            pathArray = Snap.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            return [["M", 0, 0]];
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0,
            pa0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 &&
            pathArray[0][0] == "M" &&
            pathArray[1][0].toUpperCase() == "R" &&
            pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            pa0 = pa[0];
            if (pa0 != pa0.toUpperCase()) {
                r[0] = pa0.toUpperCase();
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +pa[6] + x;
                        r[7] = +pa[7] + y;
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y].concat(pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res.concat(catmullRom2bezier(dots, crz));
                        break;
                    case "O":
                        res.pop();
                        dots = ellipsePath(x, y, pa[1], pa[2]);
                        dots.push(dots[0]);
                        res = res.concat(dots);
                        break;
                    case "U":
                        res.pop();
                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                        r = ["U"].concat(res[res.length - 1].slice(-2));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + (j % 2 ? x : y);
                        }
                }
            } else if (pa0 == "R") {
                dots = [x, y].concat(pa.slice(1));
                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                r = ["R"].concat(pa.slice(-2));
            } else if (pa0 == "O") {
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
            } else if (pa0 == "U") {
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ["U"].concat(res[res.length - 1].slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            pa0 = pa0.toUpperCase();
            if (pa0 != "O") {
                switch (r[0]) {
                    case "Z":
                        x = +mx;
                        y = +my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
        }
        res.toString = toString;
        pth.abs = pathClone(res);
        return res;
    }
    function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }
    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
    }
    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = Snap._.cacher(function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y};
            });
        if (!rx || !ry) {
            return [x1, y1, x2, y2, x2, y2];
        }
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4].concat(res);
        } else {
            res = [m2, m3, m4].concat(res).join().split(",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }
    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    }

    // Returns bounding box of cubic bezier curve.
    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    // Original version: NISHIO Hirokazu
    // Modifications: https://github.com/timo22345
    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [],
            bounds = [[], []],
            a, b, c, t, t1, t2, b2ac, sqrtb2ac;
        for (var i = 0; i < 2; ++i) {
            if (i == 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (abs(a) < 1e-12) {
                if (abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                    tvalues.push(t);
                }
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = math.sqrt(b2ac);
            if (b2ac < 0) {
                continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
            }
        }

        var x, y, j = tvalues.length,
            jlen = j,
            mt;
        while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;


        return {
          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
        };
    }

    function path2curve(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny].concat(path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i] = "A"); // the same as above
                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C") {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i - 1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i] != "A" && pfirst == "C") {
                    pcoms2[i] = "C";
                }

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }
    function mapPath(path, matrix) {
        if (!matrix) {
            return path;
        }
        var x, y, i, j, ii, jj, pathi;
        path = path2curve(path);
        for (i = 0, ii = path.length; i < ii; i++) {
            pathi = path[i];
            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    }

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }

    // export
    Snap.path = paths;

    /*\
     * Snap.path.getTotalLength
     [ method ]
     **
     * Returns the length of the given path in pixels
     **
     - path (string) SVG path string
     **
     = (number) length
    \*/
    Snap.path.getTotalLength = getTotalLength;
    /*\
     * Snap.path.getPointAtLength
     [ method ]
     **
     * Returns the coordinates of the point located at the given length along the given path
     **
     - path (string) SVG path string
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    Snap.path.getPointAtLength = getPointAtLength;
    /*\
     * Snap.path.getSubpath
     [ method ]
     **
     * Returns the subpath of a given path between given start and end lengths
     **
     - path (string) SVG path string
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    Snap.path.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns the length of the path in pixels (only works for `path` elements)
     = (number) length
    \*/
    elproto.getTotalLength = function () {
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
    };
    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
     **
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        return getPointAtLength(this.attr("d"), length);
    };
    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
     **
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        return Snap.path.getSubpath(this.attr("d"), from, to);
    };
    Snap._.box = box;
    /*\
     * Snap.path.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Finds dot coordinates on the given cubic beziér curve at the given t
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point,
     o     y: (number) y coordinate of the point,
     o     m: {
     o         x: (number) x coordinate of the left anchor,
     o         y: (number) y coordinate of the left anchor
     o     },
     o     n: {
     o         x: (number) x coordinate of the right anchor,
     o         y: (number) y coordinate of the right anchor
     o     },
     o     start: {
     o         x: (number) x coordinate of the start of the curve,
     o         y: (number) y coordinate of the start of the curve
     o     },
     o     end: {
     o         x: (number) x coordinate of the end of the curve,
     o         y: (number) y coordinate of the end of the curve
     o     },
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    Snap.path.findDotsAtSegment = findDotsAtSegment;
    /*\
     * Snap.path.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given cubic beziér curve
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for beziér curve
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.bezierBBox = bezierBBox;
    /*\
     * Snap.path.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding box
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point is inside
    \*/
    Snap.path.isPointInsideBBox = isPointInsideBBox;
    Snap.closest = function (x, y, X, Y) {
        var r = 100,
            b = box(x - r / 2, y - r / 2, r, r),
            inside = [],
            getter = X[0].hasOwnProperty("x") ? function (i) {
                return {
                    x: X[i].x,
                    y: X[i].y
                };
            } : function (i) {
                return {
                    x: X[i],
                    y: Y[i]
                };
            },
            found = 0;
        while (r <= 1e6 && !found) {
            for (var i = 0, ii = X.length; i < ii; i++) {
                var xy = getter(i);
                if (isPointInsideBBox(b, xy.x, xy.y)) {
                    found++;
                    inside.push(xy);
                    break;
                }
            }
            if (!found) {
                r *= 2;
                b = box(x - r / 2, y - r / 2, r, r)
            }
        }
        if (r == 1e6) {
            return;
        }
        var len = Infinity,
            res;
        for (i = 0, ii = inside.length; i < ii; i++) {
            var l = Snap.len(x, y, inside[i].x, inside[i].y);
            if (len > l) {
                len = l;
                inside[i].len = l;
                res = inside[i];
            }
        }
        return res;
    };
    /*\
     * Snap.path.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if bounding boxes intersect
    \*/
    Snap.path.isBBoxIntersect = isBBoxIntersect;
    /*\
     * Snap.path.intersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point,
     o         y: (number) y coordinate of the point,
     o         t1: (number) t value for segment of path1,
     o         t2: (number) t value for segment of path2,
     o         segment1: (number) order number for segment of path1,
     o         segment2: (number) order number for segment of path2,
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/
    Snap.path.intersection = pathIntersection;
    Snap.path.intersectionNumber = pathIntersectionNumber;
    /*\
     * Snap.path.isPointInside
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     *
     * Note: fill mode doesn’t affect the result of this method.
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) `true` if point is inside the path
    \*/
    Snap.path.isPointInside = isPointInsidePath;
    /*\
     * Snap.path.getBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given path
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.getBBox = pathBBox;
    Snap.path.get = getPath;
    /*\
     * Snap.path.toRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into relative values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toRelative = pathToRelative;
    /*\
     * Snap.path.toAbsolute
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into absolute values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toAbsolute = pathToAbsolute;
    /*\
     * Snap.path.toCubic
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic beziér curves
     - pathString (string|array) path string or array of segments
     = (array) array of segments
    \*/
    Snap.path.toCubic = path2curve;
    /*\
     * Snap.path.map
     [ method ]
     **
     * Transform the path string with the given matrix
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \*/
    Snap.path.map = mapPath;
    Snap.path.toString = toString;
    Snap.path.clone = pathClone;
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var mmax = Math.max,
        mmin = Math.min;

    // Set
    var Set = function (items) {
        this.items = [];
	this.bindings = {};
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i]) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set
     *
     * If the function returns `false`, the loop stops running.
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    /*\
     * Set.animate
     [ method ]
     **
     * Animates each element in set in sync.
     *
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     * or
     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
     > Usage
     | // animate all elements in set to radius 10
     | set.animate({r: 10}, 500, mina.easein);
     | // or
     | // animate first element to radius 10, but second to radius 20 and in different time
     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
     = (Element) the current element
    \*/
    setproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Snap._.Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = easing.dur;
            attrs = attrs.attr;
        }
        var args = arguments;
        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
            var each = true;
        }
        var begin,
            handler = function () {
                if (begin) {
                    this.b = begin;
                } else {
                    begin = this.b;
                }
            },
            cb = 0,
            set = this,
            callbacker = callback && function () {
                if (++cb == set.length) {
                    callback.call(this);
                }
            };
        return this.forEach(function (el, i) {
            eve.once("snap.animcreated." + el.id, handler);
            if (each) {
                args[i] && el.animate.apply(el, args[i]);
            } else {
                el.animate(attrs, ms, easing, callbacker);
            }
        });
    };
    /*\
     * Set.remove
     [ method ]
     **
     * Removes all children of the set.
     *
     = (object) Set object
    \*/
    setproto.remove = function () {
        while (this.length) {
            this.pop().remove();
        }
        return this;
    };
    /*\
     * Set.bind
     [ method ]
     **
     * Specifies how to handle a specific attribute when applied
     * to a set.
     *
     **
     - attr (string) attribute name
     - callback (function) function to run
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     - eattr (string) attribute on the element to bind the attribute to
     = (object) Set object
    \*/
    setproto.bind = function (attr, a, b) {
        var data = {};
        if (typeof a == "function") {
            this.bindings[attr] = a;
        } else {
            var aname = b || attr;
            this.bindings[attr] = function (v) {
                data[aname] = v;
                a.attr(data);
            };
        }
        return this;
    };
    /*\
     * Set.attr
     [ method ]
     **
     * Equivalent of @Element.attr.
     = (object) Set object
    \*/
    setproto.attr = function (value) {
        var unbound = {};
        for (var k in value) {
            if (this.bindings[k]) {
                this.bindings[k](value[k]);
            } else {
                unbound[k] = value[k];
            }
        }
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            this.items[i].attr(unbound);
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes range of elements from the set
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     - element (object) element to remove
     = (boolean) `true` if object was found and removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
        return false;
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Inserts set elements after given element.
     **
     - element (object) set will be inserted after this element
     = (object) Set object
    \*/
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    /*\
     * Set.getBBox
     [ method ]
     **
     * Union of all bboxes of the set. See @Element.getBBox.
     = (object) bounding box descriptor. See @Element.getBBox.
    \*/
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin.apply(0, x);
        y = mmin.apply(0, y);
        x2 = mmax.apply(0, x2);
        y2 = mmax.apply(0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y,
            cx: x + (x2 - x) / 2,
            cy: y + (y2 - y) / 2
        };
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Creates a clone of the set.
     **
     = (object) New Set object
    \*/
    setproto.clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Snap\u2018s set";
    };
    setproto.type = "set";
    // export
    /*\
     * Snap.Set
     [ property ]
     **
     * Set constructor.
    \*/
    Snap.Set = Set;
    /*\
     * Snap.set
     [ method ]
     **
     * Creates a set and fills it with list of arguments.
     **
     = (object) New Set object
     | var r = paper.rect(0, 0, 10, 10),
     |     s1 = Snap.set(), // empty set
     |     s2 = Snap.set(r, paper.circle(100, 100, 20)); // prefilled set
    \*/
    Snap.set = function () {
        var set = new Set;
        if (arguments.length) {
            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
        }
        return set;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var names = {},
        reUnit = /[%a-z]+$/i,
        Str = String;
    names.stroke = names.fill = "colour";
    function getEmpty(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t": return [l, 0, 0];
            case "m": return [l, 1, 0, 0, 1, 0, 0];
            case "r": if (item.length == 4) {
                return [l, 0, item[2], item[3]];
            } else {
                return [l, 0];
            }
            case "s": if (item.length == 5) {
                return [l, 1, 1, item[3], item[4]];
            } else if (item.length == 3) {
                return [l, 1, 1];
            } else {
                return [l, 1];
            }
        }
    }
    function equaliseTransform(t1, t2, getBBox) {
        t1 = t1 || new Snap.Matrix;
        t2 = t2 || new Snap.Matrix;
        t1 = Snap.parseTransformString(t1.toTransformString()) || [];
        t2 = Snap.parseTransformString(t2.toTransformString()) || [];
        var maxlength = Math.max(t1.length, t2.length),
            from = [],
            to = [],
            i = 0, j, jj,
            tt1, tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] ||
                tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) ||
                tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])
                ) {
                    t1 = Snap._.transform2matrix(t1, getBBox());
                    t2 = Snap._.transform2matrix(t2, getBBox());
                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                    break;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: path2array(from),
            to: path2array(to),
            f: getPath(from)
        };
    }
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    function getViewBox(val) {
        return val.join(" ");
    }
    function getColour(clr) {
        return Snap.rgb(clr[0], clr[1], clr[2], clr[3]);
    }
    function getPath(path) {
        var k = 0, i, ii, j, jj, out, a, b = [];
        for (i = 0, ii = path.length; i < ii; i++) {
            out = "[";
            a = ['"' + path[i][0] + '"'];
            for (j = 1, jj = path[i].length; j < jj; j++) {
                a[j] = "val[" + k++ + "]";
            }
            out += a + "]";
            b[i] = out;
        }
        return Function("val", "return Snap.path.toString.call([" + b + "])");
    }
    function path2array(path) {
        var out = [];
        for (var i = 0, ii = path.length; i < ii; i++) {
            for (var j = 1, jj = path[i].length; j < jj; j++) {
                out.push(path[i][j]);
            }
        }
        return out;
    }
    function isNumeric(obj) {
        return isFinite(obj);
    }
    function arrayEqual(arr1, arr2) {
        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
            return false;
        }
        return arr1.toString() == arr2.toString();
    }
    Element.prototype.equal = function (name, b) {
        return eve("snap.util.equal", this, name, b).firstDefined();
    };
    eve.on("snap.util.equal", function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this;
        if (names[name] == "colour") {
            A = Snap.color(a);
            B = Snap.color(b);
            return {
                from: [A.r, A.g, A.b, A.opacity],
                to: [B.r, B.g, B.b, B.opacity],
                f: getColour
            };
        }
        if (name == "viewBox") {
            A = this.attr(name).vb.split(" ").map(Number);
            B = b.split(" ").map(Number);
            return {
                from: A,
                to: B,
                f: getViewBox
            };
        }
        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
            if (typeof b == "string") {
                b = Str(b).replace(/\.{3}|\u2026/g, a);
            }
            a = this.matrix;
            if (!Snap._.rgTransform.test(b)) {
                b = Snap._.transform2matrix(Snap._.svgTransform2string(b), this.getBBox());
            } else {
                b = Snap._.transform2matrix(b, this.getBBox());
            }
            return equaliseTransform(a, b, function () {
                return el.getBBox(1);
            });
        }
        if (name == "d" || name == "path") {
            A = Snap.path.toCubic(a, b);
            return {
                from: path2array(A[0]),
                to: path2array(A[1]),
                f: getPath(A[0])
            };
        }
        if (name == "points") {
            A = Str(a).split(Snap._.separator);
            B = Str(b).split(Snap._.separator);
            return {
                from: A,
                to: B,
                f: function (val) { return val; }
            };
        }
        if (isNumeric(a) && isNumeric(b)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getNumber
            };
        }
        var aUnit = a.match(reUnit),
            bUnit = Str(b).match(reUnit);
        if (aUnit && arrayEqual(aUnit, bUnit)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getUnit(aUnit)
            };
        } else {
            return {
                from: this.asPX(name),
                to: this.asPX(name, b),
                f: getNumber
            };
        }
    });
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
    has = "hasOwnProperty",
    supportsTouch = "createTouch" in glob.doc,
    events = [
        "click", "dblclick", "mousedown", "mousemove", "mouseout",
        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
        "touchcancel"
    ],
    touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },
    getScroll = function (xy, el) {
        var name = xy == "y" ? "scrollTop" : "scrollLeft",
            doc = el && el.node ? el.node.ownerDocument : glob.doc;
        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
    },
    preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = function (obj, type, fn, element) {
        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
            f = function (e) {
                var scrollY = getScroll("y", element),
                    scrollX = getScroll("x", element);
                if (supportsTouch && touchMap[has](type)) {
                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                            var olde = e;
                            e = e.targetTouches[i];
                            e.originalEvent = olde;
                            e.preventDefault = preventTouch;
                            e.stopPropagation = stopTouch;
                            break;
                        }
                    }
                }
                var x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                return fn.call(element, e, x, y);
            };

        if (type !== realName) {
            obj.addEventListener(type, f, false);
        }

        obj.addEventListener(realName, f, false);

        return function () {
            if (type !== realName) {
                obj.removeEventListener(type, f, false);
            }

            obj.removeEventListener(realName, f, false);
            return true;
        };
    },
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = getScroll("y"),
            scrollX = getScroll("x"),
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches && e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            // glob.win.opera && parent.removeChild(node);
            // node.style.display = "none";
            // o = dragi.el.paper.getElementByPoint(x, y);
            // node.style.display = display;
            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        Snap.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            eve.off("snap.drag.*." + dragi.el.id);
        }
        drag = [];
    };
    /*\
     * Element.click
     [ method ]
     **
     * Adds a click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes a click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds a double click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes a double click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds a mousedown event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes a mousedown event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds a mousemove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes a mousemove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds a mouseout event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes a mouseout event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds a mouseover event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes a mouseover event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds a mouseup event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes a mouseup event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds a touchstart event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes a touchstart event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds a touchmove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes a touchmove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchend
     [ method ]
     **
     * Adds a touchend event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes a touchend event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds a touchcancel event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes a touchcancel event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            Snap[eventName] = elproto[eventName] = function (fn, scope) {
                if (Snap.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
                    });
                } else {
                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {
                        try {
                            this.events[i].f.call(this);
                        } catch (e) {}
                    }
                }
                return this;
            };
            Snap["un" + eventName] =
            elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) if (events[l].name == eventName &&
                               (events[l].f == fn || !fn)) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    /*\
     * Element.hover
     [ method ]
     **
     * Adds hover event handlers to the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes hover event handlers from the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for an element's drag gesture
     **
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
     * `drag.over.<id>` fires as well.
     *
     * Start event and start handler are called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler are called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler are called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        var el = this;
        if (!arguments.length) {
            var origTransform;
            return el.drag(function (dx, dy) {
                this.attr({
                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                });
            }, function () {
                origTransform = this.transform().local;
            });
        }
        function start(e, x, y) {
            (e.originalEvent || e).preventDefault();
            el._drag.x = x;
            el._drag.y = y;
            el._drag.id = e.identifier;
            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("snap.drag.start." + el.id, onstart);
            onmove && eve.on("snap.drag.move." + el.id, onmove);
            onend && eve.on("snap.drag.end." + el.id, onend);
            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
        }
        function init(e, x, y) {
            eve("snap.draginit." + el.id, el, e, x, y);
        }
        eve.on("snap.draginit." + el.id, start);
        el._drag = {};
        draggable.push({el: el, start: start, init: init});
        el.mousedown(init);
        return el;
    };
    /*
     * Element.onDragOver
     [ method ]
     **
     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    // elproto.onDragOver = function (f) {
    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
    // };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from the given element
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].init);
            draggable.splice(i, 1);
            eve.unbind("snap.drag.*." + this.id);
            eve.unbind("snap.draginit." + this.id);
        }
        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        pproto = Paper.prototype,
        rgurl = /^\s*url\((.+)\)/,
        Str = String,
        $ = Snap._.$;
    Snap.filter = {};
    /*\
     * Paper.filter
     [ method ]
     **
     * Creates a `<filter>` element
     **
     - filstr (string) SVG fragment of filter provided as a string
     = (object) @Element
     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
     > Usage
     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    pproto.filter = function (filstr) {
        var paper = this;
        if (paper.type != "svg") {
            paper = paper.paper;
        }
        var f = Snap.parse(Str(filstr)),
            id = Snap._.id(),
            width = paper.node.offsetWidth,
            height = paper.node.offsetHeight,
            filter = $("filter");
        $(filter, {
            id: id,
            filterUnits: "userSpaceOnUse"
        });
        filter.appendChild(f.node);
        paper.defs.appendChild(filter);
        return new Element(filter);
    };

    eve.on("snap.util.getattr.filter", function () {
        eve.stop();
        var p = $(this.node, "filter");
        if (p) {
            var match = Str(p).match(rgurl);
            return match && Snap.select(match[1]);
        }
    });
    eve.on("snap.util.attr.filter", function (value) {
        if (value instanceof Element && value.type == "filter") {
            eve.stop();
            var id = value.node.id;
            if (!id) {
                $(value.node, {id: value.id});
                id = value.id;
            }
            $(this.node, {
                filter: Snap.url(id)
            });
        }
        if (!value || value == "none") {
            eve.stop();
            this.node.removeAttribute("filter");
        }
    });
    /*\
     * Snap.filter.blur
     [ method ]
     **
     * Returns an SVG markup string for the blur filter
     **
     - x (number) amount of horizontal blur, in pixels
     - y (number) #optional amount of vertical blur, in pixels
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.blur(5, 10)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.blur = function (x, y) {
        if (x == null) {
            x = 2;
        }
        var def = y == null ? x : [x, y];
        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
            def: def
        });
    };
    Snap.filter.blur.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.shadow
     [ method ]
     **
     * Returns an SVG markup string for the shadow filter
     **
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - blur (number) #optional amount of blur
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * which makes blur default to `4`. Or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - opacity (number) #optional `0..1` opacity of the shadow
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.shadow(0, 2, .3)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
        if (opacity == null) {
            if (color == null) {
                opacity = blur;
                blur = 4;
                color = "#000";
            } else {
                opacity = color;
                color = blur;
                blur = 4;
            }
        }
        if (blur == null) {
            blur = 4;
        }
        if (opacity == null) {
            opacity = 1;
        }
        if (dx == null) {
            dx = 0;
            dy = 2;
        }
        if (dy == null) {
            dy = dx;
        }
        color = Snap.color(color);
        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
            color: color,
            dx: dx,
            dy: dy,
            blur: blur,
            opacity: opacity
        });
    };
    Snap.filter.shadow.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.grayscale
     [ method ]
     **
     * Returns an SVG markup string for the grayscale filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.grayscale = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
        });
    };
    Snap.filter.grayscale.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.sepia
     [ method ]
     **
     * Returns an SVG markup string for the sepia filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.sepia = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
        });
    };
    Snap.filter.sepia.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.saturate
     [ method ]
     **
     * Returns an SVG markup string for the saturate filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.saturate = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
            amount: 1 - amount
        });
    };
    Snap.filter.saturate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.hueRotate
     [ method ]
     **
     * Returns an SVG markup string for the hue-rotate filter
     **
     - angle (number) angle of rotation
     = (string) filter representation
    \*/
    Snap.filter.hueRotate = function (angle) {
        angle = angle || 0;
        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
            angle: angle
        });
    };
    Snap.filter.hueRotate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.invert
     [ method ]
     **
     * Returns an SVG markup string for the invert filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.invert = function (amount) {
        if (amount == null) {
            amount = 1;
        }
//        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: 1 - amount
        });
    };
    Snap.filter.invert.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.brightness
     [ method ]
     **
     * Returns an SVG markup string for the brightness filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.brightness = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
            amount: amount
        });
    };
    Snap.filter.brightness.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.contrast
     [ method ]
     **
     * Returns an SVG markup string for the contrast filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.contrast = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: .5 - amount / 2
        });
    };
    Snap.filter.contrast.toString = function () {
        return this();
    };
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var box = Snap._.box,
        is = Snap.is,
        firstLetter = /^[^a-z]*([tbmlrc])/i,
        toString = function () {
            return "T" + this.dx + "," + this.dy;
        };
    /*\
     * Element.getAlign
     [ method ]
     **
     * Returns shift needed to align the element relatively to given element.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
     > Usage
     | el.transform(el.getAlign(el2, "top"));
     * or
     | var dy = el.getAlign(el2, "top").dy;
    \*/
    Element.prototype.getAlign = function (el, way) {
        if (way == null && is(el, "string")) {
            way = el;
            el = null;
        }
        el = el || this.paper;
        var bx = el.getBBox ? el.getBBox() : box(el),
            bb = this.getBBox(),
            out = {};
        way = way && way.match(firstLetter);
        way = way ? way[1].toLowerCase() : "c";
        switch (way) {
            case "t":
                out.dx = 0;
                out.dy = bx.y - bb.y;
            break;
            case "b":
                out.dx = 0;
                out.dy = bx.y2 - bb.y2;
            break;
            case "m":
                out.dx = 0;
                out.dy = bx.cy - bb.cy;
            break;
            case "l":
                out.dx = bx.x - bb.x;
                out.dy = 0;
            break;
            case "r":
                out.dx = bx.x2 - bb.x2;
                out.dy = 0;
            break;
            default:
                out.dx = bx.cx - bb.cx;
                out.dy = 0;
            break;
        }
        out.toString = toString;
        return out;
    };
    /*\
     * Element.align
     [ method ]
     **
     * Aligns the element relatively to given one via transformation.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object) this element
     > Usage
     | el.align(el2, "top");
     * or
     | el.align("middle");
    \*/
    Element.prototype.align = function (el, way) {
        return this.transform("..." + this.getAlign(el, way));
    };
});

// Copyright (c) 2016 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        has = "hasOwnProperty";
    function slice(from, to, f) {
        return function (arr) {
            var res = arr.slice(from, to);
            if (res.length == 1) {
                res = res[0];
            }
            return f ? f(res) : res;
        };
    }
    var Animation = function (attr, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        this.attr = attr;
        this.dur = ms;
        easing && (this.easing = easing);
        callback && (this.callback = callback);
    };
    Snap._.Animation = Animation;
    /*\
     * Snap.animation
     [ method ]
     **
     * Creates an animation object
     **
     - attr (object) attributes of final destination
     - duration (number) duration of the animation, in milliseconds
     - easing (function) #optional one of easing functions of @mina or custom one
     - callback (function) #optional callback function that fires when animation ends
     = (object) animation object
    \*/
    Snap.animation = function (attr, ms, easing, callback) {
        return new Animation(attr, ms, easing, callback);
    };
    /*\
     * Element.inAnim
     [ method ]
     **
     * Returns a set of animations that may be able to manipulate the current element
     **
     = (object) in format:
     o {
     o     anim (object) animation object,
     o     mina (object) @mina object,
     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
    \*/
    elproto.inAnim = function () {
        var el = this,
            res = [];
        for (var id in el.anims) if (el.anims[has](id)) {
            (function (a) {
                res.push({
                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                    mina: a,
                    curStatus: a.status(),
                    status: function (val) {
                        return a.status(val);
                    },
                    stop: function () {
                        a.stop();
                    }
                });
            }(el.anims[id]));
        }
        return res;
    };
    /*\
     * Snap.animate
     [ method ]
     **
     * Runs generic animation of one number into another with a caring function
     **
     - from (number|array) number or array of numbers
     - to (number|array) number or array of numbers
     - setter (function) caring function that accepts one number argument
     - duration (number) duration, in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function to execute when animation ends
     = (object) animation object in @mina format
     o {
     o     id (string) animation id, consider it read-only,
     o     duration (function) gets or sets the duration of the animation,
     o     easing (function) easing,
     o     speed (function) gets or sets the speed of the animation,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
     | var rect = Snap().rect(0, 0, 10, 10);
     | Snap.animate(0, 10, function (val) {
     |     rect.attr({
     |         x: val
     |     });
     | }, 1000);
     | // in given context is equivalent to
     | rect.animate({x: 10}, 1000);
    \*/
    Snap.animate = function (from, to, setter, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        var now = mina.time(),
            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
        callback && eve.once("mina.finish." + anim.id, callback);
        return anim;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops all the animations for the current element
     **
     = (Element) the current element
    \*/
    elproto.stop = function () {
        var anims = this.inAnim();
        for (var i = 0, ii = anims.length; i < ii; i++) {
            anims[i].stop();
        }
        return this;
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Animates the given attributes of the element
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     = (Element) the current element
    \*/
    elproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = attrs.dur;
            attrs = attrs.attr;
        }
        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
            el = this;
        for (var key in attrs) if (attrs[has](key)) {
            if (el.equal) {
                eq = el.equal(key, Str(attrs[key]));
                from = eq.from;
                to = eq.to;
                f = eq.f;
            } else {
                from = +el.attr(key);
                to = +attrs[key];
            }
            var len = is(from, "array") ? from.length : 1;
            keys[key] = slice(fkeys.length, fkeys.length + len, f);
            fkeys = fkeys.concat(from);
            tkeys = tkeys.concat(to);
        }
        var now = mina.time(),
            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                var attr = {};
                for (var key in keys) if (keys[has](key)) {
                    attr[key] = keys[key](val);
                }
                el.attr(attr);
            }, easing);
        el.anims[anim.id] = anim;
        anim._attrs = attrs;
        anim._callback = callback;
        eve("snap.animcreated." + el.id, anim);
        eve.once("mina.finish." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
            callback && callback.call(el);
        });
        eve.once("mina.stop." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
        });
        return el;
    };
});

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    // Colours are from https://www.materialui.co
    var red         = "#ffebee#ffcdd2#ef9a9a#e57373#ef5350#f44336#e53935#d32f2f#c62828#b71c1c#ff8a80#ff5252#ff1744#d50000",
        pink        = "#FCE4EC#F8BBD0#F48FB1#F06292#EC407A#E91E63#D81B60#C2185B#AD1457#880E4F#FF80AB#FF4081#F50057#C51162",
        purple      = "#F3E5F5#E1BEE7#CE93D8#BA68C8#AB47BC#9C27B0#8E24AA#7B1FA2#6A1B9A#4A148C#EA80FC#E040FB#D500F9#AA00FF",
        deeppurple  = "#EDE7F6#D1C4E9#B39DDB#9575CD#7E57C2#673AB7#5E35B1#512DA8#4527A0#311B92#B388FF#7C4DFF#651FFF#6200EA",
        indigo      = "#E8EAF6#C5CAE9#9FA8DA#7986CB#5C6BC0#3F51B5#3949AB#303F9F#283593#1A237E#8C9EFF#536DFE#3D5AFE#304FFE",
        blue        = "#E3F2FD#BBDEFB#90CAF9#64B5F6#64B5F6#2196F3#1E88E5#1976D2#1565C0#0D47A1#82B1FF#448AFF#2979FF#2962FF",
        lightblue   = "#E1F5FE#B3E5FC#81D4FA#4FC3F7#29B6F6#03A9F4#039BE5#0288D1#0277BD#01579B#80D8FF#40C4FF#00B0FF#0091EA",
        cyan        = "#E0F7FA#B2EBF2#80DEEA#4DD0E1#26C6DA#00BCD4#00ACC1#0097A7#00838F#006064#84FFFF#18FFFF#00E5FF#00B8D4",
        teal        = "#E0F2F1#B2DFDB#80CBC4#4DB6AC#26A69A#009688#00897B#00796B#00695C#004D40#A7FFEB#64FFDA#1DE9B6#00BFA5",
        green       = "#E8F5E9#C8E6C9#A5D6A7#81C784#66BB6A#4CAF50#43A047#388E3C#2E7D32#1B5E20#B9F6CA#69F0AE#00E676#00C853",
        lightgreen  = "#F1F8E9#DCEDC8#C5E1A5#AED581#9CCC65#8BC34A#7CB342#689F38#558B2F#33691E#CCFF90#B2FF59#76FF03#64DD17",
        lime        = "#F9FBE7#F0F4C3#E6EE9C#DCE775#D4E157#CDDC39#C0CA33#AFB42B#9E9D24#827717#F4FF81#EEFF41#C6FF00#AEEA00",
        yellow      = "#FFFDE7#FFF9C4#FFF59D#FFF176#FFEE58#FFEB3B#FDD835#FBC02D#F9A825#F57F17#FFFF8D#FFFF00#FFEA00#FFD600",
        amber       = "#FFF8E1#FFECB3#FFE082#FFD54F#FFCA28#FFC107#FFB300#FFA000#FF8F00#FF6F00#FFE57F#FFD740#FFC400#FFAB00",
        orange      = "#FFF3E0#FFE0B2#FFCC80#FFB74D#FFA726#FF9800#FB8C00#F57C00#EF6C00#E65100#FFD180#FFAB40#FF9100#FF6D00",
        deeporange  = "#FBE9E7#FFCCBC#FFAB91#FF8A65#FF7043#FF5722#F4511E#E64A19#D84315#BF360C#FF9E80#FF6E40#FF3D00#DD2C00",
        brown       = "#EFEBE9#D7CCC8#BCAAA4#A1887F#8D6E63#795548#6D4C41#5D4037#4E342E#3E2723",
        grey        = "#FAFAFA#F5F5F5#EEEEEE#E0E0E0#BDBDBD#9E9E9E#757575#616161#424242#212121",
        bluegrey    = "#ECEFF1#CFD8DC#B0BEC5#90A4AE#78909C#607D8B#546E7A#455A64#37474F#263238";
    /*\
     * Snap.mui
     [ property ]
     **
     * Contain Material UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.mui.deeppurple, stroke: Snap.mui.amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.mui = {};
    /*\
     * Snap.flat
     [ property ]
     **
     * Contain Flat UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.flat.carrot, stroke: Snap.flat.wetasphalt});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.flat = {};
    function saveColor(colors) {
        colors = colors.split(/(?=#)/);
        var color = new String(colors[5]);
        color[50] = colors[0];
        color[100] = colors[1];
        color[200] = colors[2];
        color[300] = colors[3];
        color[400] = colors[4];
        color[500] = colors[5];
        color[600] = colors[6];
        color[700] = colors[7];
        color[800] = colors[8];
        color[900] = colors[9];
        if (colors[10]) {
            color.A100 = colors[10];
            color.A200 = colors[11];
            color.A400 = colors[12];
            color.A700 = colors[13];
        }
        return color;
    }
    Snap.mui.red = saveColor(red);
    Snap.mui.pink = saveColor(pink);
    Snap.mui.purple = saveColor(purple);
    Snap.mui.deeppurple = saveColor(deeppurple);
    Snap.mui.indigo = saveColor(indigo);
    Snap.mui.blue = saveColor(blue);
    Snap.mui.lightblue = saveColor(lightblue);
    Snap.mui.cyan = saveColor(cyan);
    Snap.mui.teal = saveColor(teal);
    Snap.mui.green = saveColor(green);
    Snap.mui.lightgreen = saveColor(lightgreen);
    Snap.mui.lime = saveColor(lime);
    Snap.mui.yellow = saveColor(yellow);
    Snap.mui.amber = saveColor(amber);
    Snap.mui.orange = saveColor(orange);
    Snap.mui.deeporange = saveColor(deeporange);
    Snap.mui.brown = saveColor(brown);
    Snap.mui.grey = saveColor(grey);
    Snap.mui.bluegrey = saveColor(bluegrey);
    Snap.flat.turquoise = "#1abc9c";
    Snap.flat.greensea = "#16a085";
    Snap.flat.sunflower = "#f1c40f";
    Snap.flat.orange = "#f39c12";
    Snap.flat.emerland = "#2ecc71";
    Snap.flat.nephritis = "#27ae60";
    Snap.flat.carrot = "#e67e22";
    Snap.flat.pumpkin = "#d35400";
    Snap.flat.peterriver = "#3498db";
    Snap.flat.belizehole = "#2980b9";
    Snap.flat.alizarin = "#e74c3c";
    Snap.flat.pomegranate = "#c0392b";
    Snap.flat.amethyst = "#9b59b6";
    Snap.flat.wisteria = "#8e44ad";
    Snap.flat.clouds = "#ecf0f1";
    Snap.flat.silver = "#bdc3c7";
    Snap.flat.wetasphalt = "#34495e";
    Snap.flat.midnightblue = "#2c3e50";
    Snap.flat.concrete = "#95a5a6";
    Snap.flat.asbestos = "#7f8c8d";
    /*\
     * Snap.importMUIColors
     [ method ]
     **
     * Imports Material UI colours into global object.
     | Snap.importMUIColors();
     | Snap().rect(0, 0, 10, 10).attr({fill: deeppurple, stroke: amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.importMUIColors = function () {
        for (var color in Snap.mui) {
            if (Snap.mui.hasOwnProperty(color)) {
                window[color] = Snap.mui[color];
            }
        }
    };
});

module.exports = Snap


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./src/canvastools/css/canvastools.css":
/*!*********************************************!*\
  !*** ./src/canvastools/css/canvastools.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader!./canvastools.css */ "./node_modules/css-loader/index.js!./src/canvastools/css/canvastools.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/CanvasTools.Editor.ts":
/*!**************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/CanvasTools.Editor.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CanvasTools_Filter_1 = __webpack_require__(/*! ./CanvasTools.Filter */ "./src/canvastools/ts/CanvasTools/CanvasTools.Filter.ts");
const Rect_1 = __webpack_require__(/*! ./Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const ISelectorSettings_1 = __webpack_require__(/*! ./Interface/ISelectorSettings */ "./src/canvastools/ts/CanvasTools/Interface/ISelectorSettings.ts");
const RegionsManager_1 = __webpack_require__(/*! ./Region/RegionsManager */ "./src/canvastools/ts/CanvasTools/Region/RegionsManager.ts");
const AreaSelector_1 = __webpack_require__(/*! ./Selection/AreaSelector */ "./src/canvastools/ts/CanvasTools/Selection/AreaSelector.ts");
const ToolbarIcon_1 = __webpack_require__(/*! ./Toolbar/ToolbarIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts");
const Toolbar_1 = __webpack_require__(/*! ./Toolbar/Toolbar */ "./src/canvastools/ts/CanvasTools/Toolbar/Toolbar.ts");
/**
 * Wraps internal CanvasTools components into one Editor experience.
 */
class Editor {
    constructor(container, areaSelector, regionsManager, filterPipeline) {
        /**
         * Auto-resize flag to automatically update editor internals when the container (window) size is changed.
         */
        this.autoResize = true;
        /**
         * Internal reference to the RegionsManager freezing state.
         */
        this.isRMFrozen = false;
        // Create SVG Element
        this.contentCanvas = this.createCanvasElement();
        this.editorSVG = this.createSVGElement();
        this.editorDiv = container;
        this.editorDiv.classList.add("CanvasToolsEditor");
        this.editorDiv.append(this.contentCanvas);
        this.editorDiv.append(this.editorSVG);
        // automatically resize internals on window resize
        window.addEventListener("resize", (e) => {
            if (this.autoResize) {
                this.resize(this.editorDiv.offsetWidth, this.editorDiv.offsetHeight);
            }
        });
        // Init regionsManager
        const rmCallbacks = {
            onChange: null,
            onManipulationBegin: (region) => {
                this.areaSelector.hide();
                if (typeof this.onManipulationBegin === "function") {
                    this.onManipulationBegin(region);
                }
            },
            onManipulationEnd: (region) => {
                this.areaSelector.show();
                if (typeof this.onManipulationEnd === "function") {
                    this.onManipulationEnd(region);
                }
            },
            onRegionSelected: (id, multiselection) => {
                if (typeof this.onRegionSelected === "function") {
                    this.onRegionSelected(id, multiselection);
                }
            },
            onRegionMove: (id, regionData) => {
                if (typeof this.onRegionMove === "function") {
                    this.onRegionMove(id, regionData);
                }
            },
            onRegionMoveBegin: (id, regionData) => {
                if (typeof this.onRegionMoveBegin === "function") {
                    this.onRegionMoveBegin(id, regionData);
                }
            },
            onRegionMoveEnd: (id, regionData) => {
                if (typeof this.onRegionMoveEnd === "function") {
                    this.onRegionMoveEnd(id, regionData);
                }
            },
            onRegionDelete: (id, regionData) => {
                if (typeof this.onRegionDelete === "function") {
                    this.onRegionDelete(id, regionData);
                }
            },
        };
        if (regionsManager !== null && regionsManager !== undefined) {
            this.regionsManager = regionsManager;
            regionsManager.callbacks = rmCallbacks;
        }
        else {
            this.regionsManager = new RegionsManager_1.RegionsManager(this.editorSVG, rmCallbacks);
        }
        // Init areaSeletor
        const asCallbacks = {
            onSelectionBegin: () => {
                this.isRMFrozen = this.regionsManager.isFrozen;
                this.regionsManager.freeze();
                if (typeof this.onSelectionBegin === "function") {
                    this.onSelectionBegin();
                }
            },
            onSelectionEnd: (regionData) => {
                if (!this.isRMFrozen) {
                    this.regionsManager.unfreeze();
                }
                if (typeof this.onSelectionEnd === "function") {
                    this.onSelectionEnd(regionData);
                }
            },
        };
        if (areaSelector !== null && areaSelector !== undefined) {
            this.areaSelector = areaSelector;
            this.areaSelector.callbacks = asCallbacks;
        }
        else {
            this.areaSelector = new AreaSelector_1.AreaSelector(this.editorSVG, asCallbacks);
        }
        // Init filterPipeline
        if (filterPipeline !== undefined && filterPipeline !== null) {
            this.filterPipeline = filterPipeline;
        }
        else {
            this.filterPipeline = new CanvasTools_Filter_1.FilterPipeline();
        }
        // Adjust editor size
        this.resize(container.offsetWidth, container.offsetHeight);
        // Add proxy to regionsManager, areaSelector and filterPipeline;
        this.mergedAPI = new Proxy(this, {
            get: (target, prop) => {
                let p;
                let t;
                if (prop in target) {
                    t = target;
                    p = t[prop];
                }
                else if (prop in target.regionsManager) {
                    t = target.RM;
                    p = t[prop];
                }
                else if (prop in target.areaSelector) {
                    t = target.AS;
                    p = t[prop];
                }
                else if (prop in target.filterPipeline) {
                    t = target.FP;
                    p = t[prop];
                }
                else {
                    p = undefined;
                }
                if (typeof p === "function") {
                    return (...args) => {
                        p.apply(t, args);
                    };
                }
                else {
                    return p;
                }
            },
        });
    }
    /**
     * A proxi wrapper around internal API for the `Editor` itself, `RegionsManager` (`RM`), `AreaSelector` (`AS`) and
     * `FilterPipeline` (`FP`).
     * @remarks As of now those apis do not overlap, so all methods/properties might be mapped from unified API.
     */
    get api() {
        return this.mergedAPI;
    }
    /**
     * Creates a new toolbar in specified div-container
     * @param container - The div-container for the toolbar.
     * @param toolbarSet - Icons set for the toolbar.
     * @param iconsPath - Path to the toolbar icons.
     */
    addToolbar(container, toolbarSet, iconsPath) {
        const svg = this.createSVGElement();
        container.append(svg);
        this.toolbar = new Toolbar_1.Toolbar(svg);
        if (toolbarSet === null || toolbarSet === undefined) {
            toolbarSet = Editor.FullToolbarSet;
        }
        let activeSelector;
        toolbarSet.forEach((item) => {
            if (item.type === ToolbarIcon_1.ToolbarItemType.SEPARATOR) {
                this.toolbar.addSeparator();
            }
            else {
                const toolbarItem = {
                    action: item.action,
                    iconUrl: iconsPath + item.iconFile,
                    tooltip: item.tooltip,
                    keycode: item.keycode,
                    width: item.width,
                    height: item.height,
                };
                const actionFn = (action) => {
                    item.actionCallback(action, this.regionsManager, this.areaSelector);
                };
                if (item.type === ToolbarIcon_1.ToolbarItemType.SELECTOR) {
                    this.toolbar.addSelector(toolbarItem, actionFn);
                    if (item.activate) {
                        activeSelector = item.action;
                    }
                }
                else if (item.type === ToolbarIcon_1.ToolbarItemType.SWITCH) {
                    this.toolbar.addSwitch(toolbarItem, actionFn);
                    this.toolbar.setSwitch(item.action, item.activate);
                }
                else if (item.type === ToolbarIcon_1.ToolbarItemType.TRIGGER) {
                    this.toolbar.addTrigger(toolbarItem, actionFn);
                }
            }
        });
        this.toolbar.select(activeSelector);
    }
    /**
     * Updates the content source for the editor.
     * @param source - Content source.
     * @returns A new `Promise` resolved when content is drawn and Editor is resized.
     */
    async addContentSource(source) {
        const buffCnvs = document.createElement("canvas");
        const context = buffCnvs.getContext("2d");
        if (source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {
            this.sourceWidth = source.width;
            this.sourceHeight = source.height;
        }
        else if (source instanceof HTMLVideoElement) {
            this.sourceWidth = source.videoWidth;
            this.sourceHeight = source.videoHeight;
        }
        buffCnvs.width = this.sourceWidth;
        buffCnvs.height = this.sourceHeight;
        context.drawImage(source, 0, 0, buffCnvs.width, buffCnvs.height);
        return this.filterPipeline.applyToCanvas(buffCnvs).then((bcnvs) => {
            // Copy buffer to the canvas on screen
            this.contentCanvas.width = bcnvs.width;
            this.contentCanvas.height = bcnvs.height;
            const imgContext = this.contentCanvas.getContext("2d");
            imgContext.drawImage(bcnvs, 0, 0, bcnvs.width, bcnvs.height);
        }).then(() => {
            // resize the editor size to adjust to the new content size
            this.resize(this.editorDiv.offsetWidth, this.editorDiv.offsetHeight);
        });
    }
    /**
     * Resize editor to new width and height.
     * @remarks - Use if the `autoResize` is `false`.
     * @param containerWidth - The new container width.
     * @param containerHeight - The new container height.
     */
    resize(containerWidth, containerHeight) {
        this.frameWidth = containerWidth;
        this.frameHeight = containerHeight;
        const imgRatio = this.contentCanvas.width / this.contentCanvas.height;
        const containerRatio = containerWidth / containerHeight;
        let hpadding = 0;
        let vpadding = 0;
        if (imgRatio > containerRatio) {
            vpadding = (containerHeight - containerWidth / imgRatio) / 2;
            this.editorDiv.style.height = `calc(100% - ${vpadding * 2}px)`;
            this.editorDiv.style.width = "";
        }
        else {
            hpadding = (containerWidth - containerHeight * imgRatio) / 2;
            this.editorDiv.style.height = "";
            this.editorDiv.style.width = `calc(100% - ${hpadding * 2}px)`;
        }
        this.editorDiv.style.padding = `${vpadding}px ${hpadding}px`;
        this.frameWidth = this.editorSVG.clientWidth;
        this.frameHeight = this.editorSVG.clientHeight;
        this.areaSelector.resize(this.frameWidth, this.frameHeight);
        this.regionsManager.resize(this.frameWidth, this.frameHeight);
    }
    /**
     * Short reference to the `RegionsManager` component.
     */
    get RM() {
        return this.regionsManager;
    }
    /**
     * Short reference to the `AreaSelector` component.
     */
    get AS() {
        return this.areaSelector;
    }
    /**
     * Short reference to the `FilterPipeline` component.
     */
    get FP() {
        return this.filterPipeline;
    }
    /**
     * Scales the `RegionData` object from frame to source size.
     * @param regionData - The `RegionData` object.
     * @param sourceWidth - [Optional] The source width.
     * @param sourceHeight - [Optional] The source height.
     * @returns Resized `RegionData` object.
     */
    scaleRegionToSourceSize(regionData, sourceWidth, sourceHeight) {
        const sw = (sourceWidth !== undefined) ? sourceWidth : this.sourceWidth;
        const sh = (sourceHeight !== undefined) ? sourceHeight : this.sourceHeight;
        const xf = sw / this.frameWidth;
        const yf = sh / this.frameHeight;
        const rd = regionData.copy();
        rd.scale(xf, yf);
        return rd;
    }
    /**
     * Scales the `RegionData` object from source to frame size.
     * @param regionData - The `RegionData` object.
     * @param sourceWidth - [Optional] The source width.
     * @param sourceHeight - [Optional] The source height.
     * @returns Resized `RegionData` object.
     */
    scaleRegionToFrameSize(regionData, sourceWidth, sourceHeight) {
        const sw = (sourceWidth !== undefined) ? sourceWidth : this.sourceWidth;
        const sh = (sourceHeight !== undefined) ? sourceHeight : this.sourceHeight;
        const xf = this.frameWidth / sw;
        const yf = this.frameHeight / sh;
        const rd = regionData.copy();
        rd.scale(xf, yf);
        return rd;
    }
    /**
     * Internal helper to create a new SVG element.
     */
    createSVGElement() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.innerHTML = Editor.SVGDefsTemplate;
        return svg;
    }
    /**
     * Internal helper to create a new HTMLCanvas element.
     */
    createCanvasElement() {
        const canvas = document.createElement("canvas");
        return canvas;
    }
}
/**
 * The toolbar icons preset with all available features.
 */
Editor.FullToolbarSet = [
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "none-select",
        iconFile: "none-selection.svg",
        tooltip: "Regions Manipulation (M)",
        keycode: "KeyM",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.NONE });
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "point-select",
        iconFile: "point-selection.svg",
        tooltip: "Point-selection (P)",
        keycode: "KeyP",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.POINT });
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "rect-select",
        iconFile: "rect-selection.svg",
        tooltip: "Rectangular box (R)",
        keycode: "KeyR",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.RECT });
        },
        activate: true,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "copy-select",
        iconFile: "copy-t-selection.svg",
        tooltip: "Template-based box (T)",
        keycode: "KeyT",
        actionCallback: (action, rm, sl) => {
            const regions = rm.getSelectedRegions();
            if (regions !== undefined && regions.length > 0) {
                const r = regions[0];
                sl.setSelectionMode({
                    mode: ISelectorSettings_1.SelectionMode.COPYRECT,
                    template: new Rect_1.Rect(r.regionData.width, r.regionData.height),
                });
            }
            else {
                sl.setSelectionMode({
                    mode: ISelectorSettings_1.SelectionMode.COPYRECT,
                    template: new Rect_1.Rect(40, 40),
                });
            }
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "polyline-select",
        iconFile: "polyline-selection.svg",
        tooltip: "Polyline-selection (Y)",
        keycode: "KeyY",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.POLYLINE });
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "polygon-select",
        iconFile: "polygon-selection.svg",
        tooltip: "Polygon-selection (O)",
        keycode: "KeyO",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.POLYGON });
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.TRIGGER,
        action: "delete-all-select",
        iconFile: "delete-all-selection.svg",
        tooltip: "Delete all regions",
        keycode: "",
        actionCallback: (action, rm, sl) => {
            rm.deleteAllRegions();
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: "selection-lock",
        iconFile: "selection-lock.svg",
        tooltip: "Lock/unlock regions (L)",
        keycode: "KeyL",
        actionCallback: (action, rm, sl) => {
            rm.toggleFreezeMode();
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: "background-toggle",
        iconFile: "background-toggle.svg",
        tooltip: "Toggle Region Background (B)",
        keycode: "KeyB",
        actionCallback: (action, rm, sl) => {
            rm.toggleBackground();
        },
        activate: false,
    },
];
/**
 * The toolbar icons preset with only rect-related features.
 */
Editor.RectToolbarSet = [
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "none-select",
        iconFile: "none-selection.svg",
        tooltip: "Regions Manipulation (M)",
        keycode: "KeyM",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.NONE });
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "rect-select",
        iconFile: "rect-selection.svg",
        tooltip: "Rectangular box (R)",
        keycode: "KeyR",
        actionCallback: (action, rm, sl) => {
            sl.setSelectionMode({ mode: ISelectorSettings_1.SelectionMode.RECT });
        },
        activate: true,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SELECTOR,
        action: "copy-select",
        iconFile: "copy-t-selection.svg",
        tooltip: "Template-based box (T)",
        keycode: "KeyT",
        actionCallback: (action, rm, sl) => {
            const regions = rm.getSelectedRegions();
            if (regions !== undefined && regions.length > 0) {
                const r = regions[0];
                sl.setSelectionMode({
                    mode: ISelectorSettings_1.SelectionMode.COPYRECT,
                    template: new Rect_1.Rect(r.regionData.width, r.regionData.height),
                });
            }
            else {
                sl.setSelectionMode({
                    mode: ISelectorSettings_1.SelectionMode.COPYRECT,
                    template: new Rect_1.Rect(40, 40),
                });
            }
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.TRIGGER,
        action: "delete-all-select",
        iconFile: "delete-all-selection.svg",
        tooltip: "Delete all regions",
        keycode: "",
        actionCallback: (action, rm, sl) => {
            rm.deleteAllRegions();
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SEPARATOR,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: "selection-lock",
        iconFile: "selection-lock.svg",
        tooltip: "Lock/unlock regions (L)",
        keycode: "KeyL",
        actionCallback: (action, rm, sl) => {
            rm.toggleFreezeMode();
        },
        activate: false,
    },
    {
        type: ToolbarIcon_1.ToolbarItemType.SWITCH,
        action: "background-toggle",
        iconFile: "background-toggle.svg",
        tooltip: "Toggle Region Background (B)",
        keycode: "KeyB",
        actionCallback: (action, rm, sl) => {
            rm.toggleBackground();
        },
        activate: false,
    },
];
/**
 * Internal SVG template to define shadow filter.
 */
Editor.SVGDefsTemplate = `
        <defs>
            <filter id="black-glow">
                <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
                <feOffset dx="0" dy="0" result="offsetblur" />
                <feComponentTransfer>
                    <feFuncA type="linear" slope="0.8" />
                </feComponentTransfer>
                <feMerge>
                    <feMergeNode />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
        </defs>`;
exports.Editor = Editor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/CanvasTools.Filter.ts":
/*!**************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/CanvasTools.Filter.ts ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Invertion filter.
 * @param canvas - Source HTMLCanvas element.
 */
function InvertFilter(canvas) {
    const context = canvas.getContext("2d");
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    const buff = document.createElement("canvas");
    buff.width = canvas.width;
    buff.height = canvas.height;
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
        data[i] = 255 - data[i]; // red
        data[i + 1] = 255 - data[i + 1]; // green
        data[i + 2] = 255 - data[i + 2]; // blue
    }
    buff.getContext("2d").putImageData(imageData, 0, 0);
    return new Promise((resolve, reject) => {
        return resolve(buff);
    });
}
exports.InvertFilter = InvertFilter;
/**
 * Grayscale filter.
 * @param canvas - Source HTMLCanvas element.
 */
function GrayscaleFilter(canvas) {
    const context = canvas.getContext("2d");
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    const buff = document.createElement("canvas");
    buff.width = canvas.width;
    buff.height = canvas.height;
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
        const gray = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
        data[i] = gray; // red
        data[i + 1] = gray; // green
        data[i + 2] = gray; // blue
    }
    buff.getContext("2d").putImageData(imageData, 0, 0);
    return new Promise((resolve, reject) => {
        return resolve(buff);
    });
}
exports.GrayscaleFilter = GrayscaleFilter;
/**
 * Experimental blur difference filter.
 * @param factor - Bluring factor (in pixels).
 */
function BlurDiffFilter(factor) {
    // http://blog.ivank.net/fastest-gaussian-blur.html
    function boxesForGauss(sigma, n) {
        const wIdeal = Math.sqrt((12 * sigma * sigma / n) + 1); // Ideal averaging filter width
        let wl = Math.floor(wIdeal);
        if (wl % 2 === 0) {
            wl--;
        }
        const wu = wl + 2;
        const mIdeal = (12 * sigma * sigma - n * wl * wl - 4 * n * wl - 3 * n) / (-4 * wl - 4);
        const m = Math.round(mIdeal);
        // var sigmaActual = Math.sqrt( (m*wl*wl + (n-m)*wu*wu - n)/12 );
        const sizes = [];
        for (let i = 0; i < n; i++) {
            sizes.push(i < m ? wl : wu);
        }
        return sizes;
    }
    function gaussBlur_4(scl, tcl, w, h, r) {
        const bxs = boxesForGauss(r, 3);
        boxBlur_4(scl, tcl, w, h, (bxs[0] - 1) / 2);
        boxBlur_4(tcl, scl, w, h, (bxs[1] - 1) / 2);
        boxBlur_4(scl, tcl, w, h, (bxs[2] - 1) / 2);
    }
    function boxBlur_4(scl, tcl, w, h, r) {
        for (let i = 0; i < scl.length; i++) {
            tcl[i] = scl[i];
        }
        boxBlurH_4(tcl, scl, w, h, r);
        boxBlurT_4(scl, tcl, w, h, r);
    }
    function boxBlurH_4(scl, tcl, w, h, r) {
        const iarr = 1 / (r + r + 1);
        for (let i = 0; i < h; i++) {
            let ti = i * w;
            let li = ti;
            let ri = ti + r;
            const fv = scl[ti];
            const lv = scl[ti + w - 1];
            let val = (r + 1) * fv;
            for (let j = 0; j < r; j++) {
                val += scl[ti + j];
            }
            for (let j = 0; j <= r; j++) {
                val += scl[ri++] - fv;
                tcl[ti++] = Math.round(val * iarr);
            }
            for (let j = r + 1; j < w - r; j++) {
                val += scl[ri++] - scl[li++];
                tcl[ti++] = Math.round(val * iarr);
            }
            for (let j = w - r; j < w; j++) {
                val += lv - scl[li++];
                tcl[ti++] = Math.round(val * iarr);
            }
        }
    }
    function boxBlurT_4(scl, tcl, w, h, r) {
        const iarr = 1 / (r + r + 1);
        for (let i = 0; i < w; i++) {
            let ti = i;
            let li = ti;
            let ri = ti + r * w;
            const fv = scl[ti];
            const lv = scl[ti + w * (h - 1)];
            let val = (r + 1) * fv;
            for (let j = 0; j < r; j++) {
                val += scl[ti + j * w];
            }
            for (let j = 0; j <= r; j++) {
                val += scl[ri] - fv;
                tcl[ti] = Math.round(val * iarr);
                ri += w;
                ti += w;
            }
            for (let j = r + 1; j < h - r; j++) {
                val += scl[ri] - scl[li];
                tcl[ti] = Math.round(val * iarr);
                li += w;
                ri += w;
                ti += w;
            }
            for (let j = h - r; j < h; j++) {
                val += lv - scl[li];
                tcl[ti] = Math.round(val * iarr);
                li += w;
                ti += w;
            }
        }
    }
    return (canvas) => {
        const context = canvas.getContext("2d");
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement("canvas");
        buff.width = canvas.width;
        buff.height = canvas.height;
        const bludData = buff.getContext("2d").createImageData(buff.width, buff.height);
        const idata = imageData.data;
        const bdata = bludData.data;
        const pixelsNumber = canvas.width * canvas.height;
        const dataR = new Uint8ClampedArray(pixelsNumber);
        const dataG = new Uint8ClampedArray(pixelsNumber);
        const dataB = new Uint8ClampedArray(pixelsNumber);
        const dataA = new Uint8ClampedArray(pixelsNumber);
        for (let i = 0; i < pixelsNumber; i++) {
            dataR[i] = idata[4 * i];
            dataG[i] = idata[4 * i + 1];
            dataB[i] = idata[4 * i + 2];
            dataA[i] = idata[4 * i + 3];
        }
        const blurR = new Uint8ClampedArray(pixelsNumber);
        const blurG = new Uint8ClampedArray(pixelsNumber);
        const blurB = new Uint8ClampedArray(pixelsNumber);
        const blurR2 = new Uint8ClampedArray(pixelsNumber);
        const blurG2 = new Uint8ClampedArray(pixelsNumber);
        const blurB2 = new Uint8ClampedArray(pixelsNumber);
        // let blurA = new Uint8ClampedArray(pixelsNumber);
        const halfFactor = factor / 2;
        gaussBlur_4(dataR, blurR, buff.width, buff.height, halfFactor);
        gaussBlur_4(dataG, blurG, buff.width, buff.height, halfFactor);
        gaussBlur_4(dataB, blurB, buff.width, buff.height, halfFactor);
        gaussBlur_4(dataR, blurR2, buff.width, buff.height, factor);
        gaussBlur_4(dataG, blurG2, buff.width, buff.height, factor);
        gaussBlur_4(dataB, blurB2, buff.width, buff.height, factor);
        const alphaStep = 127 / factor;
        for (let i = 0; i < pixelsNumber; i++) {
            const dr = Math.abs(blurR2[i] - blurR[i]);
            const dg = Math.abs(blurG2[i] - blurG[i]);
            const db = Math.abs(blurB2[i] - blurB[i]);
            // const d = 0.2126 * dr + 0.7152 * dg + 0.0722 * db;
            const d = 0.2358 * dr + 0.0700 * dg + 0.6742 * db;
            /* let dr = Math.abs(blurR2[i] - idata[4 * i + 0]);
            let dg = Math.abs(blurG2[i] - idata[4 * i + 1]);
            let db = Math.abs(blurB2[i] - idata[4 * i + 2]); */
            // let d = 255 - Math.min(Math.round(Math.max(dr + dg + db - 16, 0)/8) * 16, 255);
            /* bdata[4 * i + 0] = d;
            bdata[4 * i + 1] = d;
            bdata[4 * i + 2] = d; */
            /* bdata[4 * i + 0] = (d < factor) ? Math.round(idata[4 * i + 0] / factor) * factor : idata[4 * i + 0];
            bdata[4 * i + 1] = (d < factor) ? Math.round(idata[4 * i + 1] / factor) * factor : idata[4 * i + 1];
            bdata[4 * i + 2] = (d < factor) ? Math.round(idata[4 * i + 2] / factor) * factor : idata[4 * i + 2]; */
            /* bdata[4 * i + 0] = (dr >= 0.2126 * factor) ?
                                idata[4 * i + 0] :  Math.round(idata[4 * i + 0] / factor) * factor;
            bdata[4 * i + 1] = (dg >= 0.7152 * factor) ?
                                idata[4 * i + 1] :  Math.round(idata[4 * i + 1] / factor) * factor;
            bdata[4 * i + 2] = (db >= 0.0722 * factor) ?
                                idata[4 * i + 2] :  Math.round(idata[4 * i + 2] / factor) * factor; */
            const g = Math.round(0.2358 * idata[4 * i + 0] + 0.0700 * idata[4 * i + 1] + 0.6742 * idata[4 * i + 2]);
            bdata[4 * i + 0] = (dr >= 0.2358 * halfFactor) ?
                idata[4 * i + 0] : Math.round(g / factor) * factor;
            bdata[4 * i + 1] = (dg >= 0.0700 * halfFactor) ?
                idata[4 * i + 1] : Math.round(g / factor) * factor;
            bdata[4 * i + 2] = (db >= 0.6742 * halfFactor) ?
                idata[4 * i + 2] : Math.round(g / factor) * factor;
            /* bdata[4 * i + 0] = Math.round(idata[4 * i + 0] / 8) * 8;
            bdata[4 * i + 1] = Math.round(idata[4 * i + 1] / 8) * 8;
            bdata[4 * i + 2] = Math.round(idata[4 * i + 2] / 8) * 8; */
            bdata[4 * i + 3] = (d >= factor) ? 255 : 0 + Math.round(d * alphaStep);
        }
        buff.getContext("2d").putImageData(bludData, 0, 0);
        return new Promise((resolve, reject) => {
            return resolve(buff);
        });
    };
}
exports.BlurDiffFilter = BlurDiffFilter;
/**
 * Brightness filter.
 * @param brightness - The brightness value in the range [0, 255] to be added to pixels.
 */
function BrightnessFilter(brightness) {
    return (canvas) => {
        const context = canvas.getContext("2d");
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement("canvas");
        buff.width = canvas.width;
        buff.height = canvas.height;
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            data[i + 0] = Math.max(0, Math.min(data[i + 0] + brightness, 255));
            data[i + 1] = Math.max(0, Math.min(data[i + 1] + brightness, 255));
            data[i + 2] = Math.max(0, Math.min(data[i + 2] + brightness, 255));
        }
        buff.getContext("2d").putImageData(imageData, 0, 0);
        return new Promise((resolve, reject) => {
            return resolve(buff);
        });
    };
}
exports.BrightnessFilter = BrightnessFilter;
/**
 * Contrast filter.
 * @param contrast - The contrast factor in the range [-255, 255] to be applied to pixels.
 */
function ContrastFilter(contrast) {
    return (canvas) => {
        const context = canvas.getContext("2d");
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement("canvas");
        buff.width = canvas.width;
        buff.height = canvas.height;
        const data = imageData.data;
        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        for (let i = 0; i < data.length; i += 4) {
            data[i + 0] = factor * (data[i] - 128) + 128;
            data[i + 1] = factor * (data[i + 1] - 128) + 128;
            data[i + 2] = factor * (data[i + 2] - 128) + 128;
        }
        buff.getContext("2d").putImageData(imageData, 0, 0);
        return new Promise((resolve, reject) => {
            return resolve(buff);
        });
    };
}
exports.ContrastFilter = ContrastFilter;
/**
 * Saturation filter
 * @param saturation - The saturation factor in the range [0, 255] to be applied to pixels.
 */
function SaturationFilter(saturation) {
    return (canvas) => {
        const context = canvas.getContext("2d");
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const buff = document.createElement("canvas");
        buff.width = canvas.width;
        buff.height = canvas.height;
        const s = saturation / 255;
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i + 0];
            const g = data[i + 1];
            const b = data[i + 2];
            const gr = 0.213 * r + 0.715 * g + 0.072 * b;
            const nr = gr + s * (+0.787 * r - 0.715 * g - 0.072 * b);
            const ng = gr + s * (-0.213 * r + 0.285 * g - 0.072 * b);
            const nb = gr + s * (-0.213 * r - 0.715 * g + 0.928 * b);
            data[i] = Math.round(nr); // red
            data[i + 1] = Math.round(ng); // green
            data[i + 2] = Math.round(nb); // blue
        }
        buff.getContext("2d").putImageData(imageData, 0, 0);
        return new Promise((resolve, reject) => {
            return resolve(buff);
        });
    };
}
exports.SaturationFilter = SaturationFilter;
/*     convoluteFilter(canvas, weights, opaque) {
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = imageData.data;
        var sw = imageData.width;
        var sh = imageData.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var output = new ImageData(w, h);

        var dst = output.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy<side; cy++) {
                    for (var cx=0; cx<side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return output;
    } */
/**
 * The `FilterPipeline` class used to create a pipeline of canvas data transformations
 * before displaying it to the user.
 */
class FilterPipeline {
    /**
     * Creates new instance of the `FilterPipeline`.
     */
    constructor() {
        this.pipeline = new Array();
    }
    /**
     * Add new filter function to pipeline.
     * @param filter - A new filter function.
     */
    addFilter(filter) {
        this.pipeline.push(filter);
    }
    /**
     * Clear all the filters in pipeline.
     */
    clearFilters() {
        this.pipeline = new Array();
    }
    /**
     * Apply filters pipeline to provided source canvas.
     * @param canvas - The source HTML Canvas element.
     * @returns A new `Promise` resolved when all filters are applyed.
     */
    applyToCanvas(canvas) {
        let promise = new Promise((resolve, reject) => {
            return resolve(canvas);
        });
        if (this.pipeline.length > 0) {
            this.pipeline.forEach((filter) => {
                promise = promise.then(filter);
            });
        }
        return promise;
    }
}
exports.FilterPipeline = FilterPipeline;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/Color.ts":
/*!*************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/Color.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RGBColor_1 = __webpack_require__(/*! ./RGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/RGBColor.ts");
const SRGBColor_1 = __webpack_require__(/*! ./SRGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/SRGBColor.ts");
const XYZColor_1 = __webpack_require__(/*! ./XYZColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/XYZColor.ts");
const LABColor_1 = __webpack_require__(/*! ./LABColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts");
const HSLColor_1 = __webpack_require__(/*! ./HSLColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/HSLColor.ts");
/**
 * A wrapper `Color` class to represent various color formats
 * and manage conversions between them.
 * @remarks The current work on defining color management in web (including conversion algorithms)
 * can be tracked in this draft: https://drafts.csswg.org/css-color/
 */
class Color {
    get sRGB() {
        return this.srgbColor;
    }
    get RGB() {
        if (this.rgbColor === undefined) {
            this.rgbColor = this.srgbColor.toRGB();
        }
        return this.rgbColor;
    }
    get XYZ() {
        if (this.xyzColor === undefined) {
            this.xyzColor = this.RGB.toXYZ();
        }
        return this.xyzColor;
    }
    get LAB() {
        if (this.labColor === undefined) {
            this.labColor = this.XYZ.toLAB();
        }
        return this.labColor;
    }
    get HSL() {
        if (this.hslColor === undefined) {
            this.hslColor = this.srgbColor.toHSL();
        }
        return this.hslColor;
    }
    constructor(...args) {
        if (args.length === 1) {
            const c = args[0];
            if (c instanceof SRGBColor_1.SRGBColor) {
                this.srgbColor = c;
            }
            else if (c instanceof RGBColor_1.RGBColor) {
                this.rgbColor = c;
                this.srgbColor = c.toSRGB();
            }
            else if (c instanceof HSLColor_1.HSLColor) {
                this.hslColor = c;
                this.srgbColor = c.toSRGB();
            }
            else if (c instanceof XYZColor_1.XYZColor) {
                this.xyzColor = c;
                this.rgbColor = c.toRGB();
                this.srgbColor = this.rgbColor.toSRGB();
            }
            else if (c instanceof LABColor_1.LABColor) {
                this.labColor = c;
                this.xyzColor = c.toXYZ();
                this.rgbColor = this.xyzColor.toRGB();
                this.srgbColor = this.rgbColor.toSRGB();
            }
            else if (typeof c === "string") {
                this.srgbColor = SRGBColor_1.SRGBColor.ParseHex(c);
            }
            else {
                throw new Error("Wrong arg type. Expected one of the '***Color' types.");
            }
        }
        else if (args.length === 3) {
            if (typeof args[0] === "number" && typeof args[1] === "number" && typeof args[2] === "number") {
                this.srgbColor = new SRGBColor_1.SRGBColor(args[0], args[1], args[2]);
            }
            else {
                throw new Error("Wrong arg type. Expected 3 args of the 'number' type.");
            }
        }
        else {
            throw new Error("Wrong args for Color constructor.");
        }
    }
}
exports.Color = Color;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/HSLColor.ts":
/*!****************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/HSLColor.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SRGBColor_1 = __webpack_require__(/*! ./SRGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/SRGBColor.ts");
/**
 * Represents the HSL color space.
 */
class HSLColor {
    /**
     * The hue value of the color.
     */
    get h() {
        return this.values[0];
    }
    /**
     * The saturation value of the color.
     */
    get s() {
        return this.values[1];
    }
    /**
     * The lightness value of the color.
     */
    get l() {
        return this.values[2];
    }
    /**
     * Creates new HSLColor
     * @param h - Hue component in the range [0, 1].
     * @param s - Saturation component in the range [0, 1].
     * @param l - Lightness component in the range [0, 1].
     */
    constructor(h, s, l) {
        this.values = [h, s, l];
    }
    /**
     * Return a copy of color values in array format as [h, s, l].
     */
    toArray() {
        // copy
        return this.values.map((v) => v);
    }
    /**
     * Return an array of color values mapped to the ranges used in CSS:
     * hue - [0, 360]
     * saturation - [0, 100] %
     * lightness - [0, 100] %
     */
    toCSSValues() {
        return [this.h * 360, this.s * 100, this.l * 100];
    }
    /**
     * Composes the CSS color string using the hsl() or hsla() format.
     * @param alpha - The alpha value for hsla() format.
     */
    toCSSString(alpha) {
        const [h, s, l] = this.toCSSValues();
        if (alpha !== undefined) {
            // cast to [0, 1]
            alpha = Math.min(1, Math.max(0, alpha));
            return `hsla(${h}, ${s}%, ${l}%, ${alpha})`;
        }
        else {
            return `hsl(${h}, ${s}%, ${l}%)`;
        }
    }
    /**
     * Trasforms color to the RGB format.
     */
    toSRGB() {
        /* https://www.w3.org/TR/css-color-3/
        HOW TO RETURN hsl.to.rgb(h, s, l):
            SELECT:
                l<=0.5: PUT l*(s+1) IN m2
                ELSE: PUT l+s-l*s IN m2
            PUT l*2-m2 IN m1
            PUT hue.to.rgb(m1, m2, h+1/3) IN r
            PUT hue.to.rgb(m1, m2, h    ) IN g
            PUT hue.to.rgb(m1, m2, h-1/3) IN b
            RETURN (r, g, b)
        */
        let m1;
        let m2;
        const [h, s, l] = this.values;
        if (l <= 0.5) {
            m2 = l * (s + 1);
        }
        else {
            m2 = l + s - l * s;
        }
        m1 = l * 2 - m2;
        const r = this.hue2rgb(m1, m2, h + 1 / 3);
        const g = this.hue2rgb(m1, m2, h);
        const b = this.hue2rgb(m1, m2, h - 1 / 3);
        return new SRGBColor_1.SRGBColor(r, g, b);
    }
    /**
     * Internal helper function for the `toRGB` method.
     */
    hue2rgb(m1, m2, h) {
        /* https://www.w3.org/TR/css-color-3/
        HOW TO RETURN hue.to.rgb(m1, m2, h):
            IF h<0: PUT h+1 IN h
            IF h>1: PUT h-1 IN h
            IF h*6<1: RETURN m1+(m2-m1)*h*6
            IF h*2<1: RETURN m2
            IF h*3<2: RETURN m1+(m2-m1)*(2/3-h)*6
            RETURN m1
       */
        if (h < 0) {
            h = h + 1;
        }
        if (h > 1) {
            h = h - 1;
        }
        if (h * 6 < 1) {
            return m1 + (m2 - m1) * h * 6;
        }
        else if (h * 2 < 1) {
            return m2;
        }
        else if (h * 3 < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        else {
            return m1;
        }
    }
}
exports.HSLColor = HSLColor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts":
/*!****************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const XYZColor_1 = __webpack_require__(/*! ./XYZColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/XYZColor.ts");
/**
 * Represents the CIE LAB color space.
 */
class LABColor {
    /**
     * The lightness value of the color.
     */
    get l() {
        return this.values[0];
    }
    /**
     * The a-component of the color (green to red).
     */
    get a() {
        return this.values[1];
    }
    /**
     * The b-component of the color (blue to yellow).
     */
    get b() {
        return this.values[2];
    }
    /**
     * Creates new CIE LAB color.
     * @param l - Lightness component in the range [0, 1].
     * @param a - A-component in the range [0, 1].
     * @param b - B-component in the range [0, 1].
     */
    constructor(l, a, b) {
        this.values = [l, a, b];
    }
    /**
     * Computes color difference using the CIE94 formula as defined here:
     * https://en.wikipedia.org/wiki/Color_difference.
     * @remarks It is better to use the CIE DE2000 formula, but it requires significantly more computations.
     * E.g., check this reveiw: http://www.color.org/events/colorimetry/Melgosa_CIEDE2000_Workshop-July4.pdf.
     * @param color - A color to compare.
     * @returns The distance between this and provided colors.
     */
    distanceTo(color) {
        const deltaL = this.values[0] - color.values[0];
        const deltaA = this.values[1] - color.values[1];
        const deltaB = this.values[2] - color.values[2];
        const c1 = Math.sqrt(this.values[1] * this.values[1] + this.values[2] * this.values[2]);
        const c2 = Math.sqrt(color.values[1] * color.values[1] + color.values[2] * color.values[2]);
        const deltaC = c1 - c2;
        let deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC;
        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
        const sc = 1.0 + 0.045 * c1;
        const sh = 1.0 + 0.015 * c1;
        const deltaLKlsl = deltaL / (1.0);
        const deltaCkcsc = deltaC / (sc);
        const deltaHkhsh = deltaH / (sh);
        const i = deltaLKlsl * deltaLKlsl + deltaCkcsc * deltaCkcsc + deltaHkhsh * deltaHkhsh;
        return i < 0 ? 0 : Math.sqrt(i);
    }
    distanceTo_00(color) {
        const [L1, a1, b1] = this.values;
        const [L2, a2, b2] = color.values;
        const kL = 1.0;
        const kC = 1.0;
        const kH = 1.0;
        const K1 = 0.045;
        const K2 = 0.015;
        const deg2rad = Math.PI / 180.0;
        const rad2deg = 180.0 / Math.PI;
        const deltaL = L2 - L1;
        const midL = (L1 + L2) / 2;
        const C1 = Math.sqrt(a1 * a1 + b1 * b1);
        const C2 = Math.sqrt(a2 * a2 + b2 * b2);
        const midC = (C1 + C2) / 2;
        const midC7 = midC ** 7;
        const midC7Root = Math.sqrt(midC7 / (midC7 + 25 ** 7));
        const a1t = a1 + 0.5 * a1 * (1 - midC7Root);
        const a2t = a2 + 0.5 * a2 * (1 - midC7Root);
        const C1t = Math.sqrt(a1t * a1t + b1 * b1);
        const C2t = Math.sqrt(a2t * a2t + b2 * b2);
        const midCt = (C1t + C2t) / 2;
        const deltaCt = C2t - C1t;
        const h1 = (b1 === 0 && a1t === 0) ? 0 : (Math.atan2(b1, a1t) * rad2deg) % 360;
        const h2 = (b2 === 0 && a2t === 0) ? 0 : (Math.atan2(b2, a2t) * rad2deg) % 360;
        let deltah = h2 - h1;
        const absDeltah = Math.abs(deltah);
        if (h2 <= h1 && absDeltah > 180) {
            deltah += 360;
        }
        if (h2 > h1 && absDeltah > 180) {
            deltah -= 360;
        }
        const deltaH = 2 * Math.sqrt(C1t * C2t) * Math.sin(0.5 * deltah * deg2rad);
        let H = (h1 + h2) / 2;
        if (absDeltah > 180 && h1 + h2 < 360) {
            H += 180;
        }
        if (absDeltah > 180 && h1 + h2 >= 360) {
            H -= 180;
        }
        const T = 1 - 0.17 * Math.cos((H - 30) * deg2rad)
            + 0.24 * Math.cos((2 * H) * deg2rad)
            + 0.32 * Math.cos((3 * H + 6) * deg2rad)
            - 0.20 * Math.cos((4 * H - 63) * deg2rad);
        const SL = 1 + (K2 * (midL - 50)) / (Math.sqrt(20 + (midL - 50) * (midL - 50)));
        const SC = 1 + K1 * midCt;
        const SH = 1 + K2 * midCt * T;
        const RT = -2 * midC7Root * Math.sin((60 * Math.exp(-((H - 275) / 25) * ((H - 275) / 25))) * deg2rad);
        const diff = Math.sqrt((deltaL / (kL * SL)) ** 2
            + (deltaCt / (kC * SC)) ** 2
            + (deltaH / (kH * SH)) ** 2
            + RT * (deltaCt / (kC * SC)) * (deltaH / (kH * SH)));
        return diff;
    }
    /**
     * Computes the distance to a=b=0 in the AB-subspace.
     */
    distanceToGray() {
        return Math.sqrt(this.a * this.a + this.b * this.b);
    }
    /**
     * Return a copy of color values in array format as [l, a, b].
     */
    toArray() {
        // copy
        return this.values.map((v) => v);
    }
    /**
     * Trasforms color to the XYZ format.
     */
    toXYZ() {
        let y = (this.l * 100 + 16) / 116;
        let x = this.a / 5 + y;
        let z = y - this.b / 2;
        [x, y, z] = [x, y, z].map((v) => {
            const v3 = v * v * v;
            return (v3 > 0.008856451) ? v3 : (v - 16 / 116) / 7.787037;
        });
        return new XYZColor_1.XYZColor(x * XYZColor_1.XYZColor.D65.x, y * XYZColor_1.XYZColor.D65.y, z * XYZColor_1.XYZColor.D65.z);
    }
    /**
     * Trasforms color to the RGB format.
     */
    toRGB() {
        return this.toXYZ().toRGB();
    }
    /**
     * Trasforms color to the sRGB format.
     */
    toSRGB() {
        return this.toXYZ().toRGB().toSRGB();
    }
}
exports.LABColor = LABColor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/Palette.ts":
/*!***************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/Palette.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const LABColor_1 = __webpack_require__(/*! ./LABColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts");
const Color_1 = __webpack_require__(/*! ./Color */ "./src/canvastools/ts/CanvasTools/Core/Colors/Color.ts");
/**
 * The `Palette` class to generate a palette with specified settings
 * and extract a subset as color swatches.
 */
class Palette {
    /** Creates a new palette with provided settings */
    constructor(settings) {
        this.settings = {
            lightness: (settings.lightness === undefined) ?
                0.65 : Math.max(0, Math.min(1, settings.lightness)),
            lightnessVariation: (settings.lightnessVariation === undefined) ?
                0 : Math.max(0, Math.min(1, settings.lightnessVariation)),
            minGrayness: (settings.minGrayness === undefined) ?
                0 : Math.max(0, Math.min(1, settings.minGrayness)),
            maxGrayness: (settings.maxGrayness === undefined) ?
                2 : Math.max(0, Math.min(2, settings.maxGrayness)),
            granularity: (settings.granularity === undefined) ?
                50 : Math.max(10, settings.granularity),
            abRange: (settings.abRange === undefined) ?
                1.3 : Math.max(0, Math.min(2, settings.abRange)),
        };
        this.generateClusterPromise = this.generateGamutClusterAsync();
    }
    /**
     * Returns a promise with Gamut points resolved when all points are calculated.
     */
    async gamut() {
        if (this.gamutCluster !== undefined && this.gamutCluster !== null) {
            return new Promise((resolve) => resolve(this.gamutCluster));
        }
        else {
            return this.generateClusterPromise.then((cluster) => {
                this.gamutCluster = cluster;
                return cluster;
            });
        }
    }
    /**
     * Generates a random set of swatches within the palette's gamut.
     * @param colorsCount - The number of colors to be generated.
     */
    async swatches(colorsCount) {
        return this.gamut().then((cluster) => {
            const swatches = new Array();
            const first = Math.round(Math.random() * cluster.length);
            swatches.push(cluster[first]);
            for (let i = 0; i < colorsCount - 1; i++) {
                swatches.push(this.findNextColor(swatches, cluster));
            }
            return swatches;
        });
    }
    /**
     * Expands provided set of swatches within the palette's gamut.
     * @param swatches - The original set of swatches.
     * @param colorsCount - The number of new colors to be generated.
     */
    async more(swatches, colorsCount) {
        if (swatches.length > 0) {
            return this.gamut().then((cluster) => {
                const newSwatches = new Array();
                const allSwatches = swatches.map((sw) => sw);
                for (let i = 0; i < colorsCount; i++) {
                    const swatch = this.findNextColor(allSwatches, cluster);
                    allSwatches.push(swatch);
                    newSwatches.push(swatch);
                }
                return newSwatches;
            });
        }
        else {
            return this.swatches(colorsCount);
        }
    }
    /**
     * Iteratively generates new swatches within the palette's gamut.
     */
    swatchIterator() {
        return __asyncGenerator(this, arguments, function* swatchIterator_1() {
            const gamut = yield __await(this.gamut());
            const firstIndex = Math.round(Math.random() * gamut.length);
            const firstColor = gamut[firstIndex];
            yield yield __await(firstColor);
            const swatches = [firstColor];
            let lastColor = firstColor;
            let distance = 1.0;
            while ((distance) > 0) {
                const nextColor = this.findNextColor(swatches, gamut);
                swatches.push(nextColor);
                distance = nextColor.LAB.distanceTo_00(lastColor.LAB);
                lastColor = nextColor;
                if (distance > 0) {
                    yield yield __await(nextColor);
                }
            }
        });
    }
    /**
     * Finds the next color to expand the swatches set within the palette's gamut.
     * Returns the point with maximum distance to all the colors in swatches.
     * @param swatches - The original set of swatches.
     * @param cluster - The cluster to look with-in.
     */
    findNextColor(swatches, cluster) {
        let candidate = cluster[0];
        let maxDistanceSQ = 0;
        cluster.forEach((colorPoint) => {
            const distances = swatches.map((swatchPoint) => {
                return colorPoint.LAB.distanceTo_00(swatchPoint.LAB);
            });
            const minDistanceSQ = Math.min(...distances);
            if (minDistanceSQ > maxDistanceSQ) {
                candidate = colorPoint;
                maxDistanceSQ = minDistanceSQ;
            }
        });
        return candidate;
    }
    /**
     * Wraps the `generateGamutCluster` method into a Promise.
     */
    generateGamutClusterAsync() {
        const promise = new Promise((resolve) => {
            this.gamutCluster = this.generateGamutCluster();
            resolve(this.gamutCluster);
        });
        return promise;
    }
    /**
     * Generates a gamut cluster of paired colors in CIELAB (LAB) and RGB,
     * filtered by color points valid in RGB space and grayness constrains
     * (withing the range of [`minGrainess`, `maxGrayness`]).
     *
     * This method augments the `generatePointsCluster` method with lightness settings,
     * putting lightness equal to a random value within the range
     * [`lightness` - `lightnessVariation`/2, `lightness` + `lightnessVariation`/2].
     */
    generateGamutCluster() {
        let cluster = this.generatePointsCluster(this.settings.granularity);
        cluster = cluster.filter((p) => {
            const d = this.distanceToGray(p);
            return d >= this.settings.minGrayness && d <= this.settings.maxGrayness;
        });
        const colorSpace = new Array();
        cluster.forEach((p) => {
            let lightness = this.settings.lightness;
            if (this.settings.lightnessVariation > 0) {
                lightness += this.settings.lightnessVariation * (Math.random() - 0.5);
                lightness = Math.max(0, Math.min(1, lightness));
            }
            const labcolor = new LABColor_1.LABColor(lightness, p.a, p.b);
            const color = new Color_1.Color(labcolor);
            if (color.sRGB.isValidColor()) {
                colorSpace.push(color);
            }
        });
        return colorSpace;
    }
    /**
     * Calculate distance from color point to a zero-point (`a = b = 0`).
     * @param p - Origin point.
     */
    distanceToGray(p) {
        return Math.sqrt(p.a * p.a + p.b * p.b);
    }
    /**
     * Generate a grid of color points in AB-subspace, centered at `a = b = 0` and
     * the grid size [-`abRage`, +`abRange`] in each dimension.
     * @param granularity - Number of grid steps in each dimension.
     */
    generatePointsCluster(granularity) {
        granularity = Math.round(granularity);
        const cluster = new Array(granularity * granularity);
        const range = this.settings.abRange;
        for (let i = 0; i < granularity; i++) {
            for (let j = 0; j < granularity; j++) {
                cluster[i * granularity + j] = {
                    a: range * 2 * i / (granularity - 1) - range,
                    b: range * 2 * j / (granularity - 1) - range,
                };
            }
        }
        return cluster;
    }
}
exports.Palette = Palette;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/RGBColor.ts":
/*!****************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/RGBColor.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const XYZColor_1 = __webpack_require__(/*! ./XYZColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/XYZColor.ts");
const SRGBColor_1 = __webpack_require__(/*! ./SRGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/SRGBColor.ts");
/**
 * Represents the RGB color space.
 */
class RGBColor {
    /**
     * The red-component of the color.
     */
    get r() {
        return this.values[0];
    }
    /**
     * The green-component of the color.
     */
    get g() {
        return this.values[1];
    }
    /**
     * The blue-component of the color.
     */
    get b() {
        return this.values[2];
    }
    /**
     * Creates new RGBColor
     * @param r - Red component in the range [0, 1].
     * @param g - Green component in the range [0, 1].
     * @param b - Blue component in the range [0, 1].
     */
    constructor(r, g, b) {
        this.values = [r, g, b];
    }
    /**
     * Return a copy of color values in array format as [r, g, b].
     */
    toArray() {
        // copy
        return this.values.map((v) => v);
    }
    /**
     * Trasforms color to the XYZ format.
     */
    toXYZ() {
        const [r, g, b] = this.values;
        const x = 0.4124 * r + 0.3576 * g + 0.1805 * b;
        const y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        const z = 0.0193 * r + 0.1192 * g + 0.9505 * b;
        return new XYZColor_1.XYZColor(x, y, z);
    }
    /**
     * Trasforms color to the sRGB values.
     */
    toSRGB() {
        const values = this.values.map((v) => {
            if (v < 0.0031308) {
                return 12.92 * v;
            }
            else {
                return 1.055 * Math.pow(v, 1 / 2.4) - 0.055;
            }
        });
        return new SRGBColor_1.SRGBColor(values[0], values[1], values[2]);
    }
    /**
     * Trasforms color to the CIE LAB format.
     */
    toLAB() {
        return this.toXYZ().toLAB();
    }
}
exports.RGBColor = RGBColor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/SRGBColor.ts":
/*!*****************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/SRGBColor.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const HSLColor_1 = __webpack_require__(/*! ./HSLColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/HSLColor.ts");
const RGBColor_1 = __webpack_require__(/*! ./RGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/RGBColor.ts");
/**
 * Represents the sRGB color space.
 */
class SRGBColor {
    /**
     * Parses the hex-string representation of the RGB color.
     * @param hex - Color string in the format "#RGB" (#RGBA) or "#RRGGBB" (#RRGGBBAA).
     * @remarks Alpha value (if present) is ignored.
     */
    static ParseHex(hex) {
        const isValidColor = /#([a-f0-9]{3,4}){1,2}\b/i.test(hex);
        if (!isValidColor) {
            throw new Error(`Invalid CSS RGB color: ${hex}`);
        }
        let r;
        let g;
        let b;
        if (hex.length === 7 || hex.length === 9) {
            r = parseInt(hex.substring(1, 3), 16) / 255;
            g = parseInt(hex.substring(3, 5), 16) / 255;
            b = parseInt(hex.substring(5, 7), 16) / 255;
        }
        else if (hex.length === 4 || hex.length === 5) {
            r = parseInt(hex.charAt(1), 16) / 16;
            g = parseInt(hex.charAt(2), 16) / 16;
            b = parseInt(hex.charAt(3), 16) / 16;
        }
        return new SRGBColor(r, g, b);
    }
    /**
     * The red-component of the color.
     */
    get r() {
        return this.values[0];
    }
    /**
     * The green-component of the color.
     */
    get g() {
        return this.values[1];
    }
    /**
     * The blue-component of the color.
     */
    get b() {
        return this.values[2];
    }
    /**
     * Creates new RGBColor
     * @param r - Red component in the range [0, 1].
     * @param g - Green component in the range [0, 1].
     * @param b - Blue component in the range [0, 1].
     */
    constructor(r, g, b) {
        this.values = [r, g, b];
    }
    /**
     * Checks if the color values are in the range [0, 1].
     */
    isValidColor() {
        return (this.r >= 0) && (this.r <= 1) &&
            (this.g >= 0) && (this.g <= 1) &&
            (this.b >= 0) && (this.b <= 1);
    }
    /**
     * Truncates the color values to the range [0, 1].
     */
    truncate() {
        return new SRGBColor(Math.min(1, Math.max(0, this.r)), Math.min(1, Math.max(0, this.g)), Math.min(1, Math.max(0, this.b)));
    }
    /**
     * Return a copy of color values in array format as [r, g, b].
     */
    toArray() {
        // copy
        return this.values.map((v) => v);
    }
    /**
     * Composes the CSS color string using the rgb() or rgba() format.
     * @param alpha - The alpha value for rgba() format.
     */
    toCSSString(alpha) {
        const [r, g, b] = this.to255();
        if (alpha !== undefined) {
            // cast to [0, 1]
            alpha = Math.min(1, Math.max(0, alpha));
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        else {
            return `rgb(${r}, ${g}, ${b})`;
        }
    }
    /**
     * Composes the CSS color string using the "#RRGGBB" or "#RRGGBBAA" format.
     * @param alpha - The alpha value for the #RRGGBBAA format.
     */
    toHex(alpha) {
        const [r, g, b] = this.toFF();
        if (alpha !== undefined) {
            // cast to [0, 1]
            alpha = Math.min(1, Math.max(0, alpha));
            const alphaFF = Math.round(alpha * 255).toString(16);
            return `#${r}${g}${b}${alphaFF}`;
        }
        else {
            return `#${r}${g}${b}`;
        }
    }
    /**
     * Trasforms color to the HSL format.
     */
    toHSL() {
        const [r, g, b] = this.values;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h;
        let s;
        const l = (max + min) / 2;
        if (max === min) {
            h = 0;
            s = 0;
        }
        else {
            const d = max - min;
            s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor_1.HSLColor(h, s, l);
    }
    /**
     * Trasforms color to the XYZ format.
     */
    toXYZ() {
        return this.toRGB().toXYZ();
    }
    /**
     * Convert sRGB-color values into linear RGB format
     */
    toRGB() {
        const [r, g, b] = this.values.map((v) => {
            if (v < 0.04045) {
                return v / 12.92;
            }
            else {
                return ((v + 0.055) / 1.055) ** 2.4;
            }
        });
        return new RGBColor_1.RGBColor(r, g, b);
    }
    /**
     * Trasforms color to the CIE LAB format.
     */
    toLAB() {
        return this.toRGB().toXYZ().toLAB();
    }
    /**
     * Internal helper function to map color values into [0, 255] range.
     */
    to255() {
        const rgb = this.truncate();
        return rgb.values.map((v) => Math.round(255 * v));
    }
    /**
     * Internal helper function to map color values into hex-format "FF".
     */
    toFF() {
        const rgb = this.truncate();
        return rgb.values.map((v) => Math.round(255 * v).toString(16).padStart(2, "0"));
    }
}
exports.SRGBColor = SRGBColor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Colors/XYZColor.ts":
/*!****************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Colors/XYZColor.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RGBColor_1 = __webpack_require__(/*! ./RGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/RGBColor.ts");
const LABColor_1 = __webpack_require__(/*! ./LABColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts");
/**
 * Represents the CIE XYZ color space.
 */
class XYZColor {
    /**
     * Creates new XYZ color.
     * @param x - x-component in the range [0, 1].
     * @param y - y-component in the range [0, 1].
     * @param z - z-component in the range [0, 1].
     */
    constructor(x, y, z) {
        this.values = [x, y, z];
    }
    /**
     * The x-component of the color.
     */
    get x() {
        return this.values[0];
    }
    /**
     * The y-component of the color.
     */
    get y() {
        return this.values[1];
    }
    /**
     * The z-component of the color.
     */
    get z() {
        return this.values[2];
    }
    /**
     * Return a copy of color values in array format as [x, y, z].
     */
    toArray() {
        // copy
        return this.values.map((v) => v);
    }
    /**
     * Trasforms color to the RGB format.
     */
    toRGB() {
        const [x, y, z] = this.values;
        const r = +3.2406255 * x - 1.5372080 * y - 0.4986286 * z;
        const g = -0.9689307 * x + 1.8757561 * y + 0.0415175 * z;
        const b = +0.0557101 * x - 0.2040211 * y + 1.0569959 * z;
        return new RGBColor_1.RGBColor(r, g, b);
    }
    /**
     * Trasforms color to the sRGB format.
     */
    toSRGB() {
        return this.toRGB().toSRGB();
    }
    /**
     * Trasforms color to the CIE LAB format.
     */
    toLAB() {
        const x = this.x / XYZColor.D65.x;
        const y = this.y / XYZColor.D65.y;
        const z = this.z / XYZColor.D65.z;
        const xyz = [x, y, z].map((v) => {
            if (v > 0.008856451) {
                return v ** (1 / 3);
            }
            else {
                return 7.787037 * v + 16 / 116;
            }
        });
        return new LABColor_1.LABColor((116 * xyz[1] - 16) / 100, 5 * (xyz[0] - xyz[1]), 2 * (xyz[1] - xyz[2]));
    }
}
/**
 * The D65 white point vector.
 */
XYZColor.D65 = new XYZColor(0.95047, 1.000, 1.08883);
/**
 * The D50 white point vector.
 */
XYZColor.D50 = new XYZColor(0.966797, 1.000, 0.825188);
exports.XYZColor = XYZColor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts":
/*!********************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Point2D.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a 2d point object
 */
class Point2D {
    /**
     * Creates a new point based on extracting specific properties from any provided object
     * @param data - An `IPoint` object with `x` and `y` numeric properties
     * @returns A new `Point2D` object
     */
    static BuildFromJSON(data) {
        return new Point2D(data.x, data.y);
    }
    constructor(arg1, arg2) {
        if (typeof arg1 === "number" && typeof arg2 === "number") {
            this.x = arg1;
            this.y = arg2;
        }
        else if (arg1.x !== undefined && arg1.y !== undefined) {
            this.x = arg1.x;
            this.y = arg1.y;
        }
    }
    move(arg1, arg2) {
        if (typeof arg1 === "number" && typeof arg2 === "number") {
            this.x = arg1;
            this.y = arg2;
        }
        else if (arg1.x !== undefined && arg1.y !== undefined) {
            this.x = arg1.x;
            this.y = arg1.y;
        }
    }
    /**
     * Shifts point location to specified delta
     * @param dx - Delta to be added to the `x`-coordinate
     * @param dy - Delta to be added to the `y`-coordinate
     */
    shift(dx, dy) {
        this.x += dx;
        this.y += dy;
    }
    /**
     * Returns a new point created from bounding this one to the `Rect` object rovided
     * @remarks This method bounds the point to the rect with coordinates `[0, 0] x [r.width, r.height]`.
     * @param r - A bounding box
     * @returns A new `Point2D` object, with coordinates bounded to the box
     */
    boundToRect(r) {
        return new Point2D((this.x < 0) ? 0 : ((this.x > r.width) ? r.width : this.x), (this.y < 0) ? 0 : ((this.y > r.height) ? r.height : this.y));
    }
    /**
     * Calculates the square of the distance between two points
     * @param p - Second point
     * @returns The square of the distance
     */
    squareDistanceToPoint(p) {
        return (this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y);
    }
    /**
     * Calculates the square of the distance from this point to a line segment
     * @param p1 - The first line segment point
     * @param p2 - The second line segment point
     * @returns The square of the distance
     */
    squareDistanceToLine(p1, p2) {
        const lineLength2 = p1.squareDistanceToPoint(p2);
        let dist;
        if (lineLength2 === 0.0) {
            dist = this.squareDistanceToPoint(p1);
        }
        else {
            const t = ((this.x - p1.x) * (p2.x - p1.x) + (this.y - p1.y) * (p2.y - p1.y)) / lineLength2;
            const k = Math.max(0, Math.min(1, t));
            const p = new Point2D(p1.x + k * (p2.x - p1.x), p1.y + k * (p2.y - p1.y));
            dist = this.squareDistanceToPoint(p);
        }
        return dist;
    }
    /**
     * Creates a copy of this point
     * @returns A new `Point2D` object with copied coordinates
     */
    copy() {
        return new Point2D(this.x, this.y);
    }
    /**
     * Returns a string representation of the point in the format `"{x, y}"`.
     * @returns A string representation of the point
     */
    toString() {
        return `{${this.x.toString()}, ${this.y.toString()}}`;
    }
    /**
     * Returns a JSON representation of the point
     * @returns An `IPoint` object with `x` and `y` numeric properties.
     */
    toJSON() {
        return {
            x: this.x,
            y: this.y,
        };
    }
}
exports.Point2D = Point2D;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Rect.ts":
/*!*****************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Rect.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a rect object
 */
class Rect {
    /**
     * Creates a new rect based on extracting specific properties from any provided object
     * @param data - An `IRect` object with `width` and `height` numeric properties
     * @returns A new `Rect` object
     */
    static BuildFromJSON(data) {
        return new Rect(data.width, data.height);
    }
    /**
     * Creates a new `Rect` object with specified `width` and `height`
     * @param width - `width` of the new rect
     * @param height - `height` of the new rect
     */
    constructor(width, height) {
        this.width = 0;
        this.height = 0;
        this.resize(width, height);
    }
    /**
     * Resizes this rect to specified `width` and `height`
     * @param width - a new `width` for the rect
     * @param height - a new `height` for the rect
     */
    resize(width, height) {
        if (width >= 0 && height >= 0) {
            this.width = width;
            this.height = height;
        }
    }
    /**
     * Creates a copy of this rect
     * @returns A new `Rect` object with copied dimensions
     */
    copy() {
        return new Rect(this.width, this.height);
    }
    /**
     * Returns a string representation of the rect in the format `"[width, height]"`.
     * @returns A string representation of the rect
     */
    toString() {
        return `[${this.width.toString()}, ${this.height.toString()}]`;
    }
    /**
     * Returns a JSON representation of the rect
     * @returns An `IRect` object with `width` and `height` numeric properties.
     */
    toJSON() {
        return {
            width: this.width,
            height: this.height,
        };
    }
}
exports.Rect = Rect;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts":
/*!***********************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/RegionData.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ./Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const Rect_1 = __webpack_require__(/*! ./Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
/**
 * Defines supported region types.
 */
var RegionDataType;
(function (RegionDataType) {
    RegionDataType["Point"] = "point";
    RegionDataType["Rect"] = "rect";
    RegionDataType["Polyline"] = "polyline";
    RegionDataType["Polygon"] = "polygon";
})(RegionDataType = exports.RegionDataType || (exports.RegionDataType = {}));
/**
 * Represents region meta-data, including position, size, points and type
 */
class RegionData {
    /**
     * Creates a new `RegionData` object with `point`-type at provided `x`, `y` coordinates
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @returns A new `RegionData` object
     */
    static BuildPointRegionData(x, y) {
        return new RegionData(x, y, 0, 0, [new Point2D_1.Point2D(x, y)], RegionDataType.Point);
    }
    /**
     * Creates a new `RegionData` object with `rect`-type at provided `x`, `y`
     * coordinates and of provided `width` and `height`
     * @param x - `x`-coordinate
     * @param y - `y`-coordinate
     * @param width - `width` of the rect
     * @param height - `height` of the rect
     * @returns A new `RegionData` object
     */
    static BuildRectRegionData(x, y, width, height) {
        return new RegionData(x, y, width, height, [new Point2D_1.Point2D(x, y), new Point2D_1.Point2D(x + width, y),
            new Point2D_1.Point2D(x + width, y + height), new Point2D_1.Point2D(x, y + height)], RegionDataType.Rect);
    }
    /**
     * Creates a new `RegionData` object based on extracting specific properties from any provided object
     * @param data - An `IRegionData` object with `x`, `y`, `width`, `height`, `points` and `type` properties
     * @returns A new `RegionData` object
     */
    static BuildFromJson(data) {
        return new RegionData(data.x, data.y, data.width, data.height, data.points.map((p) => new Point2D_1.Point2D(p.x, p.y)), data.type);
    }
    /**
     * Gets the `x`-coordinate of the region
     */
    get x() {
        return this.corner.x;
    }
    /**
     * Sets the `x`-coordinate of the region. *Region points position will be recalculated*
     */
    set x(x) {
        this.move(x, this.y);
    }
    /**
     * Gets the `y`-coordinate of the region
     */
    get y() {
        return this.corner.y;
    }
    /**
     * Sets the `y`-coordinate of the region. *Region points position will be recalculated*
     */
    set y(y) {
        this.move(this.x, y);
    }
    /**
     * Gets the `width` of the region
     */
    get width() {
        return this.regionRect.width;
    }
    /**
     * Sets the `width` of the region. *Region points position will be recalculated*
     */
    set width(width) {
        this.resize(width, this.height);
    }
    /**
     * Gets the `height` of the region
     */
    get height() {
        return this.regionRect.height;
    }
    /**
     * Sets the `height` of the region. *Region points position will be recalculated*
     */
    set height(height) {
        this.resize(this.width, height);
    }
    /**
     * Returns the area of the region. *Point has area = 1.0, for other types it is `width * height`*
     */
    get area() {
        let area;
        if (this.regionType === RegionDataType.Point) {
            area = 1.0;
        }
        else {
            area = this.regionRect.width * this.regionRect.height;
        }
        return area;
    }
    /**
     * Gets the bounding box size of the region
     */
    get boundRect() {
        return this.regionRect.copy();
    }
    /**
     * Sets the bounding box size of the region. *Region will be resized automatically*
     */
    set boundRect(rect) {
        this.resize(rect.width, rect.height);
    }
    /**
     * Gets the array of region points.
     */
    get points() {
        return this.regionPoints.map((p) => p.copy());
    }
    /**
     * Sets the array of region points. *Region will be resized and repositioned automatically*
     */
    set points(points) {
        this.setPoints(points);
    }
    /**
     * Gets the type of the region
     */
    get type() {
        return this.regionType;
    }
    /**
     * Creates a new `RegionData` object
     * @param x - `x`-coordinate of the region
     * @param y - `y`-coordinate of the region
     * @param width - `width` of the region
     * @param height - `height` of the region
     * @param points - Collection of internal region points
     * @param type - `type` of the region from enum `RegionDataType`
     */
    constructor(x, y, width, height, points, type) {
        this.corner = new Point2D_1.Point2D(x, y);
        this.regionRect = new Rect_1.Rect(width, height);
        this.regionPoints = (points !== undefined && points !== null) ? points : new Array();
        this.regionType = (type !== undefined) ? type : RegionDataType.Point;
    }
    move(arg1, arg2) {
        const oldx = this.x;
        const oldy = this.y;
        this.corner.move(arg1, arg2);
        const dx = this.x - oldx;
        const dy = this.y - oldy;
        this.regionPoints.forEach((p) => {
            p.shift(dx, dy);
        });
    }
    /**
     * Resizes regions to specified dimensions
     * @param width - New `width` of the region
     * @param height - New `height` of the region
     */
    resize(width, height) {
        const sx = width / this.width;
        const sy = height / this.height;
        this.regionRect.resize(width, height);
        this.regionPoints.forEach((p) => {
            const px = (p.x - this.x) * sx + this.x;
            const py = (p.y - this.y) * sy + this.y;
            p.move(px, py);
        });
    }
    /**
     * Changes the `point` at specified `index`
     * @param point - New `point` value
     * @param index - `index` of the point in internal collection
     */
    setPoint(point, index) {
        if (index >= 0 && index < this.regionPoints.length) {
            this.regionPoints[index] = new Point2D_1.Point2D(point);
        }
        // Update region position and size
        let xmin = Number.MAX_VALUE;
        let xmax = 0;
        let ymin = Number.MAX_VALUE;
        let ymax = 0;
        this.regionPoints.forEach((point) => {
            if (point.x > xmax) {
                xmax = point.x;
            }
            if (point.x < xmin) {
                xmin = point.x;
            }
            if (point.y > ymax) {
                ymax = point.y;
            }
            if (point.y < ymin) {
                ymin = point.y;
            }
        });
        this.corner.move(xmin, ymin);
        this.regionRect.resize(xmax - xmin, ymax - ymin);
    }
    /**
     * Updates the collection of internal points
     * @param points - `IPoint2D[]` collection for the region to serve as the source for the
     * internal *copy* in the `points` collection
     */
    setPoints(points) {
        let xmin = Number.MAX_VALUE;
        let xmax = 0;
        let ymin = Number.MAX_VALUE;
        let ymax = 0;
        // Update region position and size
        points.forEach((point) => {
            if (point.x > xmax) {
                xmax = point.x;
            }
            if (point.x < xmin) {
                xmin = point.x;
            }
            if (point.y > ymax) {
                ymax = point.y;
            }
            if (point.y < ymin) {
                ymin = point.y;
            }
        });
        this.regionPoints = points.map((p) => new Point2D_1.Point2D(p));
        this.corner.move(xmin, ymin);
        this.regionRect.resize(xmax - xmin, ymax - ymin);
    }
    /**
     * Inits this region properties from another `IRegionData` object
     * @param regionData - An `IRegionData` object to serve as the source for the property values
     */
    initFrom(regionData) {
        this.corner = new Point2D_1.Point2D(regionData.x, regionData.y);
        this.regionRect = new Rect_1.Rect(regionData.width, regionData.height);
        this.regionPoints = regionData.points.map((p) => new Point2D_1.Point2D(p.x, p.y));
    }
    /**
     * Returns a new `RegionData` object with all coordinates and dimensions bounded to specified box
     * @param rect - The `IRect` box, which `width` and `height` will be used for bounding
     * @returns A new `RegionData` object
     */
    boundToRect(rect) {
        const brCorner = (new Point2D_1.Point2D(this.x + this.width, this.y + this.height)).boundToRect(rect);
        const tlCorner = this.corner.boundToRect(rect);
        const width = brCorner.x - tlCorner.x;
        const height = brCorner.y - tlCorner.y;
        return new RegionData(tlCorner.x, tlCorner.y, width, height, this.regionPoints.map((p) => p.boundToRect(rect)), this.regionType);
    }
    scale(f1, f2) {
        const xf = f1;
        const yf = (f2 !== undefined) ? f2 : f1;
        this.corner = new Point2D_1.Point2D(this.x * xf, this.y * yf);
        this.regionRect = new Rect_1.Rect(this.width * xf, this.height * yf);
        this.regionPoints = this.regionPoints.map((p) => new Point2D_1.Point2D(p.x * xf, p.y * yf));
    }
    /**
     * Creates a copy of this region data
     * @returns A new `RegionData` object with copied properties
     */
    copy() {
        return new RegionData(this.x, this.y, this.width, this.height, this.regionPoints.map((p) => p.copy()), this.regionType);
    }
    /**
     * Returns a string representation of the region in the format
     * `"{x, y} x [width, height]: {{x1, y1}, ..., {xn, yn}}"`.
     * @returns A string representation of the rect
     */
    toString() {
        return `${this.corner.toString()} x ${this.boundRect.toString()}: {${this.regionPoints.toString()}}`;
    }
    /**
     * Returns a JSON representation of the region
     * @returns An `IRegionData` object with properties only.
     */
    toJSON() {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            points: this.regionPoints.map((point) => {
                return { x: point.x, y: point.y };
            }),
            type: this.regionType,
        };
    }
}
exports.RegionData = RegionData;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/Tag.ts":
/*!****************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/Tag.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = __webpack_require__(/*! ../Core/Colors/Color */ "./src/canvastools/ts/CanvasTools/Core/Colors/Color.ts");
const HSLColor_1 = __webpack_require__(/*! ./Colors/HSLColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/HSLColor.ts");
const LABColor_1 = __webpack_require__(/*! ./Colors/LABColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts");
/**
 * Represents meta-data for a tag
 * @remarks
 * 1. To represent the color Tag class uses only the hue component
 * and generates a number of color variations based on that value.
 * 2. The `Tag` object is *immutable*, all public properties are readonly.
 */
class Tag {
    constructor(name, color, id = "") {
        this.tagColorPure = "";
        this.tagColorAccent = "";
        this.tagColorHighlight = "";
        this.tagColorShadow = "";
        this.tagColorNoColor = "";
        this.tagColorDark = "";
        this.tagName = name;
        if (typeof color === "number") {
            this.colorObj = new Color_1.Color(new HSLColor_1.HSLColor((color % 360) / 360.0, 1, 0.5));
        }
        else if (typeof color === "string") {
            this.colorObj = new Color_1.Color(color);
        }
        else if (color instanceof Color_1.Color) {
            this.colorObj = color;
        }
        this.tagID = id;
    }
    /**
     * Creates a new tag based on extracting specific properties from any provided object
     * @param data - An `ITag` object with `name`, `colorHue` and `id` properties
     * @returns A new `Tag` object
     */
    static BuildFromJSON(data) {
        if (data.color !== undefined) {
            return new Tag(data.name, new Color_1.Color(data.color), (data.id === undefined) ? "" : data.id);
        }
        else if (data.colorHue !== undefined) {
            return new Tag(data.name, new Color_1.Color(new HSLColor_1.HSLColor((data.colorHue % 360) / 360.0, 1, 0.5)), (data.id === undefined) ? "" : data.id);
        }
    }
    /**
     * Extracts the hue component from a provided CSS color string
     * @param color - A CSS-color in "#RRGGBB" or "#RGB" format
     * @returns A hue value for provided color
     * @deprecated Use the Color class instead.
     */
    static getHueFromColor(color) {
        const c = new Color_1.Color(color);
        return c.HSL.h * 360;
    }
    /**
     * The hue-value of the tag's color. *Readonly*
     */
    get colorHue() {
        return this.colorObj.HSL.h * 360;
    }
    /**
     * The tag's color in hex format. *Readonly*
     */
    get color() {
        return this.colorObj.sRGB.toHex();
    }
    /**
     * The `name` of the tag. *Readonly*
     */
    get name() {
        return this.tagName;
    }
    /**
     * The `id` of the tag. *Readonly*
     */
    get id() {
        return this.tagID;
    }
    /**
     * Returns the pure color variation of the tag's color
     * @returns String hsl(H, 100%, 50%)
     */
    get colorPure() {
        if (this.tagColorPure === "") {
            this.tagColorPure = this.colorObj.sRGB.toHex();
            // OLD: `hsl(${this.tagHue.toString()}, 100%, 50%)`;
        }
        return this.tagColorPure;
    }
    /**
     * Returns the accent color variation of the tag's color.
     * Accent = almost pure, alpha = 0.8.
     * @returns Hex string for the color
     */
    get colorAccent() {
        if (this.tagColorAccent === "") {
            this.tagColorAccent = this.colorObj.sRGB.toHex(0.8);
            // OLD: `hsla(${this.tagHue.toString()}, 100%, 50%, 0.5)`;
        }
        return this.tagColorAccent;
    }
    /**
     * Returns the highlight color variation of the tag's color.
     * Highlight = grayed pure, alpha = 0.4
     * @returns Hex string for the color
     */
    get colorHighlight() {
        if (this.tagColorHighlight === "") {
            const lab = this.colorObj.LAB.toArray();
            const highlight = new LABColor_1.LABColor(lab[0] * 0.7, lab[1] * 0.7, lab[2] * 0.7);
            this.tagColorHighlight = highlight.toSRGB().truncate().toHex(0.4);
            // OLD: `hsla(${this.tagHue.toString()}, 80%, 40%, 0.3)`;
        }
        return this.tagColorHighlight;
    }
    /**
     * Returns the shadow color variation of the tag's color
     * Shadow = grayed pure, alpha = 0.2
     * @returns Hex string for the color
     */
    get colorShadow() {
        if (this.tagColorShadow === "") {
            const lab = this.colorObj.LAB.toArray();
            const shadow = new LABColor_1.LABColor(lab[0] * 0.6, lab[1] * 0.6, lab[2] * 0.6);
            this.tagColorShadow = shadow.toSRGB().truncate().toHex(0.2);
            // OLD: `hsla(${this.tagHue.toString()}, 50%, 30%, 0.2)`;
        }
        return this.tagColorShadow;
    }
    /**
     * Returns the dark color variation of the tag's color.
     * Dark = pure with decreased lightness and grayed.
     * @returns Hex string for the color
     */
    get colorDark() {
        if (this.tagColorDark === "") {
            const lab = this.colorObj.LAB.toArray();
            const dark = new LABColor_1.LABColor(lab[0] * 0.5, lab[1] * 0.5, lab[2] * 0.5);
            this.tagColorDark = dark.toSRGB().truncate().toHex(0.8);
            // OLD: `hsla(${this.tagHue.toString()}, 50%, 30%, 0.8)`;
        }
        return this.tagColorDark;
    }
    /**
     * Returns the fully transparent color variation of the tag's color
     * @returns Hex string for the color
     */
    get colorNoColor() {
        if (this.tagColorNoColor === "") {
            this.tagColorNoColor = `rgba(0, 0, 0, 0.0)`;
        }
        return this.tagColorNoColor;
    }
    /**
     * Creates a copy of this tag
     * @returns A new `Tag` object with copied properties
     */
    copy() {
        return new Tag(this.tagName, this.colorObj, this.tagID);
    }
    /**
     * Returns a JSON representation of the tag
     * @returns An `ITag` object with `name`, `colorHue` and `id` properties
     */
    toJSON() {
        return {
            name: this.tagName,
            colorHue: this.colorHue,
            color: this.colorObj.sRGB.toHex(),
            id: this.tagID,
        };
    }
}
exports.Tag = Tag;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Core/TagsDescriptor.ts":
/*!***************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Core/TagsDescriptor.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Tag_1 = __webpack_require__(/*! ./Tag */ "./src/canvastools/ts/CanvasTools/Core/Tag.ts");
/**
 * Represents a composition of region tags
 */
class TagsDescriptor {
    /**
     * Creates a new `TagDescriptor` object based on extracting specific properties from any provided object
     * @remarks The `TagDescriptor` object is *immutable*. All public properties return copies of objects.
     * @param data - An `ITagDescriptor` object with the `primary` and `secondary`
     * properties implementing `ITag` and `ITag[]` interfaces
     * @returns A new `TagDescriptor` object
     */
    static BuildFromJSON(data) {
        let p = null;
        if (data.primary !== null && data.primary !== undefined) {
            p = Tag_1.Tag.BuildFromJSON(data.primary);
        }
        const s = (data.secondary === undefined) ? [] : data.secondary.map((tag) => Tag_1.Tag.BuildFromJSON(tag));
        return new TagsDescriptor(p, s);
    }
    /**
     * Returns an array of all tags (no order guaranteed). *Readonly*
     */
    get all() {
        return this.allTags.map((tag) => tag.copy());
    }
    /**
     * Returns the primary tag. *Readonly*
     */
    get primary() {
        if (this.primaryTag !== null) {
            return this.primaryTag.copy();
        }
        else {
            return null;
        }
    }
    /**
     * Returns an array of all secondary tags (no order guaranteed). *Readonly*
     */
    get secondary() {
        if (this.primaryTag !== null) {
            return this.all.filter((tag) => {
                return (tag.name !== this.primary.name);
            });
        }
        else {
            return this.all;
        }
    }
    /**
     * Creates a new `TagDescriptor` object with specified tags
     * @param primaryTag - Primary `Tag` for the descriptor
     * @param secondaryTags - An array of secondary tags (optional)
     */
    constructor(arg1, arg2 = []) {
        // empty TagsDescriptor
        if (arg1 === undefined) {
            this.primaryTag = null;
            this.allTags = [];
        }
        else if (arg1 instanceof Tag_1.Tag) {
            // arg1 = primaryTag, arg2 = secondaryTag
            if (arg2 instanceof Array) {
                this.allTags = new Array(arg1, ...arg2);
            }
            else {
                this.allTags = [arg1];
            }
            this.primaryTag = arg1;
        }
        else if (arg1 instanceof Array) {
            // arg1 = tags, ignore arg2
            this.allTags = arg1.map((tag) => tag.copy());
            if (arg1.length > 0) {
                this.primaryTag = arg1[0];
            }
            else {
                this.primaryTag = null;
            }
        }
        else if (arg1 === null) {
            // arg1 = null | undefined, ignore
            if (arg2 instanceof Array) {
                this.allTags = arg2.map((tag) => tag.copy());
            }
            else {
                this.allTags = [];
            }
            this.primaryTag = null;
        }
    }
    /**
     * Returns a string with a comma separated list of tags with primary tag first (if present)
     */
    toString() {
        let str = "";
        if (this.primaryTag !== null) {
            str += this.primaryTag.name;
            this.secondary.forEach((tag) => {
                str += ", " + tag.name;
            });
        }
        else {
            this.secondary.forEach((tag) => {
                str += ", " + tag.name;
            });
            str = str.substring(2, str.length);
        }
        return str;
    }
    /**
     * Returns an `ITagsDescriptor` object with `primary` and `secondary` properties
     */
    toJSON() {
        if (this.primaryTag !== null) {
            return {
                primary: this.primaryTag.toJSON(),
                secondary: this.secondary.map((tag) => tag.toJSON()),
            };
        }
        else {
            return {
                primary: null,
                secondary: this.secondary.map((tag) => tag.toJSON()),
            };
        }
    }
}
exports.TagsDescriptor = TagsDescriptor;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts":
/*!**********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Defines supported events types for regions.
 */
var ChangeEventType;
(function (ChangeEventType) {
    ChangeEventType[ChangeEventType["MOVEEND"] = 0] = "MOVEEND";
    ChangeEventType[ChangeEventType["MOVING"] = 1] = "MOVING";
    ChangeEventType[ChangeEventType["MOVEBEGIN"] = 2] = "MOVEBEGIN";
    ChangeEventType[ChangeEventType["SELECTIONTOGGLE"] = 3] = "SELECTIONTOGGLE";
})(ChangeEventType = exports.ChangeEventType || (exports.ChangeEventType = {}));


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Interface/ISelectorSettings.ts":
/*!***********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Interface/ISelectorSettings.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enum to define current selectio mode
 */
var SelectionMode;
(function (SelectionMode) {
    SelectionMode[SelectionMode["NONE"] = 0] = "NONE";
    SelectionMode[SelectionMode["POINT"] = 1] = "POINT";
    SelectionMode[SelectionMode["RECT"] = 2] = "RECT";
    SelectionMode[SelectionMode["COPYRECT"] = 3] = "COPYRECT";
    SelectionMode[SelectionMode["POLYLINE"] = 4] = "POLYLINE";
    SelectionMode[SelectionMode["POLYGON"] = 5] = "POLYGON";
})(SelectionMode = exports.SelectionMode || (exports.SelectionMode = {}));


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Component/AnchorsComponent.ts":
/*!*****************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Component/AnchorsComponent.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const IRegionCallbacks_1 = __webpack_require__(/*! ../../Interface/IRegionCallbacks */ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts");
const RegionComponent_1 = __webpack_require__(/*! ./RegionComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts");
/**
 * An abstract visual component used internall to draw anchor points that allow
 * region points moving and this component resizing.
 */
class AnchorsComponent extends RegionComponent_1.RegionComponent {
    /**
     * Creates a new `AnchorsComponent` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * The index of currently active anchor.
         */
        this.activeAnchorIndex = -1;
        this.node = paper.g();
        this.node.addClass("anchorsLayer");
        this.anchors = [];
        this.anchorsNode = paper.g();
        this.buildAnchors();
        this.ghostAnchor = this.createAnchor(paper, 0, 0, "ghost", AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS);
        this.ghostAnchor.attr({
            display: "none",
        });
        this.node.add(this.anchorsNode);
        this.node.add(this.ghostAnchor);
        const listeners = [
            { event: "pointerenter", listener: this.onGhostPointerEnter, base: this.ghostAnchor.node, bypass: false },
            { event: "pointerleave", listener: this.onGhostPointerLeave, base: this.ghostAnchor.node, bypass: false },
            { event: "pointerdown", listener: this.onGhostPointerDown, base: this.ghostAnchor.node, bypass: false },
            { event: "pointerup", listener: this.onGhostPointerUp, base: this.ghostAnchor.node, bypass: false },
            { event: "pointermove", listener: this.onGhostPointerMove, base: this.ghostAnchor.node, bypass: false },
        ];
        this.subscribeToEvents(listeners);
    }
    /**
     * Redraws the visual on the component.
     */
    redraw() {
        if (this.regionData.points !== null && this.regionData.points.length > 0) {
            window.requestAnimationFrame(() => {
                this.regionData.points.forEach((p, index) => {
                    this.anchors[index].attr({
                        cx: p.x,
                        cy: p.y,
                    });
                });
            });
        }
    }
    /**
     * Switches the component to the frozen state.
     */
    freeze() {
        super.freeze();
        this.ghostAnchor.undrag();
        this.onManipulationEnd();
    }
    /**
     * Creates a collection on anchors.
     */
    buildAnchors() {
        this.buildPointAnchors();
    }
    /**
     * Creates a collection of anchor points.
     */
    buildPointAnchors() {
        this.regionData.points.forEach((point, index) => {
            const anchor = this.createAnchor(this.paper, point.x, point.y);
            this.anchors.push(anchor);
            this.anchorsNode.add(anchor);
            this.subscribeAnchorToEvents(anchor, index);
        });
    }
    /**
     * Helper function to subscribe anchor to activation event.
     * @param anchor - The anchor for wire up.
     * @param index - The index of the anchor used to define which one is active.
     */
    subscribeAnchorToEvents(anchor, index) {
        anchor.node.addEventListener("pointerenter", (e) => {
            if (!this.isFrozen) {
                // Set drag origin point to current anchor
                this.dragOrigin = this.regionData.points[index];
                this.activeAnchorIndex = index;
                // Move ghost anchor to current anchor position
                window.requestAnimationFrame(() => {
                    this.ghostAnchor.attr({
                        cx: this.dragOrigin.x,
                        cy: this.dragOrigin.y,
                        display: "block",
                    });
                });
                this.onManipulationBegin();
            }
        });
    }
    /**
     * Helper function to create a new anchor.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param x - The `x`-coordinate of the acnhor.
     * @param y - The `y`-coordinate of the anchor.
     * @param style - Additional css style class to be applied.
     * @param r - The radius of the anchor.
     */
    createAnchor(paper, x, y, style, r = AnchorsComponent.DEFAULT_ANCHOR_RADIUS) {
        const a = paper.circle(x, y, r);
        a.addClass("anchorStyle");
        if (style !== undefined && style !== "") {
            a.addClass(style);
        }
        return a;
    }
    /**
     * Callback for the dragbegin event.
     */
    anchorDragBegin() {
        // do nothing
    }
    /**
     * Callback for the dragmove event. Uses `dragOrigin` to calculate new position.
     * @param dx - Diff in the `x`-coordinate.
     * @param dy - Diff in the `y`-coordinate.
     * @param x - New `x`-coordinate.
     * @param y - New `y`-coordinate.
     * @remarks This method calls the `updateRegion` method to actually make any changes in data.
     */
    anchorDragMove(dx, dy, x, y) {
        let p = new Point2D_1.Point2D(this.dragOrigin.x + dx, this.dragOrigin.y + dy);
        if (this.paperRect !== null) {
            p = p.boundToRect(this.paperRect);
        }
        window.requestAnimationFrame(() => {
            this.ghostAnchor.attr({ cx: p.x, cy: p.y });
        });
        this.updateRegion(p);
    }
    /**
     * Callback for the dranend event.
     */
    anchorDragEnd() {
        window.requestAnimationFrame(() => {
            this.ghostAnchor.attr({
                display: "none",
            });
        });
        this.activeAnchorIndex = -1;
    }
    /**
     * Callback for the pointerenter event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerEnter(e) {
        this.ghostAnchor.drag(this.anchorDragMove.bind(this), this.anchorDragBegin.bind(this), this.anchorDragEnd.bind(this));
        this.onManipulationBegin();
    }
    /**
     * Callback for the pointerleave event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerLeave(e) {
        this.ghostAnchor.undrag();
        window.requestAnimationFrame(() => {
            this.ghostAnchor.attr({
                display: "none",
            });
        });
        this.activeAnchorIndex = -1;
        this.onManipulationEnd();
    }
    /**
     * Callback for the pointerdown event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerDown(e) {
        this.ghostAnchor.node.setPointerCapture(e.pointerId);
        this.dragOrigin = new Point2D_1.Point2D(e.offsetX, e.offsetY);
        this.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEBEGIN);
    }
    /**
     * Callback for the pointermove event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerMove(e) {
        // do nothing
    }
    /**
     * Callback for the pointerup event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerUp(e) {
        this.ghostAnchor.node.releasePointerCapture(e.pointerId);
        this.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEEND);
    }
}
/**
 * Default radius for anchor poitns. Can be redefined through CSS styles.
 */
AnchorsComponent.DEFAULT_ANCHOR_RADIUS = 3;
/**
 * Defailt radius for the ghost anchor, used activate dragging. Can be redefined through CSS styles.
 */
AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS = 7;
exports.AnchorsComponent = AnchorsComponent;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Component/DragComponent.ts":
/*!**************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Component/DragComponent.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const IRegionCallbacks_1 = __webpack_require__(/*! ../../Interface/IRegionCallbacks */ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts");
const RegionComponent_1 = __webpack_require__(/*! ./RegionComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts");
/**
 * An abstract visual component used internall do allow dragging the whole region.
 */
class DragComponent extends RegionComponent_1.RegionComponent {
    /**
     * Creates a new `DragComponent` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * Dragging state of the component.
         */
        this.isDragged = false;
        this.node = paper.g();
        this.node.addClass("dragLayer");
    }
    /**
     * Switches the component to the frozen state.
     */
    freeze() {
        super.freeze();
        this.dragNode.undrag();
        this.onManipulationEnd();
    }
    /**
     * Callback for the dragbegin event.
     */
    onDragBegin() {
        this.dragOrigin = new Point2D_1.Point2D(this.x, this.y);
    }
    /**
     * Callback for the dragmove event.
     * @param dx - Diff in the `x`-coordinate of draggable element.
     * @param dy - Diff in the `y`-coordinate of draggable element.
     * @remarks This method directly calls the `onChange` callback wrapper.
     */
    onDragMove(dx, dy) {
        if (dx !== 0 && dy !== 0) {
            let p = new Point2D_1.Point2D(this.dragOrigin.x + dx, this.dragOrigin.y + dy);
            if (this.paperRect !== null) {
                p = p.boundToRect(this.paperRect);
            }
            const rd = this.regionData.copy();
            rd.move(p);
            this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
        }
    }
    /**
     * Callback for the dragend event.
     */
    onDragEnd() {
        this.dragOrigin = null;
        this.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEEND);
    }
    /**
     * Helper function to subscibe the draggable element to events.
     */
    subscribeToDragEvents() {
        const listeners = [
            {
                event: "pointerenter",
                base: this.dragNode.node,
                listener: (e) => {
                    this.dragNode.undrag();
                    this.dragNode.drag(this.onDragMove.bind(this), this.onDragBegin.bind(this), this.onDragEnd.bind(this));
                    this.isDragged = true;
                    this.onManipulationBegin();
                },
                bypass: false,
            },
            {
                event: "pointermove",
                base: this.dragNode.node,
                listener: (e) => {
                    if (!this.isDragged) {
                        this.dragNode.undrag();
                        this.dragNode.drag(this.onDragMove.bind(this), this.onDragBegin.bind(this), this.onDragEnd.bind(this));
                        this.isDragged = true;
                        this.onManipulationBegin();
                    }
                },
                bypass: false,
            },
            {
                event: "pointerleave",
                base: this.dragNode.node,
                listener: (e) => {
                    this.dragNode.undrag();
                    this.isDragged = false;
                    this.onManipulationEnd();
                },
                bypass: false,
            },
            {
                event: "pointerdown",
                base: this.dragNode.node,
                listener: (e) => {
                    this.dragNode.node.setPointerCapture(e.pointerId);
                    const multiselection = e.ctrlKey;
                    this.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.MOVEBEGIN, multiselection);
                },
                bypass: false,
            },
            {
                event: "pointerup",
                base: this.dragNode.node,
                listener: (e) => {
                    this.dragNode.node.releasePointerCapture(e.pointerId);
                    const multiselection = e.ctrlKey;
                    this.onChange(this, this.regionData.copy(), IRegionCallbacks_1.ChangeEventType.SELECTIONTOGGLE, multiselection);
                },
                bypass: false,
            },
        ];
        this.subscribeToEvents(listeners);
    }
}
exports.DragComponent = DragComponent;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts":
/*!****************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An abstract visial component to define a component of region presentation UI.
 */
class RegionComponent {
    /**
     * Creates a new UI component (part of the region).
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect, regionData, callbacks = null) {
        /**
         * Defines if the component is visible.
         */
        this.isVisible = true;
        /**
         * Defines if the component is in a frozen state.
         */
        this.isFrozen = false;
        /**
         * Defines if the component is selected.
         */
        this.isSelected = false;
        this.paper = paper;
        this.paperRect = paperRect;
        this.regionData = regionData;
        this.callbacks = {
            onChange: null,
            onManipulationBegin: null,
            onManipulationEnd: null,
        };
        if (callbacks !== null && callbacks !== undefined) {
            if (callbacks.onManipulationBegin !== undefined) {
                this.callbacks.onManipulationBegin = callbacks.onManipulationBegin;
            }
            if (callbacks.onManipulationEnd !== undefined) {
                this.callbacks.onManipulationEnd = callbacks.onManipulationEnd;
            }
            if (callbacks.onChange !== undefined) {
                this.callbacks.onChange = callbacks.onChange;
            }
        }
    }
    /**
     * The `x`-coordinate of the component. Defined through the `regionaData`.
     */
    get x() {
        return this.regionData.x;
    }
    /**
     * The `y`-coordinate of the component. Defined through the `regionaData`.
     */
    get y() {
        return this.regionData.y;
    }
    /**
     * The `width` of the component. Defined through the `regionaData`.
     */
    get width() {
        return this.regionData.boundRect.width;
    }
    /**
     * The `height` of the component. Defined through the `regionaData`.
     */
    get height() {
        return this.regionData.boundRect.height;
    }
    /**
     * The `area` of the component. Defined through the `regionaData`.
     */
    get area() {
        return this.regionData.area;
    }
    /**
     * The `boundRect` of the component. Defined through the `regionaData`.
     * @remarks Returns the `Rect` object of the same `width` and `height` as the component.
     */
    get boundRect() {
        return this.regionData.boundRect;
    }
    /**
     * Switches the component presentstion to the hidden state.
     */
    hide() {
        this.node.node.setAttribute("visibility", "hidden");
        this.isVisible = false;
    }
    /**
     * Switches the component presentation to the visibile state.
     */
    show() {
        this.node.node.setAttribute("visibility", "visible");
        this.isVisible = true;
    }
    /**
     * Selects the component.
     */
    select() {
        this.isSelected = true;
        this.node.addClass("selected");
    }
    /**
     * Unselecets the component.
     */
    unselect() {
        this.isSelected = false;
        this.node.removeClass("selected");
    }
    /**
     * Switches the component to the frozen state.
     */
    freeze() {
        this.isFrozen = true;
    }
    /**
     * Switches the component to the unfrozen state.
     */
    unfreeze() {
        this.isFrozen = false;
    }
    move(arg1, arg2) {
        this.regionData.move(arg1, arg2);
        this.redraw();
    }
    /**
     * Resizes the component to specified `width` and `height`.
     * @param width - The new `width` for the component.
     * @param height - The new `height` for the component.
     */
    resize(width, height) {
        this.regionData.resize(width, height);
        this.redraw();
    }
    /**
     * Resizes the bounding box for the component.
     * @param width - The new `width` of the bounding box.
     * @param height - The new `height` of the bounding box.
     */
    resizePaper(width, height) {
        this.paperRect.resize(width, height);
    }
    /**
     * The wrapper around external `onChange` callback. Checks whether the callback is defined.
     * @param region - Reference to the component.
     * @param regionData - The `RegionData` object to be passed.
     * @param eventType - The event type.
     * @param multiSelection - The flag for multiple regions selection.
     */
    onChange(region, regionData, eventType, multiSelection) {
        if (this.callbacks.onChange !== null && this.callbacks.onChange !== undefined) {
            this.callbacks.onChange(region, regionData, eventType, multiSelection);
        }
    }
    /**
     * The wrapper around external `onManipulationBegin` callback. Checks whether the callback is defined.
     * @param region - Reference to the component.
     */
    onManipulationBegin(region) {
        if (this.callbacks.onManipulationBegin !== null && this.callbacks.onManipulationBegin !== undefined) {
            this.callbacks.onManipulationBegin(region);
        }
    }
    /**
     * The wrapper around external `onManupulationEnd` callback. Checks whether the callback is defined.
     * @param region - Reference to the component.
     */
    onManipulationEnd(region) {
        if (this.callbacks.onManipulationEnd !== null && this.callbacks.onManipulationEnd !== undefined) {
            this.callbacks.onManipulationEnd(region);
        }
    }
    /**
     * Subscrubes the component elements according to provided event descriptors. Binds to the `this` object.
     * @param listeners - The collection of event descriptors.
     */
    subscribeToEvents(listeners) {
        listeners.forEach((e) => {
            e.base.addEventListener(e.event, this.makeFreezable(e.listener.bind(this), e.bypass));
        });
    }
    /**
     * A helper function to make event listeners froozen if the component state is frozen.
     * @param f - Function to wrap.
     * @param bypass - A flag whether event should bypass.
     */
    makeFreezable(f, bypass = false) {
        return (args) => {
            if (!this.isFrozen || bypass) {
                f(args);
            }
        };
    }
}
exports.RegionComponent = RegionComponent;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Component/TagsComponent.ts":
/*!**************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Component/TagsComponent.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RegionComponent_1 = __webpack_require__(/*! ./RegionComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts");
/**
 * An abstract visual component used internall do draw tags data for regions.
 */
class TagsComponent extends RegionComponent_1.RegionComponent {
    /**
     * Creates a new `TagsComponent` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param tags - The `TagsDescriptor` object presenting colors and names for region tags.
     * @param styleId - The unique css style id for region.
     * @param styleSheet - The regerence to the stylesheet object for rules insection.
     * @param tagsUpdateOptions - The settings for redrawing tags.
     */
    constructor(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions) {
        super(paper, paperRect, regionData, null);
        /**
         * Reference to the stylesheet element.
         */
        this.styleSheet = null;
        /**
         * Default styling rules.
         */
        this.styleMap = [];
        /**
         * Light styling rules used when `showRegionBackground` is set to `false`.
         */
        this.styleLightMap = [];
        this.styleId = styleId;
        this.styleSheet = styleSheet;
        this.tags = tags;
        this.tagsUpdateOptions = tagsUpdateOptions;
        this.node = paper.g();
        this.node.addClass("tagsLayer");
    }
    /**
     * Updates component with new `TagsDescriptor` object and new drawing settings.
     * @param tags - The new `TagsDescriptor` object.
     * @param options - The new drawing settings.
     */
    updateTags(tags, options) {
        this.tags = tags;
        this.tagsUpdateOptions = options;
        this.rebuildTagLabels();
        this.clearStyleMaps();
        this.initStyleMaps(tags);
        const showBackground = (options !== undefined) ? options.showRegionBackground : true;
        this.applyStyleMaps(showBackground);
    }
    /**
     * Clears current styling rules.
     */
    clearStyleMaps() {
        while (this.styleSheet.cssRules.length > 0) {
            this.styleSheet.deleteRule(0);
        }
    }
    /**
     * Inserts the styling rules into the `styleSheet` object.
     * @param showRegionBackground - The flag to make background visible or transparent.
     */
    applyStyleMaps(showRegionBackground = true) {
        // Map primary tag color
        if (this.tags && this.tags.primary !== undefined) {
            window.requestAnimationFrame(() => {
                const sm = (showRegionBackground ? this.styleMap : this.styleLightMap);
                for (const r of sm) {
                    this.styleSheet.insertRule(`${r.rule}{${r.style}}`, 0);
                }
            });
        }
    }
}
exports.TagsComponent = TagsComponent;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Point/DragElement.ts":
/*!********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Point/DragElement.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DragComponent_1 = __webpack_require__(/*! ../Component/DragComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/DragComponent.ts");
/**
 * `DragComponent` for the `PointRegion` class.
 */
class DragElement extends DragComponent_1.DragComponent {
    /**
     * Creates a new `DragElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        this.dragNode = paper.circle(this.x, this.y, DragElement.DEFAULT_DRAG_RADIUS);
        this.dragNode.addClass("dragPointStyle");
        this.node.add(this.dragNode);
        this.subscribeToDragEvents();
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        window.requestAnimationFrame(() => {
            this.dragNode.attr({
                cx: this.x,
                cy: this.y,
            });
        });
    }
}
/**
 * Default (visual) radius for point drag-component.
 */
DragElement.DEFAULT_DRAG_RADIUS = 6;
exports.DragElement = DragElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Point/PointRegion.ts":
/*!********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Point/PointRegion.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Region_1 = __webpack_require__(/*! ../Region */ "./src/canvastools/ts/CanvasTools/Region/Region.ts");
const DragElement_1 = __webpack_require__(/*! ./DragElement */ "./src/canvastools/ts/CanvasTools/Region/Point/DragElement.ts");
const TagsElement_1 = __webpack_require__(/*! ./TagsElement */ "./src/canvastools/ts/CanvasTools/Region/Point/TagsElement.ts");
/**
 * The point-type region class.
 */
class PointRegion extends Region_1.Region {
    /**
     * Creates new `PointRegion` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     * @param id - The region `id` used to identify regions in `RegionsManager`.
     * @param tagsDescriptor - The descriptor of region tags.
     * @param tagsUpdateOptions - The drawing options for tags.
     */
    constructor(paper, paperRect = null, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions) {
        super(paper, paperRect, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions);
        this.buildOn(paper);
    }
    /**
     * Updates region tags.
     * @param tags - The new tags descriptor object.
     * @param options - The tags drawing options.
     */
    updateTags(tags, options) {
        super.updateTags(tags, options);
        this.tagsNode.updateTags(tags, options);
        this.node.select("title").node.innerHTML = (tags !== null) ? tags.toString() : "";
    }
    /**
     * Creates the UI of the region component.
     * @param paper - The `Snap.Paper` element to draw on.
     */
    buildOn(paper) {
        this.node = paper.g();
        this.node.addClass("regionStyle");
        this.node.addClass(this.styleID);
        const callbacks = {
            onChange: this.onChange.bind(this),
            onManipulationBegin: this.onManipulationBegin.bind(this),
            onManipulationEnd: this.onManipulationEnd.bind(this),
        };
        this.dragNode = new DragElement_1.DragElement(paper, this.paperRect, this.regionData, callbacks);
        this.tagsNode = new TagsElement_1.TagsElement(paper, this.paperRect, this.regionData, this.tags, this.styleID, this.styleSheet, this.tagsUpdateOptions);
        this.toolTip = Snap.parse(`<title>${(this.tags !== null) ? this.tags.toString() : ""}</title>`);
        this.node.append(this.toolTip);
        this.node.add(this.dragNode.node);
        this.node.add(this.tagsNode.node);
        this.UI.push(this.tagsNode, this.dragNode);
    }
}
exports.PointRegion = PointRegion;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Point/TagsElement.ts":
/*!********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Point/TagsElement.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TagsComponent_1 = __webpack_require__(/*! ../Component/TagsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/TagsComponent.ts");
/**
 * `TagsComponent` for the `PointRegion` class.
 */
class TagsElement extends TagsComponent_1.TagsComponent {
    /**
     * Creates a new `TagsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param tags - The `TagsDescriptor` object presenting colors and names for region tags.
     * @param styleId - The unique css style id for region.
     * @param styleSheet - The regerence to the stylesheet object for rules insection.
     * @param tagsUpdateOptions - The settings for redrawing tags.
     */
    constructor(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions) {
        super(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions);
        this.buildOn(paper, tags);
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        const size = TagsElement.DEFAULT_SECONDARY_TAG_SIZE;
        const cx = this.x;
        const cy = this.y - size - TagsElement.DEFAULT_SECONDARY_TAG_DY;
        window.requestAnimationFrame(() => {
            this.primaryTagNode.attr({
                cx: this.x,
                cy: this.y,
            });
            // Secondary Tags
            if (this.secondaryTags && this.secondaryTags.length > 0) {
                const length = this.secondaryTags.length;
                for (let i = 0; i < length; i++) {
                    const stag = this.secondaryTags[i];
                    const x = cx + (2 * i - length + 0.5) * size;
                    stag.attr({
                        x,
                        y: cy,
                    });
                }
            }
        });
    }
    /**
     * Inits style maps.
     */
    initStyleMaps(tags) {
        if (tags !== null) {
            if (tags.primary !== null) {
                this.styleMap = [
                    {
                        rule: `.${this.styleId} .primaryTagPointStyle`,
                        style: `fill: ${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover  .primaryTagPointStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                    stroke: #fff;`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagPointStyle`,
                        style: `fill: ${tags.primary.colorAccent};
                                stroke:${tags.primary.colorHighlight};`,
                    },
                ];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagPointStyle`,
                        style: `fill: ${tags.primary.colorNoColor};
                                stroke:${tags.primary.colorAccent};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover  .primaryTagPointStyle`,
                        style: `stroke:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagPointStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .secondaryTagStyle`,
                        style: `opacity:0.25;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .dragPointStyle`,
                        style: `opacity:0.25;`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .dragPointStyle`,
                        style: `opacity:0.5;`,
                    },
                ];
            }
            else {
                this.styleMap = [];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagPointStyle`,
                        style: `fill: var(--default-color-transparent);
                                stroke: var(--default-color-pure);
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .dragPointStyle`,
                        style: `opacity:0.25;`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .dragPointStyle`,
                        style: `opacity:0.5;`,
                    },
                ];
            }
            if (tags.secondary !== null && tags.secondary !== undefined) {
                tags.secondary.forEach((tag) => {
                    const rule = {
                        rule: `.secondaryTagStyle.secondaryTag-${tag.name}`,
                        style: `fill: ${tag.colorAccent};`,
                    };
                    this.styleMap.push(rule);
                    this.styleLightMap.push(rule);
                });
            }
        }
    }
    /**
     * Internal function to recreate tag labels.
     */
    rebuildTagLabels() {
        // Clear secondary tags -> redraw from scratch
        for (const tag of this.secondaryTags) {
            tag.remove();
        }
        this.secondaryTags = [];
        // If there are tags assigned
        if (this.tags) {
            if (this.tags.primary !== undefined && this.tags.primary !== null) {
                // Primary Tag
            }
            // Secondary Tags
            if (this.tags.secondary && this.tags.secondary.length > 0) {
                const length = this.tags.secondary.length;
                for (let i = 0; i < length; i++) {
                    const stag = this.tags.secondary[i];
                    const size = TagsElement.DEFAULT_SECONDARY_TAG_SIZE;
                    const x = this.x + this.boundRect.width / 2 + (2 * i - length + 1) * size - size / 2;
                    const y = this.y - size - TagsElement.DEFAULT_SECONDARY_TAG_DY;
                    const tagel = this.paper.rect(x, y, size, size);
                    window.requestAnimationFrame(() => {
                        tagel.addClass("secondaryTagStyle");
                        tagel.addClass(`secondaryTag-${stag.name}`);
                    });
                    this.secondaryTagsNode.add(tagel);
                    this.secondaryTags.push(tagel);
                }
            }
        }
    }
    /**
     * Internal function to create tag labels
     * @param paper - The `Snap.Paper` object to draw on.
     * @param tags - The `TagsDescriptor` object defining tags.
     */
    buildOn(paper, tags) {
        this.primaryTagNode = paper.circle(this.x, this.y, TagsElement.DEFAULT_PRIMARY_TAG_RADIUS);
        this.primaryTagNode.addClass("primaryTagPointStyle");
        this.secondaryTagsNode = paper.g();
        this.secondaryTagsNode.addClass("secondatyTagsLayer");
        this.secondaryTags = [];
        this.node.add(this.primaryTagNode);
        this.node.add(this.secondaryTagsNode);
        this.initStyleMaps(tags);
        this.updateTags(tags, this.tagsUpdateOptions);
    }
}
/**
 * Default (visual) radius for primary tag point.
 */
TagsElement.DEFAULT_PRIMARY_TAG_RADIUS = 3;
/**
 * Default (visual) size for secondary tag boxes.
 */
TagsElement.DEFAULT_SECONDARY_TAG_SIZE = 6;
/**
 * Default (visual) vertical shift for secondary tag boxes.
 */
TagsElement.DEFAULT_SECONDARY_TAG_DY = 6;
exports.TagsElement = TagsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polygon/AnchorsElement.ts":
/*!*************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polygon/AnchorsElement.ts ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const IRegionCallbacks_1 = __webpack_require__(/*! ../../Interface/IRegionCallbacks */ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts");
const AnchorsComponent_1 = __webpack_require__(/*! ../Component/AnchorsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/AnchorsComponent.ts");
/**
 * `AnchorsComponent` for the `PolygonRegion` class.
 */
class AnchorsElement extends AnchorsComponent_1.AnchorsComponent {
    /**
     * Creates a new `AnchorsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * Internal flag to delete a point on pointer up event.
         */
        this.deleteOnPointerUp = false;
        /**
         * Internal flat to add a point on pointer up event.
         */
        this.addOnPointerUp = false;
        this.anchorsLength = regionData.points.length;
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        if (this.regionData.points !== null && this.regionData.points.length > 0) {
            const points = this.regionData.points;
            // rebuild anchors
            if (this.anchorsLength !== points.length) {
                window.requestAnimationFrame(() => {
                    this.anchors.forEach((anchor) => {
                        anchor.remove();
                    });
                    this.anchors = [];
                    this.buildPointAnchors();
                });
                this.anchorsLength = points.length;
            }
            else {
                window.requestAnimationFrame(() => {
                    this.regionData.points.forEach((p, index) => {
                        this.anchors[index].attr({
                            cx: p.x,
                            cy: p.y,
                        });
                    });
                });
            }
            const pointsData = [];
            this.regionData.points.forEach((p) => {
                pointsData.push(p.x, p.y);
            });
            this.anchorsPolyline.attr({
                points: pointsData.toString(),
            });
        }
    }
    /**
     * Creates a collection on anchors.
     */
    buildAnchors() {
        this.buildPolylineAnchors();
        this.buildPointAnchors();
    }
    /**
     * Creates a collection of anchor points.
     */
    buildPolylineAnchors() {
        const pointsData = [];
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        this.anchorsPolyline = this.paper.polyline(pointsData);
        this.anchorsPolyline.addClass("anchorLineStyle");
        this.subscribeLineToEvents(this.anchorsPolyline);
        this.anchorsNode.add(this.anchorsPolyline);
    }
    /**
     * Subscribe an anchor to events.
     * @param anchor - The anchor to wire up with events.
     */
    subscribeLineToEvents(anchor) {
        anchor.node.addEventListener("pointermove", (e) => {
            if (!this.isFrozen) {
                if (e.ctrlKey) {
                    this.dragOrigin = new Point2D_1.Point2D(e.offsetX, e.offsetY);
                    this.activeAnchorIndex = -1;
                    this.addOnPointerUp = true;
                    window.requestAnimationFrame(() => {
                        this.ghostAnchor.attr({
                            cx: this.dragOrigin.x,
                            cy: this.dragOrigin.y,
                            display: "block",
                        });
                    });
                }
                else {
                    this.addOnPointerUp = false;
                }
                this.onManipulationBegin();
            }
        }, false);
    }
    /**
     * Updated the `regionData` based on the new ghost anchor location. Should be redefined in child classes.
     * @param p - The new ghost anchor location.
     */
    updateRegion(p) {
        const rd = this.regionData.copy();
        if (this.activeAnchorIndex >= 0 && this.activeAnchorIndex < this.regionData.points.length) {
            rd.setPoint(p, this.activeAnchorIndex);
        }
        this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
    }
    /**
     * Callback for the pointerenter event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerEnter(e) {
        if (e.ctrlKey) {
            if (this.addOnPointerUp && this.activeAnchorIndex < 0) {
                this.ghostAnchor.addClass("add");
            }
            else if (this.regionData.points.length > 2) {
                this.ghostAnchor.addClass("delete");
                this.deleteOnPointerUp = true;
                this.addOnPointerUp = false;
            }
        }
        else {
            this.ghostAnchor.removeClass("delete");
            this.ghostAnchor.removeClass("add");
            this.deleteOnPointerUp = false;
        }
        this.ghostAnchor.drag(this.anchorDragMove.bind(this), this.anchorDragBegin.bind(this), this.anchorDragEnd.bind(this));
        this.onManipulationBegin();
    }
    /**
     * Callback for the pointermove event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerMove(e) {
        if (e.ctrlKey) {
            const p = new Point2D_1.Point2D(e.offsetX, e.offsetY);
            let dist = Number.MAX_VALUE;
            let nearestPoint = null;
            let index = -1;
            this.regionData.points.forEach((point, i) => {
                const d = p.squareDistanceToPoint(point);
                if (d < dist) {
                    dist = d;
                    nearestPoint = point;
                    index = i;
                }
            });
            const swapToDelete = dist < AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD;
            if (this.addOnPointerUp && this.activeAnchorIndex < 0 && !swapToDelete) {
                this.ghostAnchor.addClass("add");
                window.requestAnimationFrame(() => {
                    this.ghostAnchor.attr({
                        cx: p.x,
                        cy: p.y,
                    });
                });
            }
            else if (this.regionData.points.length > 2 || swapToDelete) {
                this.ghostAnchor.removeClass("add");
                this.ghostAnchor.addClass("delete");
                this.activeAnchorIndex = index;
                window.requestAnimationFrame(() => {
                    this.ghostAnchor.attr({
                        cx: nearestPoint.x,
                        cy: nearestPoint.y,
                    });
                });
                this.deleteOnPointerUp = true;
                this.addOnPointerUp = false;
            }
        }
        else {
            this.ghostAnchor.removeClass("delete");
            this.ghostAnchor.removeClass("add");
            this.deleteOnPointerUp = false;
            this.addOnPointerUp = false;
        }
    }
    /**
     * Callback for the pointerup event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerUp(e) {
        this.ghostAnchor.node.releasePointerCapture(e.pointerId);
        const rd = this.regionData.copy();
        if (this.deleteOnPointerUp) {
            if (this.activeAnchorIndex >= 0 && this.activeAnchorIndex < this.regionData.points.length) {
                const points = rd.points;
                points.splice(this.activeAnchorIndex, 1);
                rd.setPoints(points);
            }
            this.deleteOnPointerUp = false;
            this.addOnPointerUp = false;
            this.ghostAnchor.removeClass("delete");
            this.ghostAnchor.removeClass("add");
        }
        else if (this.addOnPointerUp) {
            const point = new Point2D_1.Point2D(e.offsetX, e.offsetY);
            const points = rd.points;
            // Find the nearest segment of polyline
            let index = 0;
            let distance = Number.MAX_VALUE;
            for (let i = 0; i < points.length - 1; i++) {
                const d = this.dragOrigin.squareDistanceToLine(points[i], points[i + 1]);
                if (d < distance) {
                    index = i;
                    distance = d;
                }
            }
            points.splice(index + 1, 0, point);
            rd.setPoints(points);
            this.deleteOnPointerUp = false;
            this.addOnPointerUp = false;
            this.ghostAnchor.addClass("delete");
        }
        this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVEEND);
    }
}
/**
 * Default threshold distance to define whether ctrl-pointer click is on point or line.
 */
AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD = 5;
exports.AnchorsElement = AnchorsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polygon/DragElement.ts":
/*!**********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polygon/DragElement.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DragComponent_1 = __webpack_require__(/*! ../Component/DragComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/DragComponent.ts");
/**
 * `DragComponent` for the `PolygonRegion` class.
 */
class DragElement extends DragComponent_1.DragComponent {
    /**
     * Creates a new `DragElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        this.dragNode = paper.rect(this.x, this.y, this.width, this.height);
        this.dragNode.addClass("dragRectStyle");
        this.node.add(this.dragNode);
        this.subscribeToDragEvents();
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        window.requestAnimationFrame(() => {
            this.dragNode.attr({
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
            });
        });
    }
}
exports.DragElement = DragElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polygon/PolygonRegion.ts":
/*!************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polygon/PolygonRegion.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rect_1 = __webpack_require__(/*! ../../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const Region_1 = __webpack_require__(/*! ../Region */ "./src/canvastools/ts/CanvasTools/Region/Region.ts");
const AnchorsElement_1 = __webpack_require__(/*! ./AnchorsElement */ "./src/canvastools/ts/CanvasTools/Region/Polygon/AnchorsElement.ts");
const DragElement_1 = __webpack_require__(/*! ./DragElement */ "./src/canvastools/ts/CanvasTools/Region/Polygon/DragElement.ts");
const TagsElement_1 = __webpack_require__(/*! ./TagsElement */ "./src/canvastools/ts/CanvasTools/Region/Polygon/TagsElement.ts");
/**
 * The polygon-type region class.
 */
class PolygonRegion extends Region_1.Region {
    /**
     * Creates new `PolygonRegion` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     * @param id - The region `id` used to identify regions in `RegionsManager`.
     * @param tagsDescriptor - The descriptor of region tags.
     * @param tagsUpdateOptions - The drawing options for tags.
     */
    constructor(paper, paperRect = null, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions) {
        super(paper, paperRect, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions);
        if (paperRect !== null) {
            this.paperRects = {
                actual: new Rect_1.Rect(paperRect.width - regionData.width, paperRect.height - regionData.height),
                host: paperRect,
            };
        }
        this.buildOn(paper);
    }
    /**
     * The callback function fot internal components.
     * @param component - Reference to the UI component.
     * @param regionData - New RegionData object.
     * @param state - New state of the region.
     * @param multiSelection - Flag for multiselection.
     */
    onChange(component, regionData, state, multiSelection = false) {
        this.paperRects.actual.resize(this.paperRects.host.width - regionData.width, this.paperRects.host.height - regionData.height);
        super.onChange(component, regionData, state, multiSelection);
    }
    /**
     * Updates region tags.
     * @param tags - The new tags descriptor object.
     * @param options - The tags drawing options.
     */
    updateTags(tags, options) {
        super.updateTags(tags, options);
        this.tagsNode.updateTags(tags, options);
        this.node.select("title").node.innerHTML = (tags !== null) ? tags.toString() : "";
    }
    /**
     * Resizes the region to specified `width` and `height`.
     * @param width - The new region width.
     * @param height - The new region height.
     */
    resize(width, height) {
        this.paperRects.actual.resize(this.paperRects.host.width - width, this.paperRects.host.height - height);
        super.resize(width, height);
    }
    /**
     * Creates the UI of the region component.
     * @param paper - The `Snap.Paper` element to draw on.
     */
    buildOn(paper) {
        this.node = paper.g();
        this.node.addClass("regionStyle");
        this.node.addClass(this.styleID);
        const callbacks = {
            onChange: this.onChange.bind(this),
            onManipulationBegin: this.onManipulationBegin.bind(this),
            onManipulationEnd: this.onManipulationEnd.bind(this),
        };
        this.dragNode = new DragElement_1.DragElement(paper, this.paperRects.actual, this.regionData, callbacks);
        this.tagsNode = new TagsElement_1.TagsElement(paper, this.paperRect, this.regionData, this.tags, this.styleID, this.styleSheet, this.tagsUpdateOptions);
        this.anchorNode = new AnchorsElement_1.AnchorsElement(paper, this.paperRect, this.regionData, callbacks);
        this.toolTip = Snap.parse(`<title>${(this.tags !== null) ? this.tags.toString() : ""}</title>`);
        this.node.append(this.toolTip);
        this.node.add(this.dragNode.node);
        this.node.add(this.tagsNode.node);
        this.node.add(this.anchorNode.node);
        this.UI.push(this.tagsNode, this.dragNode, this.anchorNode);
    }
}
exports.PolygonRegion = PolygonRegion;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polygon/TagsElement.ts":
/*!**********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polygon/TagsElement.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TagsComponent_1 = __webpack_require__(/*! ../Component/TagsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/TagsComponent.ts");
/**
 * `TagsComponent` for the `PolygonRegion` class.
 */
class TagsElement extends TagsComponent_1.TagsComponent {
    /**
     * Creates a new `TagsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param tags - The `TagsDescriptor` object presenting colors and names for region tags.
     * @param styleId - The unique css style id for region.
     * @param styleSheet - The regerence to the stylesheet object for rules insection.
     * @param tagsUpdateOptions - The settings for redrawing tags.
     */
    constructor(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions) {
        super(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions);
        this.buildOn(paper, tags);
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        const pointsData = [];
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        const size = TagsElement.DEFAULT_SECONDARY_TAG_SIZE;
        const cx = this.x + this.width / 2;
        const cy = this.y - size - 5;
        window.requestAnimationFrame(() => {
            this.primaryTagBoundRect.attr({
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
            });
            this.primaryTagPolygon.attr({
                points: pointsData.toString(),
            });
            // Secondary Tags
            if (this.secondaryTags && this.secondaryTags.length > 0) {
                const length = this.secondaryTags.length;
                for (let i = 0; i < length; i++) {
                    const stag = this.secondaryTags[i];
                    const x = cx + (2 * i - length + 0.5) * size;
                    stag.attr({
                        x,
                        y: cy,
                    });
                }
            }
        });
    }
    /**
     * Inits style maps.
     */
    initStyleMaps(tags) {
        if (tags !== null) {
            if (tags.primary !== null) {
                this.styleMap = [
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: ${tags.primary.colorShadow};
                                stroke: ${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};`,
                    },
                    {
                        rule: `.${this.styleId}:hover .primaryTagBoundRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagPolygonStyle`,
                        style: `fill: ${tags.primary.colorShadow};
                                stroke: ${tags.primary.colorPure};`,
                    },
                    {
                        rule: `.${this.styleId}:hover .primaryTagPolygonStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke: ${tags.primary.colorPure};`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagPolygonStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke: ${tags.primary.colorPure};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke:${tags.primary.colorDark};
                                fill: ${tags.primary.colorPure}`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .anchorStyle`,
                        style: `stroke:#fff;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `fill:transparent;`,
                    },
                ];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: none;
                                stroke: ${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagPolygonStyle`,
                        style: `fill: ${tags.primary.colorNoColor};
                                stroke: ${tags.primary.colorPure};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .primaryTagPolygonStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke: ${tags.primary.colorPure};`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagPolygonStyle`,
                        style: `fill: ${tags.primary.colorNoColor};
                                stroke: ${tags.primary.colorPure};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke:${tags.primary.colorDark};
                                fill: ${tags.primary.colorPure};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .anchorStyle`,
                        style: `stroke:#fff;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `fill:transparent;
                                stroke-width: 0px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .secondaryTagStyle`,
                        style: `opacity:0.25;`,
                    },
                ];
            }
            else {
                this.styleMap = [];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagPolygonStyle`,
                        style: `fill: var(--default-color-transparent);`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagPolygonStyle`,
                        style: `fill: var(--default-color-transparent);`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: none;`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagPolylineStyle`,
                        style: `stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `stroke-width: 0px;`,
                    },
                ];
            }
            if (tags.secondary !== null && tags.secondary !== undefined) {
                tags.secondary.forEach((tag) => {
                    const rule = {
                        rule: `.secondaryTagStyle.secondaryTag-${tag.name}`,
                        style: `fill: ${tag.colorAccent};`,
                    };
                    this.styleMap.push(rule);
                    this.styleLightMap.push(rule);
                });
            }
        }
    }
    /**
     * Internal function to recreate tag labels.
     */
    rebuildTagLabels() {
        // Clear secondary tags -> redraw from scratch
        for (const tag of this.secondaryTags) {
            tag.remove();
        }
        this.secondaryTags = [];
        // If there are tags assigned
        if (this.tags) {
            if (this.tags.primary !== undefined && this.tags.primary !== null) {
                // Primary Tag
            }
            // Secondary Tags
            if (this.tags.secondary && this.tags.secondary.length > 0) {
                const length = this.tags.secondary.length;
                for (let i = 0; i < length; i++) {
                    const stag = this.tags.secondary[i];
                    const s = TagsElement.DEFAULT_SECONDARY_TAG_SIZE;
                    const x = this.x + this.boundRect.width / 2 + (2 * i - length + 1) * s - s / 2;
                    const y = this.y - s - 5;
                    const tagel = this.paper.rect(x, y, s, s);
                    window.requestAnimationFrame(() => {
                        tagel.addClass("secondaryTagStyle");
                        tagel.addClass(`secondaryTag-${stag.name}`);
                    });
                    this.secondaryTagsNode.add(tagel);
                    this.secondaryTags.push(tagel);
                }
            }
        }
    }
    /**
     * Internal function to create tag labels
     * @param paper - The `Snap.Paper` object to draw on.
     * @param tags - The `TagsDescriptor` object defining tags.
     */
    buildOn(paper, tags) {
        this.primaryTagNode = paper.g();
        this.primaryTagBoundRect = paper.rect(this.x, this.y, this.boundRect.width, this.boundRect.height);
        this.primaryTagBoundRect.addClass("primaryTagBoundRectStyle");
        const pointsData = [];
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        this.primaryTagPolygon = paper.polygon(pointsData);
        this.primaryTagPolygon.addClass("primaryTagPolygonStyle");
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        this.primaryTagNode.add(this.primaryTagBoundRect);
        this.primaryTagNode.add(this.primaryTagPolygon);
        this.secondaryTagsNode = paper.g();
        this.secondaryTagsNode.addClass("secondatyTagsLayer");
        this.secondaryTags = [];
        this.node.add(this.primaryTagNode);
        this.node.add(this.secondaryTagsNode);
        this.initStyleMaps(tags);
        this.updateTags(tags, this.tagsUpdateOptions);
    }
}
/**
 * Default (visual) radius for primary tag point.
 */
TagsElement.DEFAULT_PRIMARY_TAG_RADIUS = 3;
/**
 * Default (visual) size for secondary tag boxes.
 */
TagsElement.DEFAULT_SECONDARY_TAG_SIZE = 6;
/**
 * Default (visual) vertical shift for secondary tag boxes.
 */
TagsElement.DEFAULT_SECONDARY_TAG_DY = 6;
exports.TagsElement = TagsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polyline/AnchorsElement.ts":
/*!**************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polyline/AnchorsElement.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const IRegionCallbacks_1 = __webpack_require__(/*! ../../Interface/IRegionCallbacks */ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts");
const AnchorsComponent_1 = __webpack_require__(/*! ../Component/AnchorsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/AnchorsComponent.ts");
/**
 * `AnchorsComponent` for the `PolylineRegion` class.
 */
class AnchorsElement extends AnchorsComponent_1.AnchorsComponent {
    /**
     * Creates a new `AnchorsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * Internal flag to delete a point on pointer up event.
         */
        this.deleteOnPointerUp = false;
        /**
         * Internal flat to add a point on pointer up event.
         */
        this.addOnPointerUp = false;
        this.anchorsLength = regionData.points.length;
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        if (this.regionData.points !== null && this.regionData.points.length > 0) {
            const points = this.regionData.points;
            // rebuild anchors
            if (this.anchorsLength !== points.length) {
                window.requestAnimationFrame(() => {
                    this.anchors.forEach((anchor) => {
                        anchor.remove();
                    });
                    this.anchors = [];
                    this.buildPointAnchors();
                });
                this.anchorsLength = points.length;
            }
            else {
                window.requestAnimationFrame(() => {
                    this.regionData.points.forEach((p, index) => {
                        this.anchors[index].attr({
                            cx: p.x,
                            cy: p.y,
                        });
                    });
                });
            }
            const pointsData = [];
            this.regionData.points.forEach((p) => {
                pointsData.push(p.x, p.y);
            });
            this.anchorsPolyline.attr({
                points: pointsData.toString(),
            });
        }
    }
    /**
     * Creates a collection on anchors.
     */
    buildAnchors() {
        this.buildPolylineAnchors();
        this.buildPointAnchors();
    }
    /**
     * Creates acollection of anchor points.
     */
    buildPolylineAnchors() {
        const pointsData = [];
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        this.anchorsPolyline = this.paper.polyline(pointsData);
        this.anchorsPolyline.addClass("anchorLineStyle");
        this.subscribeLineToEvents(this.anchorsPolyline);
        this.anchorsNode.add(this.anchorsPolyline);
    }
    /**
     * Subscribe an anchor to events.
     * @param anchor - The anchor to wire up with events.
     */
    subscribeLineToEvents(anchor) {
        anchor.node.addEventListener("pointermove", (e) => {
            if (!this.isFrozen) {
                if (e.ctrlKey) {
                    this.dragOrigin = new Point2D_1.Point2D(e.offsetX, e.offsetY);
                    this.activeAnchorIndex = -1;
                    this.addOnPointerUp = true;
                    window.requestAnimationFrame(() => {
                        this.ghostAnchor.attr({
                            cx: this.dragOrigin.x,
                            cy: this.dragOrigin.y,
                            display: "block",
                        });
                    });
                }
                else {
                    this.addOnPointerUp = false;
                }
                this.onManipulationBegin();
            }
        }, false);
    }
    /**
     * Updated the `regionData` based on the new ghost anchor location. Should be redefined in child classes.
     * @param p - The new ghost anchor location.
     */
    updateRegion(p) {
        const rd = this.regionData.copy();
        if (this.activeAnchorIndex >= 0 && this.activeAnchorIndex < this.regionData.points.length) {
            rd.setPoint(p, this.activeAnchorIndex);
        }
        this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
    }
    /**
     * Callback for the pointerenter event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerEnter(e) {
        if (e.ctrlKey) {
            if (this.addOnPointerUp && this.activeAnchorIndex < 0) {
                this.ghostAnchor.addClass("add");
            }
            else if (this.regionData.points.length > 2) {
                this.ghostAnchor.addClass("delete");
                this.deleteOnPointerUp = true;
                this.addOnPointerUp = false;
            }
        }
        else {
            this.ghostAnchor.removeClass("delete");
            this.ghostAnchor.removeClass("add");
            this.deleteOnPointerUp = false;
        }
        this.ghostAnchor.drag(this.anchorDragMove.bind(this), this.anchorDragBegin.bind(this), this.anchorDragEnd.bind(this));
        this.onManipulationBegin();
    }
    /**
     * Callback for the pointermove event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerMove(e) {
        if (e.ctrlKey) {
            const p = new Point2D_1.Point2D(e.offsetX, e.offsetY);
            let dist = Number.MAX_VALUE;
            let nearestPoint = null;
            let index = -1;
            this.regionData.points.forEach((point, i) => {
                const d = p.squareDistanceToPoint(point);
                if (d < dist) {
                    dist = d;
                    nearestPoint = point;
                    index = i;
                }
            });
            const swapToDelete = dist < AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD;
            if (this.addOnPointerUp && this.activeAnchorIndex < 0 && !swapToDelete) {
                this.ghostAnchor.addClass("add");
                window.requestAnimationFrame(() => {
                    this.ghostAnchor.attr({
                        cx: p.x,
                        cy: p.y,
                    });
                });
            }
            else if (this.regionData.points.length > 2 || swapToDelete) {
                this.ghostAnchor.removeClass("add");
                this.ghostAnchor.addClass("delete");
                this.activeAnchorIndex = index;
                window.requestAnimationFrame(() => {
                    this.ghostAnchor.attr({
                        cx: nearestPoint.x,
                        cy: nearestPoint.y,
                    });
                });
                this.deleteOnPointerUp = true;
                this.addOnPointerUp = false;
            }
        }
        else {
            this.ghostAnchor.removeClass("delete");
            this.ghostAnchor.removeClass("add");
            this.deleteOnPointerUp = false;
            this.addOnPointerUp = false;
        }
    }
    /**
     * Callback for the pointerup event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerUp(e) {
        this.ghostAnchor.node.releasePointerCapture(e.pointerId);
        const rd = this.regionData.copy();
        if (this.deleteOnPointerUp) {
            if (this.activeAnchorIndex >= 0 && this.activeAnchorIndex < this.regionData.points.length) {
                const points = rd.points;
                points.splice(this.activeAnchorIndex, 1);
                rd.setPoints(points);
            }
            this.deleteOnPointerUp = false;
            this.addOnPointerUp = false;
            this.ghostAnchor.removeClass("delete");
            this.ghostAnchor.removeClass("add");
        }
        else if (this.addOnPointerUp) {
            const point = new Point2D_1.Point2D(e.offsetX, e.offsetY);
            const points = rd.points;
            // Find the nearest segment of polyline
            let index = 0;
            let distance = Number.MAX_VALUE;
            for (let i = 0; i < points.length - 1; i++) {
                const d = this.dragOrigin.squareDistanceToLine(points[i], points[i + 1]);
                if (d < distance) {
                    index = i;
                    distance = d;
                }
            }
            points.splice(index + 1, 0, point);
            rd.setPoints(points);
            this.deleteOnPointerUp = false;
            this.addOnPointerUp = false;
            this.ghostAnchor.addClass("delete");
        }
        this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVEEND);
    }
}
/**
 * Default threshold distance to define whether ctrl-pointer click is on point or line.
 */
AnchorsElement.ANCHOR_POINT_LINE_SWITCH_THRESHOLD = 5;
exports.AnchorsElement = AnchorsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polyline/DragElement.ts":
/*!***********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polyline/DragElement.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DragComponent_1 = __webpack_require__(/*! ../Component/DragComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/DragComponent.ts");
/**
 * `DragComponent` for the `PolylineRegion` class.
 */
class DragElement extends DragComponent_1.DragComponent {
    /**
     * Creates a new `DragElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        this.dragNode = paper.rect(this.x, this.y, this.width, this.height);
        this.dragNode.addClass("dragRectStyle");
        this.node.add(this.dragNode);
        this.subscribeToDragEvents();
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        window.requestAnimationFrame(() => {
            this.dragNode.attr({
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
            });
        });
    }
}
exports.DragElement = DragElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polyline/PolylineRegion.ts":
/*!**************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polyline/PolylineRegion.ts ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rect_1 = __webpack_require__(/*! ../../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const Region_1 = __webpack_require__(/*! ../Region */ "./src/canvastools/ts/CanvasTools/Region/Region.ts");
const AnchorsElement_1 = __webpack_require__(/*! ./AnchorsElement */ "./src/canvastools/ts/CanvasTools/Region/Polyline/AnchorsElement.ts");
const DragElement_1 = __webpack_require__(/*! ./DragElement */ "./src/canvastools/ts/CanvasTools/Region/Polyline/DragElement.ts");
const TagsElement_1 = __webpack_require__(/*! ./TagsElement */ "./src/canvastools/ts/CanvasTools/Region/Polyline/TagsElement.ts");
/**
 * The polyline-type region class.
 */
class PolylineRegion extends Region_1.Region {
    /**
     * Creates new `PolylineRegion` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     * @param id - The region `id` used to identify regions in `RegionsManager`.
     * @param tagsDescriptor - The descriptor of region tags.
     * @param tagsUpdateOptions - The drawing options for tags.
     */
    constructor(paper, paperRect = null, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions) {
        super(paper, paperRect, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions);
        if (paperRect !== null) {
            this.paperRects = {
                actual: new Rect_1.Rect(paperRect.width - regionData.width, paperRect.height - regionData.height),
                host: paperRect,
            };
        }
        this.buildOn(paper);
    }
    /**
     * The callback function fot internal components.
     * @param component - Reference to the UI component.
     * @param regionData - New RegionData object.
     * @param state - New state of the region.
     * @param multiSelection - Flag for multiselection.
     */
    onChange(component, regionData, state, multiSelection = false) {
        this.paperRects.actual.resize(this.paperRects.host.width - regionData.width, this.paperRects.host.height - regionData.height);
        super.onChange(component, regionData, state, multiSelection);
    }
    /**
     * Updates region tags.
     * @param tags - The new tags descriptor object.
     * @param options - The tags drawing options.
     */
    updateTags(tags, options) {
        super.updateTags(tags, options);
        this.tagsNode.updateTags(tags, options);
        this.node.select("title").node.innerHTML = (tags !== null) ? tags.toString() : "";
    }
    /**
     * Resizes the region to specified `width` and `height`.
     * @param width - The new region width.
     * @param height - The new region height.
     */
    resize(width, height) {
        this.paperRects.actual.resize(this.paperRects.host.width - width, this.paperRects.host.height - height);
        super.resize(width, height);
    }
    /**
     * Creates the UI of the region component.
     * @param paper - The `Snap.Paper` element to draw on.
     */
    buildOn(paper) {
        this.node = paper.g();
        this.node.addClass("regionStyle");
        this.node.addClass(this.styleID);
        const callbacks = {
            onChange: this.onChange.bind(this),
            onManipulationBegin: this.onManipulationBegin.bind(this),
            onManipulationEnd: this.onManipulationEnd.bind(this),
        };
        this.dragNode = new DragElement_1.DragElement(paper, this.paperRects.actual, this.regionData, callbacks);
        this.tagsNode = new TagsElement_1.TagsElement(paper, this.paperRect, this.regionData, this.tags, this.styleID, this.styleSheet, this.tagsUpdateOptions);
        this.anchorNode = new AnchorsElement_1.AnchorsElement(paper, this.paperRect, this.regionData, callbacks);
        this.toolTip = Snap.parse(`<title>${(this.tags !== null) ? this.tags.toString() : ""}</title>`);
        this.node.append(this.toolTip);
        this.node.add(this.dragNode.node);
        this.node.add(this.tagsNode.node);
        this.node.add(this.anchorNode.node);
        this.UI.push(this.tagsNode, this.dragNode, this.anchorNode);
    }
}
exports.PolylineRegion = PolylineRegion;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Polyline/TagsElement.ts":
/*!***********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Polyline/TagsElement.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TagsComponent_1 = __webpack_require__(/*! ../Component/TagsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/TagsComponent.ts");
/**
 * `TagsComponent` for the `PolylineRegion` class.
 */
class TagsElement extends TagsComponent_1.TagsComponent {
    /**
     * Creates a new `TagsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param tags - The `TagsDescriptor` object presenting colors and names for region tags.
     * @param styleId - The unique css style id for region.
     * @param styleSheet - The regerence to the stylesheet object for rules insection.
     * @param tagsUpdateOptions - The settings for redrawing tags.
     */
    constructor(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions) {
        super(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions);
        this.buildOn(paper, tags);
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        const pointsData = [];
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        const size = TagsElement.DEFAULT_SECONDARY_TAG_SIZE;
        const cx = this.x + this.width / 2;
        const cy = this.y - size - 5;
        window.requestAnimationFrame(() => {
            this.primaryTagBoundRect.attr({
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
            });
            this.primaryTagPolyline.attr({
                points: pointsData.toString(),
            });
            // Secondary Tags
            if (this.secondaryTags && this.secondaryTags.length > 0) {
                const length = this.secondaryTags.length;
                for (let i = 0; i < length; i++) {
                    const stag = this.secondaryTags[i];
                    const x = cx + (2 * i - length + 0.5) * size;
                    stag.attr({
                        x,
                        y: cy,
                    });
                }
            }
        });
    }
    /**
     * Inits style maps.
     */
    initStyleMaps(tags) {
        if (tags !== null) {
            if (tags.primary !== null) {
                this.styleMap = [
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: ${tags.primary.colorShadow};
                                stroke: ${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};`,
                    },
                    {
                        rule: `.${this.styleId}:hover .primaryTagBoundRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagPolylineStyle`,
                        style: `stroke: ${tags.primary.colorPure};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke:${tags.primary.colorDark};
                                fill: ${tags.primary.colorPure}`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .anchorStyle`,
                        style: `stroke:#fff;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `fill:transparent;`,
                    },
                ];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: none;
                                stroke: ${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagPolylineStyle`,
                        style: `stroke: ${tags.primary.colorPure};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke:${tags.primary.colorDark};
                                fill: ${tags.primary.colorPure};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .anchorStyle`,
                        style: `stroke:#fff;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `fill:transparent;
                                stroke-width: 0px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .secondaryTagStyle`,
                        style: `opacity:0.25;`,
                    },
                ];
            }
            else {
                this.styleMap = [];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: none;
                                stroke: ${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagBoundRectStyle`,
                        style: `fill: none;`,
                    },
                    {
                        rule: `.${this.styleId} .primaryTagPolylineStyle`,
                        style: `stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke-width: 1px;`,
                    },
                ];
            }
            if (tags.secondary !== null && tags.secondary !== undefined) {
                tags.secondary.forEach((tag) => {
                    const rule = {
                        rule: `.secondaryTagStyle.secondaryTag-${tag.name}`,
                        style: `fill: ${tag.colorAccent};`,
                    };
                    this.styleMap.push(rule);
                    this.styleLightMap.push(rule);
                });
            }
        }
    }
    /**
     * Internal function to recreate tag labels.
     */
    rebuildTagLabels() {
        // Clear secondary tags -> redraw from scratch
        for (const tag of this.secondaryTags) {
            tag.remove();
        }
        this.secondaryTags = [];
        // If there are tags assigned
        if (this.tags) {
            if (this.tags.primary !== undefined && this.tags.primary !== null) {
                // Primary Tag
            }
            // Secondary Tags
            if (this.tags.secondary && this.tags.secondary.length > 0) {
                const length = this.tags.secondary.length;
                for (let i = 0; i < length; i++) {
                    const stag = this.tags.secondary[i];
                    const s = TagsElement.DEFAULT_SECONDARY_TAG_SIZE;
                    const x = this.x + this.boundRect.width / 2 + (2 * i - length + 1) * s - s / 2;
                    const y = this.y - s - 5;
                    const tagel = this.paper.rect(x, y, s, s);
                    window.requestAnimationFrame(() => {
                        tagel.addClass("secondaryTagStyle");
                        tagel.addClass(`secondaryTag-${stag.name}`);
                    });
                    this.secondaryTagsNode.add(tagel);
                    this.secondaryTags.push(tagel);
                }
            }
        }
    }
    /**
     * Internal function to create tag labels
     * @param paper - The `Snap.Paper` object to draw on.
     * @param tags - The `TagsDescriptor` object defining tags.
     */
    buildOn(paper, tags) {
        this.primaryTagNode = paper.g();
        this.primaryTagBoundRect = paper.rect(this.x, this.y, this.boundRect.width, this.boundRect.height);
        this.primaryTagBoundRect.addClass("primaryTagBoundRectStyle");
        const pointsData = [];
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        this.primaryTagPolyline = paper.polyline(pointsData);
        this.primaryTagPolyline.addClass("primaryTagPolylineStyle");
        this.regionData.points.forEach((p) => {
            pointsData.push(p.x, p.y);
        });
        this.primaryTagNode.add(this.primaryTagBoundRect);
        this.primaryTagNode.add(this.primaryTagPolyline);
        this.secondaryTagsNode = paper.g();
        this.secondaryTagsNode.addClass("secondatyTagsLayer");
        this.secondaryTags = [];
        this.node.add(this.primaryTagNode);
        this.node.add(this.secondaryTagsNode);
        this.initStyleMaps(tags);
        this.updateTags(tags, this.tagsUpdateOptions);
    }
}
/**
 * Default (visual) radius for primary tag.
 */
TagsElement.DEFAULT_PRIMARY_TAG_RADIUS = 3;
/**
 * Default (visual) size for secondary tag boxes.
 */
TagsElement.DEFAULT_SECONDARY_TAG_SIZE = 6;
/**
 * Default (visual) vertical shift for secondary tag boxes.
 */
TagsElement.DEFAULT_SECONDARY_TAG_DY = 6;
exports.TagsElement = TagsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Rect/AnchorsElements.ts":
/*!***********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Rect/AnchorsElements.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const IRegionCallbacks_1 = __webpack_require__(/*! ../../Interface/IRegionCallbacks */ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts");
const AnchorsComponent_1 = __webpack_require__(/*! ../Component/AnchorsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/AnchorsComponent.ts");
/**
 * `AnchorsComponent` for the `RectRegion` class.
 * @todo Current implementations of bones reuses existing aprroach with anchor index
 * by using negative indexes and manually correcting them to actual indexes.
 * It seems like it should be refactored some how.
 */
class AnchorsElement extends AnchorsComponent_1.AnchorsComponent {
    /**
     * Creates a new `AnchorsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
    }
    /**
     * Redraws the visual on the component.
     */
    redraw() {
        super.redraw();
        const [x, y, width, height] = [this.regionData.x, this.regionData.y,
            this.regionData.width, this.regionData.height];
        const [tBone, rBone, bBone, lBone] = this.anchorBones;
        window.requestAnimationFrame(() => {
            tBone.attr({ x, y: y - this.boneThickness / 2, width, height: this.boneThickness });
            rBone.attr({ x: x + width - this.boneThickness / 2, y, width: this.boneThickness, height });
            bBone.attr({ x, y: y + height - this.boneThickness / 2, width, height: this.boneThickness });
            lBone.attr({ x: x - this.boneThickness / 2, y, width: this.boneThickness, height });
        });
    }
    /**
     * Creates a collection on anchors.
     */
    buildAnchors() {
        this.buildBoneAnchors();
        this.buildPointAnchors();
    }
    /**
     * Creates collection of anchor points.
     */
    buildPointAnchors() {
        this.anchorPointStyles = ["TL", "TR", "BR", "BL"];
        this.regionData.points.forEach((point, index) => {
            const anchor = this.createAnchor(this.paper, point.x, point.y, this.anchorPointStyles[index]);
            this.anchors.push(anchor);
            this.anchorsNode.add(anchor);
            this.subscribeAnchorToEvents(anchor, index);
        });
    }
    /**
     * Creates collection of anchor bones.
     */
    buildBoneAnchors() {
        this.anchorBoneStyles = ["T", "R", "B", "L"];
        this.anchorBones = [];
        this.boneThickness = AnchorsComponent_1.AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS;
        const [x, y, w, h] = [this.regionData.x, this.regionData.y, this.regionData.width, this.regionData.height];
        const tBone = this.createAnchorBone(this.paper, x, y, w, 0, "T", this.boneThickness);
        const rBone = this.createAnchorBone(this.paper, x + w, y, 0, h, "R", this.boneThickness);
        const bBone = this.createAnchorBone(this.paper, x, y + h, w, 0, "B", this.boneThickness);
        const lBone = this.createAnchorBone(this.paper, x, y, 0, h, "L", this.boneThickness);
        const bones = [tBone, rBone, bBone, lBone];
        this.anchorBones.push(...bones);
        bones.forEach((bone, index) => {
            this.anchorsNode.add(bone);
            // Using already existing infrastructure for indexes
            this.subscribeAnchorBoneToEvents(bone, -(index + 1));
        });
    }
    /**
     * Helper function to create a new anchor bone.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param x - The `x`-coordinate of the acnhor bone.
     * @param y - The `y`-coordinate of the anchor bone.
     * @param width - The `width` of the anchor bone.
     * @param height - The `height` of the anchor bone.
     * @param style - Additional css style class to be applied.
     * @param thickness - The `thickness` of the bone (activation area).
     */
    createAnchorBone(paper, x, y, width, height, style, thickness = AnchorsComponent_1.AnchorsComponent.DEFAULT_GHOST_ANCHOR_RADIUS) {
        let bone;
        if (width === 0) {
            bone = paper.rect(x - thickness / 2, y, thickness, height);
        }
        else if (height === 0) {
            bone = paper.rect(x, y - thickness / 2, width, thickness);
        }
        else {
            throw Error("Rect bones that are neither vertical or horizontal are not supported.");
            return null;
        }
        bone.addClass("anchorBoneStyle");
        if (style !== undefined && style !== "") {
            bone.addClass(style);
        }
        return bone;
    }
    /**
     * Updates the `regionData` based on the new ghost anchor location. Should be redefined in child classes.
     * @param p - The new ghost anchor location.
     */
    updateRegion(p) {
        let x1 = p.x;
        let y1 = p.y;
        let x2;
        let y2;
        let flipX = false;
        let flipY = false;
        let activeAnchor = this.getActiveAnchor();
        switch (activeAnchor) {
            case "TL": {
                x2 = this.x + this.width;
                y2 = this.y + this.height;
                flipX = x2 < x1;
                flipY = y2 < y1;
                break;
            }
            case "TR": {
                x2 = this.x;
                y2 = this.y + this.height;
                flipX = x1 < x2;
                flipY = y2 < y1;
                break;
            }
            case "BL": {
                y2 = this.y;
                x2 = this.x + this.width;
                flipX = x2 < x1;
                flipY = y1 < y2;
                break;
            }
            case "BR": {
                x2 = this.x;
                y2 = this.y;
                flipX = x1 < x2;
                flipY = y1 < y2;
                break;
            }
            case "T": {
                x1 = this.x;
                x2 = this.x + this.width;
                y2 = this.y + this.height;
                flipY = y1 > y2;
                break;
            }
            case "R": {
                x2 = this.x;
                y1 = this.y;
                y2 = this.y + this.height;
                flipX = x2 > x1;
                break;
            }
            case "B": {
                x1 = this.x;
                x2 = this.x + this.width;
                y2 = this.y;
                flipY = y1 < y2;
                break;
            }
            case "L": {
                x2 = this.x + this.width;
                y1 = this.y;
                y2 = this.y + this.height;
                flipX = x1 > x2;
                break;
            }
        }
        let newAA = "";
        if (activeAnchor !== "" && activeAnchor.length === 2) {
            newAA += (activeAnchor[0] === "T") ? (flipY ? "B" : "T") : (flipY ? "T" : "B");
            newAA += (activeAnchor[1] === "L") ? (flipX ? "R" : "L") : (flipX ? "L" : "R");
        }
        if (activeAnchor !== "" && activeAnchor.length === 1) {
            if (flipX) {
                newAA = (activeAnchor === "R") ? "L" : "R";
            }
            else if (flipY) {
                newAA = (activeAnchor === "T") ? "B" : "T";
            }
            else {
                newAA = activeAnchor;
            }
        }
        if (activeAnchor !== newAA) {
            this.ghostAnchor.removeClass(activeAnchor);
            if (newAA.length === 2) {
                this.activeAnchorIndex = this.anchorPointStyles.indexOf(newAA);
            }
            else {
                this.activeAnchorIndex = -(this.anchorBoneStyles.indexOf(newAA) + 1);
            }
            activeAnchor = newAA;
            this.ghostAnchor.addClass(newAA);
        }
        const p1 = new Point2D_1.Point2D(Math.min(x1, x2), Math.min(y1, y2)).boundToRect(this.paperRect);
        const p2 = new Point2D_1.Point2D(Math.max(x1, x2), Math.max(y1, y2)).boundToRect(this.paperRect);
        const rd = this.regionData.copy();
        rd.setPoints([p1, new Point2D_1.Point2D(p2.x, p1.y), p2, new Point2D_1.Point2D(p1.x, p2.y)]);
        this.onChange(this, rd, IRegionCallbacks_1.ChangeEventType.MOVING);
    }
    /**
     * Callback for the pointerenter event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerEnter(e) {
        this.ghostAnchor.addClass(this.getActiveAnchor());
        super.onGhostPointerEnter(e);
    }
    /**
     * Callback for the pointerleave event for the ghost anchor.
     * @param e - PointerEvent object.
     */
    onGhostPointerLeave(e) {
        this.ghostAnchor.removeClass(this.getActiveAnchor());
        super.onGhostPointerLeave(e);
    }
    /**
     * Helper function to subscribe anchor to activation event.
     * @param bone - The anchor bone for wire up.
     * @param index - The index of the anchor used to define which one is active.
     */
    subscribeAnchorBoneToEvents(bone, index) {
        bone.node.addEventListener("pointerenter", (e) => {
            if (!this.isFrozen) {
                // Set drag origin point to current anchor
                this.dragOrigin = new Point2D_1.Point2D(e.offsetX, e.offsetY);
                this.activeAnchorIndex = index;
                // Move ghost anchor to current anchor position
                window.requestAnimationFrame(() => {
                    this.ghostAnchor.attr({
                        cx: this.dragOrigin.x,
                        cy: this.dragOrigin.y,
                        display: "block",
                    });
                });
                this.onManipulationBegin();
            }
        });
    }
    /**
     * Internal helper function to get active anchor.
     */
    getActiveAnchor() {
        if (this.activeAnchorIndex >= 0) {
            // anchor point is activeted
            return this.anchorPointStyles[this.activeAnchorIndex];
        }
        else {
            // anchor bone is activeted, indexes are negative starting -1
            return this.anchorBoneStyles[-this.activeAnchorIndex - 1];
        }
    }
}
exports.AnchorsElement = AnchorsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Rect/DragElement.ts":
/*!*******************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Rect/DragElement.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DragComponent_1 = __webpack_require__(/*! ../Component/DragComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/DragComponent.ts");
/**
 * `DragComponent` for the `RectRegion` class.
 */
class DragElement extends DragComponent_1.DragComponent {
    /**
     * Creates a new `DragElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        this.dragNode = paper.rect(this.x, this.y, this.boundRect.width, this.boundRect.height);
        this.dragNode.addClass("dragRectStyle");
        this.node.add(this.dragNode);
        this.subscribeToDragEvents();
    }
    /**
     * Redraws the componnent.
     */
    redraw() {
        window.requestAnimationFrame(() => {
            this.dragNode.attr({
                height: this.height,
                width: this.width,
                x: this.x,
                y: this.y,
            });
        });
    }
}
exports.DragElement = DragElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Rect/RectRegion.ts":
/*!******************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Rect/RectRegion.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rect_1 = __webpack_require__(/*! ../../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const Region_1 = __webpack_require__(/*! ../Region */ "./src/canvastools/ts/CanvasTools/Region/Region.ts");
const AnchorsElements_1 = __webpack_require__(/*! ./AnchorsElements */ "./src/canvastools/ts/CanvasTools/Region/Rect/AnchorsElements.ts");
const DragElement_1 = __webpack_require__(/*! ./DragElement */ "./src/canvastools/ts/CanvasTools/Region/Rect/DragElement.ts");
const TagsElement_1 = __webpack_require__(/*! ./TagsElement */ "./src/canvastools/ts/CanvasTools/Region/Rect/TagsElement.ts");
/**
 * The rect-type region class.
 */
class RectRegion extends Region_1.Region {
    /**
     * Creates new `RectRegion` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     * @param id - The region `id` used to identify regions in `RegionsManager`.
     * @param tagsDescriptor - The descriptor of region tags.
     * @param tagsUpdateOptions - The drawing options for tags.
     */
    constructor(paper, paperRect = null, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions) {
        super(paper, paperRect, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions);
        if (paperRect !== null) {
            this.paperRects = {
                actual: new Rect_1.Rect(paperRect.width - regionData.width, paperRect.height - regionData.height),
                host: paperRect,
            };
        }
        this.buildOn(paper);
    }
    /**
     * Updates region tags.
     * @param tags - The new tags descriptor object.
     * @param options - The tags drawing options.
     */
    updateTags(tags, options) {
        super.updateTags(tags, options);
        this.tagsNode.updateTags(tags, options);
        this.node.select("title").node.innerHTML = (tags !== null) ? tags.toString() : "";
    }
    /**
     * Resizes the region to specified `width` and `height`.
     * @param width - The new region width.
     * @param height - The new region height.
     */
    resize(width, height) {
        this.paperRects.actual.resize(this.paperRects.host.width - width, this.paperRects.host.height - height);
        super.resize(width, height);
    }
    /**
     * The callback function fot internal components.
     * @param component - Reference to the UI component.
     * @param regionData - New RegionData object.
     * @param state - New state of the region.
     * @param multiSelection - Flag for multiselection.
     */
    onChange(component, regionData, state, multiSelection = false) {
        this.paperRects.actual.resize(this.paperRects.host.width - regionData.width, this.paperRects.host.height - regionData.height);
        super.onChange(component, regionData, state, multiSelection);
    }
    /**
     * Creates the UI of the region component.
     * @param paper - The `Snap.Paper` element to draw on.
     */
    buildOn(paper) {
        this.node = paper.g();
        this.node.addClass("regionStyle");
        this.node.addClass(this.styleID);
        const callbacks = {
            onChange: this.onChange.bind(this),
            onManipulationBegin: this.onManipulationBegin.bind(this),
            onManipulationEnd: this.onManipulationEnd.bind(this),
        };
        this.anchorNode = new AnchorsElements_1.AnchorsElement(paper, this.paperRects.host, this.regionData, callbacks);
        this.dragNode = new DragElement_1.DragElement(paper, this.paperRects.actual, this.regionData, callbacks);
        this.tagsNode = new TagsElement_1.TagsElement(paper, this.paperRects.host, this.regionData, this.tags, this.styleID, this.styleSheet, this.tagsUpdateOptions);
        this.toolTip = Snap.parse(`<title>${(this.tags !== null) ? this.tags.toString() : ""}</title>`);
        this.node.append(this.toolTip);
        this.node.add(this.tagsNode.node);
        this.node.add(this.dragNode.node);
        this.node.add(this.anchorNode.node);
        this.UI.push(this.tagsNode, this.dragNode, this.anchorNode);
    }
}
exports.RectRegion = RectRegion;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Rect/TagsElement.ts":
/*!*******************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Rect/TagsElement.ts ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TagsComponent_1 = __webpack_require__(/*! ../Component/TagsComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/TagsComponent.ts");
/**
 * `TagsComponent` for the `RectRegion` class.
 */
class TagsElement extends TagsComponent_1.TagsComponent {
    /**
     * Creates a new `TagsElement` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param tags - The `TagsDescriptor` object presenting colors and names for region tags.
     * @param styleId - The unique css style id for region.
     * @param styleSheet - The regerence to the stylesheet object for rules insection.
     * @param tagsUpdateOptions - The settings for redrawing tags.
     */
    constructor(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions) {
        super(paper, paperRect, regionData, tags, styleId, styleSheet, tagsUpdateOptions);
        this.buildOn(paper, tags);
    }
    /**
     * Redraws the componnent.
     */
    redraw(rebuildTags = false) {
        // If there are tags assigned
        if (this.tags) {
            window.requestAnimationFrame(() => {
                if (this.tags.primary !== undefined && this.tags.primary !== null) {
                    // Update primaty tag rect
                    this.primaryTagRect.attr({
                        height: this.height,
                        width: this.width,
                        x: this.x,
                        y: this.y,
                    });
                    // Update primary tag text
                    if (rebuildTags) {
                        this.primaryTagText.node.innerHTML = (this.tags.primary !== null) ? this.tags.primary.name : "";
                        this.textBox = this.primaryTagText.getBBox();
                    }
                    const showTextLabel = (this.textBox.width + 10 <= this.width)
                        && (this.textBox.height <= this.height);
                    if (showTextLabel) {
                        this.primaryTagTextBG.attr({
                            height: this.textBox.height + 5,
                            width: this.textBox.width + 10,
                            x: this.x + 1,
                            y: this.y + 1,
                        });
                        this.primaryTagText.attr({
                            visibility: "visible",
                            x: this.x + 5,
                            y: this.y + this.textBox.height,
                        });
                    }
                    else {
                        this.primaryTagTextBG.attr({
                            height: Math.min(10, this.height),
                            width: Math.min(10, this.width),
                            x: this.x,
                            y: this.y,
                        });
                        this.primaryTagText.attr({
                            visibility: "hidden",
                            x: this.x + 5,
                            y: this.y + this.textBox.height,
                        });
                    }
                }
                else {
                    this.primaryTagRect.attr({
                        height: this.height,
                        width: this.width,
                        x: this.x,
                        y: this.y,
                    });
                    this.primaryTagTextBG.attr({
                        height: 0,
                        width: 0,
                    });
                    this.primaryTagText.attr({
                        visibility: "hidden",
                        x: this.x + 5,
                        y: this.y + this.textBox.height,
                    });
                }
                // Clear secondary tags -> redraw from scratch
                if (rebuildTags) {
                    this.secondaryTags.forEach((tag) => {
                        tag.remove();
                    });
                    this.secondaryTags = [];
                }
                // Recreate secondary tags
                if (this.tags.secondary && this.tags.secondary.length > 0) {
                    const s = 6;
                    const cx = this.x + 0.5 * this.boundRect.width;
                    const cy = this.y - s - 5;
                    const length = this.tags.secondary.length;
                    for (let i = 0; i < length; i++) {
                        const stag = this.tags.secondary[i];
                        const x = cx + (2 * i - length + 1) * s - s / 2;
                        if (rebuildTags) {
                            const tagel = this.paper.rect(x, cy, s, s);
                            tagel.addClass("secondaryTagStyle");
                            tagel.addClass(`secondaryTag-${stag.name}`);
                            this.secondaryTagsNode.add(tagel);
                            this.secondaryTags.push(tagel);
                        }
                        else {
                            const tagel = this.secondaryTags[i];
                            tagel.attr({
                                x,
                                y: cy,
                            });
                        }
                    }
                }
            });
        }
        else {
            window.requestAnimationFrame(() => {
                this.primaryTagRect.attr({
                    height: this.height,
                    width: this.width,
                    x: this.x,
                    y: this.y,
                });
                // Remove primary tag
                this.primaryTagText.node.innerHTML = "";
                this.primaryTagTextBG.attr({
                    height: 0,
                    width: 0,
                });
                // Clear secondary tags
                this.secondaryTags.forEach((tag) => {
                    tag.remove();
                });
                this.secondaryTags = [];
            });
        }
    }
    /**
     * Inits style maps.
     */
    initStyleMaps(tags) {
        if (tags !== null) {
            if (tags.primary !== null) {
                this.styleMap = [
                    {
                        rule: `.${this.styleId} .primaryTagRectStyle`,
                        style: `fill: ${tags.primary.colorShadow};
                                stroke:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover  .primaryTagRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke: #fff;`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .primaryTagTextBGStyle`,
                        style: `fill:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke:${tags.primary.colorDark};
                                fill: ${tags.primary.colorPure}`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .anchorStyle`,
                        style: `stroke:#fff;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `fill:transparent;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost:hover`,
                        style: `fill:rgba(255,255,255,0.5);`,
                    },
                ];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagRectStyle`,
                        style: `fill: ${tags.primary.colorNoColor};
                                stroke:${tags.primary.colorAccent};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover  .primaryTagRectStyle`,
                        style: `fill: ${tags.primary.colorHighlight};
                                stroke: #fff;`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagRectStyle`,
                        style: `fill: ${tags.primary.colorNoColor};
                                stroke:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .primaryTagTextBGStyle`,
                        style: `fill:${tags.primary.colorNoColor};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .primaryTagTextStyle`,
                        style: `fill:${tags.primary.colorAccent};`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .secondaryTagStyle`,
                        style: `opacity:0.25;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke:${tags.primary.colorDark};
                                fill: ${tags.primary.colorPure};
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId}:hover .anchorStyle`,
                        style: `stroke:#fff;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `fill:transparent;
                                stroke-width: 0;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost:hover`,
                        style: `fill:rgba(255,255,255,0.5);
                                stroke-width: 0;`,
                    },
                ];
            }
            else {
                this.styleMap = [];
                this.styleLightMap = [
                    {
                        rule: `.${this.styleId} .primaryTagRectStyle`,
                        style: `fill: var(--default-color-transparent);
                                stroke: var(--default-color-pure);
                                stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.selected.${this.styleId} .primaryTagRectStyle`,
                        style: `fill: var(--default-color-transparent);
                                stroke: var(--default-color-pure);`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle`,
                        style: `stroke-width: 1px;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost`,
                        style: `stroke-width: 0;`,
                    },
                    {
                        rule: `.regionStyle.${this.styleId} .anchorStyle.ghost:hover`,
                        style: `stroke-width: 0;`,
                    },
                ];
            }
            if (tags.secondary !== null && tags.secondary !== undefined) {
                tags.secondary.forEach((tag) => {
                    const rule = {
                        rule: `.secondaryTagStyle.secondaryTag-${tag.name}`,
                        style: `fill: ${tag.colorAccent};`,
                    };
                    this.styleMap.push(rule);
                    this.styleLightMap.push(rule);
                });
            }
        }
    }
    /**
     * Internal function to recreate tag labels.
     */
    rebuildTagLabels() {
        this.redraw(true);
    }
    /**
     * Internal function to create tag labels
     * @param paper - The `Snap.Paper` object to draw on.
     * @param tags - The `TagsDescriptor` object defining tags.
     */
    buildOn(paper, tags) {
        this.primaryTagNode = paper.g();
        this.primaryTagRect = paper.rect(this.x, this.y, this.boundRect.width, this.boundRect.height);
        this.primaryTagRect.addClass("primaryTagRectStyle");
        this.primaryTagText = paper.text(this.x, this.y, "");
        this.primaryTagText.addClass("primaryTagTextStyle");
        this.textBox = this.primaryTagText.getBBox();
        // bound to region???
        this.primaryTagTextBG = paper.rect(this.x, this.y, 0, 0);
        this.primaryTagTextBG.addClass("primaryTagTextBGStyle");
        this.primaryTagNode.add(this.primaryTagRect);
        this.primaryTagNode.add(this.primaryTagTextBG);
        this.primaryTagNode.add(this.primaryTagText);
        this.secondaryTagsNode = paper.g();
        this.secondaryTagsNode.addClass("secondatyTagsLayer");
        this.secondaryTags = [];
        this.node.add(this.primaryTagNode);
        this.node.add(this.secondaryTagsNode);
        this.initStyleMaps(tags);
        this.updateTags(tags, this.tagsUpdateOptions);
    }
}
exports.TagsElement = TagsElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/Region.ts":
/*!*********************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/Region.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RegionComponent_1 = __webpack_require__(/*! ./Component/RegionComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts");
/* import * as SNAPSVG_TYPE from "snapsvg";
declare var Snap: typeof SNAPSVG_TYPE; */
class Region extends RegionComponent_1.RegionComponent {
    /**
     * Creates new `Region` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     * @param id - The region `id` used to identify regions in `RegionsManager`.
     * @param tagsDescriptor - The descriptor of region tags.
     * @param tagsUpdateOptions - The drawing options for tags.
     */
    constructor(paper, paperRect = null, regionData, callbacks, id, tagsDescriptor, tagsUpdateOptions) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * The reference to the CSSStyleSheet object.
         */
        this.styleSheet = null;
        this.ID = id;
        this.tags = tagsDescriptor;
        this.regionID = this.s8();
        this.styleID = `region_${this.regionID}_style`;
        this.styleSheet = this.insertStyleSheet();
        this.tagsUpdateOptions = tagsUpdateOptions;
        this.UI = [];
    }
    /**
     * Clear region styles.
     */
    removeStyles() {
        document.getElementById(this.styleID).remove();
    }
    /**
     * The callback function fot internal components.
     * @param component - Reference to the UI component.
     * @param regionData - New RegionData object.
     * @param state - New state of the region.
     * @param multiSelection - Flag for multiselection.
     */
    onChange(component, regionData, state, multiSelection = false) {
        this.regionData.initFrom(regionData);
        this.redraw();
        super.onChange(this, this.regionData.copy(), state, multiSelection);
    }
    /**
     * Updates region tags.
     * @param tags - The new tags descriptor object.
     * @param options - The tags drawing options.
     */
    updateTags(tags, options) {
        this.tags = tags;
        this.tagsUpdateOptions = options;
    }
    move(arg1, arg2) {
        super.move(arg1, arg2);
        this.redraw();
    }
    /**
     * Resizes the region to specified `width` and `height`.
     * @param width - The new region width.
     * @param height - The new region height.
     */
    resize(width, height) {
        super.resize(width, height);
        this.redraw();
    }
    /**
     * Redraws the region component.
     */
    redraw() {
        this.UI.forEach((element) => {
            element.redraw();
        });
    }
    /**
     * Visually freeze the region.
     */
    freeze() {
        super.freeze();
        this.node.addClass("old");
        this.UI.forEach((element) => {
            element.freeze();
        });
    }
    /**
     * Visually unfreeze the region.
     */
    unfreeze() {
        super.unfreeze();
        this.node.removeClass("old");
        this.UI.forEach((element) => {
            element.unfreeze();
        });
    }
    /**
     * Internal helper function to generate random id.
     */
    s8() {
        return Math.floor((1 + Math.random()) * 0x100000000).toString(16).substring(1);
    }
    /**
     * Helper function to insert a new stylesheet into the document.
     */
    insertStyleSheet() {
        const style = document.createElement("style");
        style.setAttribute("id", this.styleID);
        document.head.appendChild(style);
        return style.sheet;
    }
}
exports.Region = Region;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/RegionMenu.ts":
/*!*************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/RegionMenu.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RegionComponent_1 = __webpack_require__(/*! ./Component/RegionComponent */ "./src/canvastools/ts/CanvasTools/Region/Component/RegionComponent.ts");
/**
 * The region menu element.
 */
class MenuElement extends RegionComponent_1.RegionComponent {
    /**
     * Creates the menu component.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param paperRect - The parent bounding box for created component.
     * @param regionData - The `RegionData` object shared across components. Used also for initial setup.
     * @param callbacks - The external callbacks collection.
     */
    constructor(paper, paperRect = null, regionData, callbacks) {
        super(paper, paperRect, regionData, callbacks);
        /**
         * Default menu item size.
         */
        this.menuItemSize = 20;
        /**
         * Default menu width.
         */
        this.mw = this.menuItemSize + 10;
        /**
         * Default menu height.
         */
        this.mh = this.menuItemSize + 10;
        /**
         * Threshold for positioning menu inside/outside
         */
        this.dh = 20;
        /**
         * Threshold for positioning menu left/right
         */
        this.dw = 5;
        this.buildUI();
    }
    /**
     * Add a new icon with action to menu.
     * @param action - Item action description.
     * @param icon - Item SVG-path string.
     * @param actor - The callback function.
     */
    addAction(action, icon, actor) {
        const item = this.menuGroup.g();
        const itemBack = this.menuGroup.rect(5, 5, this.menuItemSize, this.menuItemSize, 5, 5);
        itemBack.addClass("menuItemBack");
        const itemIcon = this.menuGroup.path(MenuElement.PathCollection.delete.path);
        itemIcon.transform(`scale(0.2) translate(26 26)`);
        itemIcon.addClass("menuIcon");
        itemIcon.addClass("menuIcon-" + icon);
        const itemRect = this.menuGroup.rect(5, 5, this.menuItemSize, this.menuItemSize, 5, 5);
        itemRect.addClass("menuItem");
        item.add(itemBack);
        item.add(itemIcon);
        item.add(itemRect);
        item.click((e) => {
            actor(this.region, action);
        });
        this.menuItemsGroup.add(item);
        this.menuItems.push(item);
    }
    /**
     * Attach the menu to specified region element.
     * @param region - The host region element.
     */
    attachTo(region) {
        this.region = region;
        this.regionData.initFrom(region.regionData);
        this.rearrangeMenuPosition();
        window.requestAnimationFrame(() => {
            this.menuGroup.attr({
                x: this.mx,
                y: this.my,
            });
        });
    }
    move(arg1, arg2) {
        super.move(arg1, arg2);
        this.rearrangeMenuPosition();
        window.requestAnimationFrame(() => {
            this.menuGroup.attr({
                x: this.mx,
                y: this.my,
            });
        });
    }
    /**
     * Move menu according to new region size.
     * @remarks This method moves the virtual shadow of the region and then rearranges menu position.
     * @param width - New region width.
     * @param height - New region height.
     */
    resize(width, height) {
        super.resize(width, height);
        this.rearrangeMenuPosition();
        window.requestAnimationFrame(() => {
            this.menuGroup.attr({
                x: this.mx,
                y: this.my,
            });
        });
    }
    /**
     * Redraw menu element.
     */
    redraw() {
        // do nothing
    }
    /**
     * Visually hide menu element.
     */
    hide() {
        window.requestAnimationFrame(() => {
            this.menuGroup.attr({
                visibility: "hidden",
            });
        });
    }
    /**
     * Visually show menu element.
     */
    show() {
        window.requestAnimationFrame(() => {
            this.menuGroup.attr({
                visibility: "visible",
            });
        });
    }
    /**
     * Show menu element on the specified region.
     * @param region - The host region element.
     */
    showOnRegion(region) {
        this.attachTo(region);
        this.show();
    }
    /**
     * Creates the menu element UI.
     */
    buildUI() {
        const menuSVG = this.paper.svg(this.mx, this.my, this.mw, this.mh, this.mx, this.my, this.mw, this.mh);
        // Snap.Paper
        this.menuGroup = Snap(menuSVG).paper;
        this.menuGroup.addClass("menuLayer");
        this.rearrangeMenuPosition();
        this.menuRect = this.menuGroup.rect(0, 0, this.mw, this.mh, 5, 5);
        this.menuRect.addClass("menuRectStyle");
        this.menuItemsGroup = this.menuGroup.g();
        this.menuItemsGroup.addClass("menuItems");
        this.menuItems = new Array();
        this.menuGroup.add(this.menuRect);
        this.menuGroup.add(this.menuItemsGroup);
        this.menuGroup.mouseover((e) => {
            this.onManipulationBegin();
        });
        this.menuGroup.mouseout((e) => {
            this.onManipulationEnd();
        });
    }
    /**
     * Updates menu position.
     */
    rearrangeMenuPosition() {
        /* // position menu inside
        if (this.mh <= this.boundRect.height - this.dh) {
            this.my = this.y + this.boundRect.height / 2 - this.mh / 2;
            // position menu on the right side
            if (this.x + this.boundRect.width + this.mw / 2 + this.dw < this.paperRect.width) {
                this.mx = this.x + this.boundRect.width - this.mw / 2;
            } else if (this.x - this.mw / 2 - this.dw > 0) { // position menu on the left side
                this.mx = this.x - this.mw / 2;
            } else { // position menu on the right side INSIDE
                this.mx = this.x + this.boundRect.width - this.mw - this.dw;
            }
        } else { // position menu outside
            if (this.y + this.mh > this.paperRect.height) {
                this.my = this.paperRect.height - this.mh - this.dw;
            } else {
                this.my = this.y;
            }
            // position menu on the right side
            if (this.x + this.boundRect.width + this.mw + 2 * this.dw < this.paperRect.width) {
                this.mx = this.x + this.boundRect.width + this.dw;
            } else if (this.x - this.mw - 2 * this.dw > 0) { // position menu on the left side
                this.mx = this.x - this.mw - this.dw;
            } else { // position menu on the right side INSIDE
                this.mx = this.x + this.boundRect.width - this.mw - this.dw;
            }
        } */
        // position menu outside
        if (this.y + this.mh + this.dw > this.paperRect.height) {
            this.my = this.paperRect.height - this.mh - this.dw;
        }
        else {
            this.my = this.y + this.dw;
        }
        // position menu on the right side
        if (this.x + this.boundRect.width + this.mw + 2 * this.dw < this.paperRect.width) {
            this.mx = this.x + this.boundRect.width + this.dw;
        }
        else if (this.x - this.mw - 2 * this.dw > 0) { // position menu on the left side
            this.mx = this.x - this.mw - this.dw;
        }
        else { // position menu on the right side INSIDE
            this.mx = this.x + this.boundRect.width - this.mw - this.dw;
        }
    }
}
/**
 * The SVG path for x-button (close).
 */
MenuElement.PathCollection = {
    delete: {
        iconSize: 96,
        path: "M 83.4 21.1 L 74.9 12.6 L 48 39.5 L 21.1 12.6 L 12.6 21.1 L 39.5 48 L 12.6 74.9 " +
            "L 21.1 83.4 L 48 56.5 L 74.9 83.4 L 83.4 74.9 L 56.5 48 Z",
    },
};
exports.MenuElement = MenuElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Region/RegionsManager.ts":
/*!*****************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Region/RegionsManager.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const Rect_1 = __webpack_require__(/*! ../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const IRegionCallbacks_1 = __webpack_require__(/*! ../Interface/IRegionCallbacks */ "./src/canvastools/ts/CanvasTools/Interface/IRegionCallbacks.ts");
const RectRegion_1 = __webpack_require__(/*! ./Rect/RectRegion */ "./src/canvastools/ts/CanvasTools/Region/Rect/RectRegion.ts");
const PointRegion_1 = __webpack_require__(/*! ./Point/PointRegion */ "./src/canvastools/ts/CanvasTools/Region/Point/PointRegion.ts");
const PolygonRegion_1 = __webpack_require__(/*! ./Polygon/PolygonRegion */ "./src/canvastools/ts/CanvasTools/Region/Polygon/PolygonRegion.ts");
const PolylineRegion_1 = __webpack_require__(/*! ./Polyline/PolylineRegion */ "./src/canvastools/ts/CanvasTools/Region/Polyline/PolylineRegion.ts");
const RegionMenu_1 = __webpack_require__(/*! ./RegionMenu */ "./src/canvastools/ts/CanvasTools/Region/RegionMenu.ts");
const RegionData_1 = __webpack_require__(/*! ../Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
/**
 * The manager for visual region objects.
 */
class RegionsManager {
    /**
     * Creates new `RegionsManager`.
     * @param svgHost - The hosting SVG element.
     * @param callbacks - Reference to the callbacks collection.
     */
    constructor(svgHost, callbacks) {
        /**
         * Global freezing state.
         */
        this.isFrozenState = false;
        /**
         * Internal manipulation flag.
         */
        this.justManipulated = false;
        /**
         * Tags create/redraw options.
         */
        this.tagsUpdateOptions = {
            showRegionBackground: true,
        };
        this.baseParent = svgHost;
        this.paper = Snap(svgHost);
        this.paperRect = new Rect_1.Rect(svgHost.width.baseVal.value, svgHost.height.baseVal.value);
        this.regions = new Array();
        if (callbacks !== undefined) {
            this.callbacks = callbacks;
            if (typeof callbacks.onChange === "function") {
                this.callbacks.onChange = (region, regionData, state, multiSelection = false) => {
                    this.onRegionChange(region, regionData, state, multiSelection);
                    callbacks.onChange(region, regionData, state, multiSelection);
                };
            }
            else {
                this.callbacks.onChange = this.onRegionChange.bind(this);
            }
        }
        else {
            this.callbacks = {
                onChange: this.onRegionChange.bind(this),
                onManipulationBegin: null,
                onManipulationEnd: null,
            };
        }
        this.buildOn(this.paper);
        this.subscribeToEvents();
    }
    /**
     * Returns current freezing state.
     */
    get isFrozen() {
        return this.isFrozenState;
    }
    /**
     * Add new region to the manager. Automatically defines region type based on the `type` property.
     * @param id - The region ID.
     * @param regionData - The `RegionData` object defining region.
     * @param tagsDescriptor - The tags descriptor object.
     */
    addRegion(id, regionData, tagsDescriptor) {
        if (regionData.type === RegionData_1.RegionDataType.Point) {
            this.addPointRegion(id, regionData, tagsDescriptor);
        }
        else if (regionData.type === RegionData_1.RegionDataType.Polyline) {
            this.addPolylineRegion(id, regionData, tagsDescriptor);
        }
        else if (regionData.type === RegionData_1.RegionDataType.Rect) {
            this.addRectRegion(id, regionData, tagsDescriptor);
        }
        else if (regionData.type === RegionData_1.RegionDataType.Polygon) {
            this.addPolygonRegion(id, regionData, tagsDescriptor);
        }
        this.sortRegionsByArea();
        this.redrawAllRegions();
    }
    /**
     * Add new rect region to the manager.
     * @param id - The region ID.
     * @param regionData - The `RegionData` object defining region.
     * @param tagsDescriptor - The tags descriptor object.
     */
    addRectRegion(id, regionData, tagsDescriptor) {
        this.menu.hide();
        const region = new RectRegion_1.RectRegion(this.paper, this.paperRect, regionData, this.callbacks, id, tagsDescriptor, this.tagsUpdateOptions);
        this.registerRegion(region);
    }
    /**
     * Add new point region to the manager.
     * @param id - The region ID.
     * @param regionData - The `RegionData` object defining region.
     * @param tagsDescriptor - The tags descriptor object.
     */
    addPointRegion(id, regionData, tagsDescriptor) {
        this.menu.hide();
        const region = new PointRegion_1.PointRegion(this.paper, this.paperRect, regionData, this.callbacks, id, tagsDescriptor, this.tagsUpdateOptions);
        this.registerRegion(region);
    }
    /**
     * Add new polyline region to the manager.
     * @param id - The region ID.
     * @param regionData - The `RegionData` object defining region.
     * @param tagsDescriptor - The tags descriptor object.
     */
    addPolylineRegion(id, regionData, tagsDescriptor) {
        this.menu.hide();
        const region = new PolylineRegion_1.PolylineRegion(this.paper, this.paperRect, regionData, this.callbacks, id, tagsDescriptor, this.tagsUpdateOptions);
        this.registerRegion(region);
    }
    /**
     * Add new polygon region to the manager.
     * @param id - The region ID.
     * @param regionData - The `RegionData` object defining region.
     * @param tagsDescriptor - The tags descriptor object.
     */
    addPolygonRegion(id, regionData, tagsDescriptor) {
        this.menu.hide();
        const region = new PolygonRegion_1.PolygonRegion(this.paper, this.paperRect, regionData, this.callbacks, id, tagsDescriptor, this.tagsUpdateOptions);
        this.registerRegion(region);
    }
    /*     // REGION CREATION
        public drawRegion(x: number, y: number, rect: Rect, id: string, tagsDescriptor: TagsDescriptor) {
            this.menu.hide();
            let region = new RectRegion(this.paper, this.paperRect, new Point2D(x, y), rect, id, tagsDescriptor,
                this.onManipulationBegin_local.bind(this),
                this.onManipulationEnd_local.bind(this),
                this.tagsUpdateOptions);
            region.area = rect.height * rect.width;
            region.onChange = this.onRegionChange.bind(this);
    
            region.updateTags(region.tags, this.tagsUpdateOptions);
            this.regionManagerLayer.add(region.node);
            this.regions.push(region);
            // Need to do a check for invalid stacking from user generated or older saved json
            if (this.regions.length > 1) {
                this.sortRegionsByArea();
                this.redrawAllRegions();
            }
            //this.menu.showOnRegion(region);
        } */
    /**
     * Redraws all regions. Reinserts regions in actual order.
     */
    redrawAllRegions() {
        // re-add all elements to DOM based on new order
        window.requestAnimationFrame((e) => {
            this.regions.forEach((region) => {
                const node = region.node.remove();
                this.regionManagerLayer.add(node);
            });
        });
    }
    /**
     * Returns bounding boxes of the selected regions.
     * @deprecated Use `getSelectedRegions` method instead
     */
    getSelectedRegionsBounds() {
        const regions = this.lookupSelectedRegions().map((region) => {
            return {
                id: region.ID,
                x: region.x,
                y: region.y,
                width: region.boundRect.width,
                height: region.boundRect.height,
            };
        });
        return regions;
    }
    /**
     * Returns a collection of selected regions.
     */
    getSelectedRegions() {
        const regions = this.lookupSelectedRegions().map((region) => {
            return {
                id: region.ID,
                regionData: region.regionData,
            };
        });
        return regions;
    }
    /**
     * Deletes a region with specified `id`.
     * @param id - Id of the region to delete.
     */
    deleteRegionById(id) {
        const region = this.lookupRegionByID(id);
        if (region != null) {
            this.deleteRegion(region);
        }
        if (this.callbacks.onManipulationEnd !== null) {
            this.callbacks.onManipulationEnd();
        }
    }
    /**
     * Deletes all the regions from the manager.
     */
    deleteAllRegions() {
        for (const region of this.regions) {
            region.removeStyles();
            region.node.remove();
        }
        this.regions = [];
        this.menu.hide();
    }
    /**
     * Updates tags of the specified region.
     * @param id - The `id` of the region to update.
     * @param tagsDescriptor - The new tags descriptor object.
     */
    updateTagsById(id, tagsDescriptor) {
        const region = this.lookupRegionByID(id);
        if (region != null) {
            region.updateTags(tagsDescriptor, this.tagsUpdateOptions);
        }
    }
    /**
     * Updates tags for all selected regions.
     * @param tagsDescriptor - The new tags descriptor object.
     */
    updateTagsForSelectedRegions(tagsDescriptor) {
        const regions = this.lookupSelectedRegions();
        regions.forEach((region) => {
            region.updateTags(tagsDescriptor, this.tagsUpdateOptions);
        });
    }
    /**
     * Selects the region specified by `id`.
     * @param id - The `id` of the region to select.
     */
    selectRegionById(id) {
        const region = this.lookupRegionByID(id);
        this.selectRegion(region);
    }
    /**
     * Resizes the manager to specified `width` and `height`.
     * @param width - The new manager width.
     * @param height - The new manager height.
     */
    resize(width, height) {
        const tw = width / this.paperRect.width;
        const th = height / this.paperRect.height;
        this.paperRect.resize(width, height);
        this.menu.hide();
        // recalculate size/position for all regions;
        for (const region of this.regions) {
            region.move(new Point2D_1.Point2D(region.x * tw, region.y * th));
            region.resize(region.boundRect.width * tw, region.boundRect.height * th);
        }
    }
    /**
     * Freezes the manager and all its current regions.
     * @param nuance - [optional] Additional css-class to add to the manager.
     */
    freeze(nuance) {
        this.regionManagerLayer.addClass("frozen");
        if (nuance !== undefined) {
            this.regionManagerLayer.addClass(nuance);
            this.frozenNuance = nuance;
        }
        else {
            this.frozenNuance = "";
        }
        this.menu.hide();
        this.regions.forEach((region) => {
            region.freeze();
        });
        this.isFrozenState = true;
    }
    /**
     * Unfreezes the manager and all its regions.
     */
    unfreeze() {
        this.regionManagerLayer.removeClass("frozen");
        if (this.frozenNuance !== "") {
            this.regionManagerLayer.removeClass(this.frozenNuance);
        }
        const selectedRegions = this.lookupSelectedRegions();
        if (selectedRegions.length > 0) {
            this.menu.showOnRegion(selectedRegions[0]);
        }
        this.regions.forEach((region) => {
            region.unfreeze();
        });
        this.isFrozenState = false;
    }
    /**
     * Toggles freezing mode.
     */
    toggleFreezeMode() {
        if (this.isFrozen) {
            this.unfreeze();
        }
        else {
            this.freeze();
        }
    }
    /**
     * Changes the tags drawing setting to draw background or make it transparent.
     */
    toggleBackground() {
        this.tagsUpdateOptions.showRegionBackground = !this.tagsUpdateOptions.showRegionBackground;
        this.regions.forEach((r) => {
            r.updateTags(r.tags, this.tagsUpdateOptions);
        });
    }
    /**
     * Finds the region by specified `id`.
     * @param id - The `id` to look for.
     */
    lookupRegionByID(id) {
        let region = null;
        let i = 0;
        while (i < this.regions.length && region == null) {
            if (this.regions[i].ID === id) {
                region = this.regions[i];
            }
            i++;
        }
        return region;
    }
    /**
     * Internal helper function to sort regions by their area.
     */
    sortRegionsByArea() {
        function quickSort(arr, left, right) {
            let pivot;
            let partitionIndex;
            if (left < right) {
                pivot = right;
                partitionIndex = partition(arr, pivot, left, right);
                // sort left and right
                quickSort(arr, left, partitionIndex - 1);
                quickSort(arr, partitionIndex + 1, right);
            }
            return arr;
        }
        function partition(arr, pivot, left, right) {
            const pivotValue = arr[pivot].area;
            let partitionIndex = left;
            for (let i = left; i < right; i++) {
                if (arr[i].area > pivotValue) {
                    swap(arr, i, partitionIndex);
                    partitionIndex++;
                }
            }
            swap(arr, right, partitionIndex);
            return partitionIndex;
        }
        function swap(arr, i, j) {
            const temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        const length = this.regions.length;
        if (length > 1) {
            quickSort(this.regions, 0, this.regions.length - 1);
        }
    }
    /**
     * Finds all selected regions.
     */
    lookupSelectedRegions() {
        const collection = Array();
        for (const region of this.regions) {
            if (region.isSelected) {
                collection.push(region);
            }
        }
        return collection;
    }
    /**
     * Deletes provided region.
     * @param region - The region to delete.
     */
    deleteRegion(region) {
        // remove style
        region.removeStyles();
        // remove element
        region.node.remove();
        this.regions = this.regions.filter((r) => {
            return r !== region;
        });
        this.menu.hide();
        if ((typeof this.callbacks.onRegionDelete) === "function") {
            this.callbacks.onRegionDelete(region.ID, region.regionData);
        }
    }
    /**
     * Deletes all selected regions.
     */
    deleteSelectedRegions() {
        const collection = this.lookupSelectedRegions();
        for (const region of collection) {
            this.deleteRegion(region);
        }
        this.selectNextRegion();
        if (this.callbacks.onManipulationEnd !== null) {
            this.callbacks.onManipulationEnd();
        }
    }
    /**
     * Selects specified region.
     * @param region - The region to select.
     */
    selectRegion(region) {
        if (region !== null) {
            this.unselectRegions(region);
            region.select();
            this.menu.showOnRegion(region);
            if ((typeof this.callbacks.onRegionSelected) === "function") {
                this.callbacks.onRegionSelected(region.ID);
            }
        }
    }
    /**
     * Selects all the regions.
     */
    selectAllRegions() {
        let r = null;
        for (const region of this.regions) {
            r = region;
            r.select();
            if ((typeof this.callbacks.onRegionSelected) === "function") {
                this.callbacks.onRegionSelected(r.ID);
            }
        }
        if (r != null) {
            this.menu.showOnRegion(r);
        }
    }
    /**
     * Selects the next region (based on current order, e.g., sorted by area).
     */
    selectNextRegion() {
        let region = null;
        let i = 0;
        const length = this.regions.length;
        if (length === 1) {
            region = this.regions[0];
        }
        else if (length > 1) {
            while (i < length && region == null) {
                if (this.regions[i].isSelected) {
                    region = (i === length - 1) ? this.regions[0] : this.regions[i + 1];
                }
                i++;
            }
        }
        if (region == null && length > 0) {
            region = this.regions[0];
        }
        this.selectRegion(region);
    }
    /**
     * Moves or changes region size
     * @param region - The region to be changed.
     * @param dx - x-coordinate shift.
     * @param dy - y-coordinate shift.
     * @param dw - width-shift.
     * @param dh - height-shift.
     * @param inverse - flag if the change is inverted.
     */
    reshapeRegion(region, dx, dy, dw, dh, inverse = false) {
        let w;
        let h;
        let x;
        let y;
        if (!inverse) {
            w = region.boundRect.width + Math.abs(dw);
            h = region.boundRect.height + Math.abs(dh);
            x = region.x + dx + (dw > 0 ? 0 : dw);
            y = region.y + dy + (dh > 0 ? 0 : dh);
        }
        else {
            w = Math.max(0, region.boundRect.width - Math.abs(dw));
            h = Math.max(0, region.boundRect.height - Math.abs(dh));
            x = region.x + dx + (dw < 0 ? 0 : dw);
            y = region.y + dy + (dh < 0 ? 0 : dh);
        }
        const p1 = new Point2D_1.Point2D(x, y).boundToRect(this.paperRect);
        const p2 = new Point2D_1.Point2D(x + w, y + h).boundToRect(this.paperRect);
        region.move(p1);
        region.resize(p2.x - p1.x, p2.y - p1.y);
    }
    /**
     * Moves the selected region with specified shift in coordinates
     * @param dx - x-coordinate shift.
     * @param dy - y-coordinate shift.
     */
    moveSelectedRegions(dx, dy) {
        const regions = this.lookupSelectedRegions();
        regions.forEach((r) => {
            this.reshapeRegion(r, dx, dy, 0, 0);
        });
        this.menu.showOnRegion(regions[0]);
    }
    /**
     * Resizes the selected region with specified width and height shifts.
     * @param dw - width-shift.
     * @param dh - height-shift.
     * @param inverse - flag if the change is inverted.
     */
    resizeSelectedRegions(dw, dh, inverse = false) {
        const regions = this.lookupSelectedRegions();
        regions.forEach((r) => {
            this.reshapeRegion(r, 0, 0, dw, dh, inverse);
        });
        this.menu.showOnRegion(regions[0]);
    }
    /**
     * The callback function fot internal components.
     * @param component - Reference to the UI component.
     * @param regionData - New RegionData object.
     * @param state - New state of the region.
     * @param multiSelection - Flag for multiselection.
     */
    onRegionChange(region, regionData, state, multiSelection = false) {
        // resize or drag begin
        if (state === IRegionCallbacks_1.ChangeEventType.MOVEBEGIN) {
            if (!multiSelection) {
                this.unselectRegions(region);
            }
            this.menu.hide();
            if ((typeof this.callbacks.onRegionSelected) === "function") {
                this.callbacks.onRegionSelected(region.ID, multiSelection);
            }
            if ((typeof this.callbacks.onRegionMoveBegin) === "function") {
                this.callbacks.onRegionMoveBegin(region.ID, regionData);
            }
            this.justManipulated = false;
            // resizing or dragging
        }
        else if (state === IRegionCallbacks_1.ChangeEventType.MOVING) {
            if ((typeof this.callbacks.onRegionMove) === "function") {
                this.callbacks.onRegionMove(region.ID, regionData);
            }
            this.justManipulated = true;
            // resize or drag end
        }
        else if (state === IRegionCallbacks_1.ChangeEventType.MOVEEND) {
            if (this.justManipulated) {
                region.select();
                this.menu.showOnRegion(region);
                this.sortRegionsByArea();
                this.redrawAllRegions();
                if ((typeof this.callbacks.onRegionMoveEnd) === "function") {
                    this.callbacks.onRegionMoveEnd(region.ID, regionData);
                }
            }
        }
        else if (state === IRegionCallbacks_1.ChangeEventType.SELECTIONTOGGLE && !this.justManipulated) {
            // select
            if (!region.isSelected) {
                if (!multiSelection) {
                    this.unselectRegions(region);
                }
                region.select();
                this.menu.showOnRegion(region);
                if ((typeof this.callbacks.onRegionSelected) === "function") {
                    this.callbacks.onRegionSelected(region.ID, multiSelection);
                }
                // unselect
            }
            else {
                region.unselect();
                this.menu.hide();
                if ((typeof this.callbacks.onRegionSelected) === "function") {
                    this.callbacks.onRegionSelected("", multiSelection);
                }
            }
        }
    }
    /**
     * Unselects all the regions, naybe except the one specified.
     * @param except - Region to ignore.
     */
    unselectRegions(except) {
        for (const region of this.regions) {
            if (region !== except) {
                region.unselect();
            }
        }
    }
    /**
     * Inits regions manager UI.
     * @param paper - The `Snap.Paper` element to draw on.
     */
    buildOn(paper) {
        this.regionManagerLayer = paper.g();
        this.regionManagerLayer.addClass("regionManager");
        this.menuLayer = paper.g();
        this.menuLayer.addClass("menuManager");
        this.menu = new RegionMenu_1.MenuElement(paper, this.paperRect, new RegionData_1.RegionData(0, 0, 0, 0), this.callbacks);
        this.menu.addAction("delete", "trash", (region) => {
            this.deleteRegion(region);
            this.menu.hide();
        });
        this.menuLayer.add(this.menu.menuGroup);
        this.menu.hide();
    }
    /**
     * Helper function to subscribe manager to pointer and keyboard events.
     */
    subscribeToEvents() {
        this.regionManagerLayer.mouseover((e) => {
            if (this.callbacks.onManipulationBegin !== null) {
                this.callbacks.onManipulationBegin();
            }
        });
        this.regionManagerLayer.mouseout((e) => {
            if (this.callbacks.onManipulationEnd !== null) {
                this.callbacks.onManipulationEnd();
            }
        });
        window.addEventListener("keyup", (e) => {
            if (!(e.target instanceof HTMLInputElement) &&
                !(e.target instanceof HTMLTextAreaElement) &&
                !(e.target instanceof HTMLSelectElement)) {
                if (!this.isFrozen) {
                    switch (e.keyCode) {
                        // tab
                        case 9:
                            this.selectNextRegion();
                            break;
                        // delete, backspace
                        case 46:
                        case 8:
                            this.deleteSelectedRegions();
                            break;
                        // ctrl + up
                        case 38:
                            if (e.ctrlKey) {
                                if (!e.shiftKey && !e.altKey) {
                                    this.moveSelectedRegions(0, -5);
                                }
                                else if (e.shiftKey && !e.altKey) {
                                    this.resizeSelectedRegions(0, -5);
                                }
                                else if (e.altKey && !e.shiftKey) {
                                    this.resizeSelectedRegions(0, -5, true);
                                }
                            }
                            break;
                        // ctrl + down
                        case 40:
                            if (e.ctrlKey) {
                                if (!e.shiftKey && !e.altKey) {
                                    this.moveSelectedRegions(0, 5);
                                }
                                else if (e.shiftKey && !e.altKey) {
                                    this.resizeSelectedRegions(0, 5);
                                }
                                else if (e.altKey && !e.shiftKey) {
                                    this.resizeSelectedRegions(0, 5, true);
                                }
                            }
                            break;
                        // ctrl + left
                        case 37:
                            if (e.ctrlKey) {
                                if (!e.shiftKey && !e.altKey) {
                                    this.moveSelectedRegions(-5, 0);
                                }
                                else if (e.shiftKey && !e.altKey) {
                                    this.resizeSelectedRegions(-5, 0);
                                }
                                else if (e.altKey && !e.shiftKey) {
                                    this.resizeSelectedRegions(-5, 0, true);
                                }
                            }
                            break;
                        // ctrl + right
                        case 39:
                            if (e.ctrlKey) {
                                if (!e.shiftKey && !e.altKey) {
                                    this.moveSelectedRegions(5, 0);
                                }
                                else if (e.shiftKey && !e.altKey) {
                                    this.resizeSelectedRegions(5, 0);
                                }
                                else if (e.altKey && !e.shiftKey) {
                                    this.resizeSelectedRegions(5, 0, true);
                                }
                            }
                            break;
                        // default
                        default: return;
                    }
                    e.preventDefault();
                }
            }
        });
        window.addEventListener("keydown", (e) => {
            if (!(e.target instanceof HTMLInputElement) &&
                !(e.target instanceof HTMLTextAreaElement) &&
                !(e.target instanceof HTMLSelectElement)) {
                if (!this.isFrozen) {
                    switch (e.code) {
                        // ctrl + A, ctrl + a
                        case "KeyA":
                        case "Numpad1":
                            if (e.ctrlKey) {
                                this.selectAllRegions();
                            }
                            break;
                    }
                    // e.preventDefault();
                }
            }
        });
    }
    /**
     * Registers the provided region in the manager.
     * @param region - The new region to register.
     */
    registerRegion(region) {
        this.unselectRegions();
        region.select();
        this.regionManagerLayer.add(region.node);
        this.regions.push(region);
        this.menu.showOnRegion(region);
    }
}
exports.RegionsManager = RegionsManager;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/AreaSelector.ts":
/*!******************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/AreaSelector.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rect_1 = __webpack_require__(/*! ../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const ISelectorSettings_1 = __webpack_require__(/*! ../Interface/ISelectorSettings */ "./src/canvastools/ts/CanvasTools/Interface/ISelectorSettings.ts");
const PointSelector_1 = __webpack_require__(/*! ./Selectors/PointSelector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/PointSelector.ts");
const PolylineSelector_1 = __webpack_require__(/*! ./Selectors/PolylineSelector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/PolylineSelector.ts");
const PolygonSelector_1 = __webpack_require__(/*! ./Selectors/PolygonSelector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/PolygonSelector.ts");
const RectCopySelector_1 = __webpack_require__(/*! ./Selectors/RectCopySelector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/RectCopySelector.ts");
const RectSelector_1 = __webpack_require__(/*! ./Selectors/RectSelector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/RectSelector.ts");
/**
 * The region selection manager.
 * @remarks The naming of the class is historical per the idea to specify the
 * region area to be selected. Thus AreaSelector.
 * @todo Consider renaming.
 */
class AreaSelector {
    /**
     * Creates a new `AreaSelector` manager.
     * @param svgHost - The host SVG element.
     * @param callbacks - The collection of callbacks.
     */
    constructor(svgHost, callbacks) {
        /**
         * Internal flag to track selector visibility.
         */
        this.isVisible = true;
        this.parentNode = svgHost;
        if (callbacks !== undefined) {
            this.callbacks = callbacks;
        }
        else {
            this.callbacks = {
                onLocked: null,
                onSelectionBegin: null,
                onSelectionEnd: null,
                onUnlocked: null,
            };
        }
        this.buildUIElements();
    }
    /**
     * Resizes selectors to specified `width` and `height`.
     * @param width - The new `width` for selector.
     * @param height - The new `height` for selector.
     */
    resize(width, height) {
        if (width !== undefined && height !== undefined) {
            this.boundRect.resize(width, height);
        }
        else {
            this.boundRect.resize(this.parentNode.width.baseVal.value, this.parentNode.height.baseVal.value);
        }
        if (this.selector !== null) {
            this.selector.resize(width, height);
        }
    }
    /**
     * Enables the current selector.
     */
    enable() {
        if (this.selector !== null) {
            this.selector.enable();
            this.selector.resize(this.boundRect.width, this.boundRect.height);
        }
    }
    /**
     * Disables the current selector.
     */
    disable() {
        if (this.selector !== null) {
            this.selector.disable();
        }
    }
    /**
     * Makes current selector visible and enabled.
     */
    show() {
        this.enable();
        this.isVisible = true;
    }
    /**
     * Makes current selector hidden and disabled.
     */
    hide() {
        this.disable();
        this.isVisible = false;
    }
    setSelectionMode(settings) {
        this.disable();
        if (settings === null || settings === undefined) {
            this.selectorSettings = {
                mode: ISelectorSettings_1.SelectionMode.NONE,
            };
        }
        else if (settings.mode !== undefined) {
            this.selectorSettings = settings;
        }
        else {
            this.selectorSettings = { mode: settings };
        }
        const selectionMode = this.selectorSettings.mode;
        if (selectionMode === ISelectorSettings_1.SelectionMode.NONE) {
            this.selector = null;
            return;
        }
        else if (selectionMode === ISelectorSettings_1.SelectionMode.COPYRECT) {
            this.selector = this.rectCopySelector;
            const template = this.selectorSettings.template;
            if (template !== undefined) {
                this.rectCopySelector.setTemplate(template);
            }
            else {
                this.rectCopySelector.setTemplate(AreaSelector.DefaultTemplateSize);
            }
        }
        else if (selectionMode === ISelectorSettings_1.SelectionMode.RECT) {
            this.selector = this.rectSelector;
        }
        else if (selectionMode === ISelectorSettings_1.SelectionMode.POINT) {
            this.selector = this.pointSelector;
        }
        else if (selectionMode === ISelectorSettings_1.SelectionMode.POLYLINE) {
            this.selector = this.polylineSelector;
        }
        else if (selectionMode === ISelectorSettings_1.SelectionMode.POLYGON) {
            this.selector = this.polygonSelector;
        }
        // restore enablement status
        this.enable();
        if (this.isVisible) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * Returns current options (settings) for selector.
     */
    getSelectorSettings() {
        return this.selectorSettings;
    }
    /**
     * Creates UI of the AreaSelector.
     */
    buildUIElements() {
        this.paper = Snap(this.parentNode);
        this.boundRect = new Rect_1.Rect(this.parentNode.width.baseVal.value, this.parentNode.height.baseVal.value);
        this.areaSelectorLayer = this.paper.g();
        this.areaSelectorLayer.addClass("areaSelector");
        this.rectSelector = new RectSelector_1.RectSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.rectCopySelector = new RectCopySelector_1.RectCopySelector(this.parentNode, this.paper, this.boundRect, new Rect_1.Rect(0, 0), this.callbacks);
        this.pointSelector = new PointSelector_1.PointSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.polylineSelector = new PolylineSelector_1.PolylineSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.polygonSelector = new PolygonSelector_1.PolygonSelector(this.parentNode, this.paper, this.boundRect, this.callbacks);
        this.selector = this.rectSelector;
        this.rectSelector.enable();
        this.rectCopySelector.disable();
        this.pointSelector.disable();
        this.polylineSelector.disable();
        this.polygonSelector.disable();
        this.selector.hide();
        this.areaSelectorLayer.add(this.rectSelector.node);
        this.areaSelectorLayer.add(this.rectCopySelector.node);
        this.areaSelectorLayer.add(this.pointSelector.node);
        this.areaSelectorLayer.add(this.polylineSelector.node);
        this.areaSelectorLayer.add(this.polygonSelector.node);
    }
}
/**
 * Default template size for the `RectCopySelector`.
 * @todo Move to the `RectCopySelector` class.
 */
AreaSelector.DefaultTemplateSize = new Rect_1.Rect(20, 20);
exports.AreaSelector = AreaSelector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts":
/*!****************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const Element_1 = __webpack_require__(/*! ./Element */ "./src/canvastools/ts/CanvasTools/Selection/Component/Element.ts");
/**
 * The cross element for selectors.
 */
class CrossElement extends Element_1.Element {
    /**
     * The `x`-coordinate of the cross center.
     */
    get x() {
        return this.center.x;
    }
    /**
     * The `y`-coordinate of the cross center.
     */
    get y() {
        return this.center.y;
    }
    /**
     * Creates new `CrossElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param boundRect - The parent bounding box for selection.
     */
    constructor(paper, boundRect) {
        super(paper, boundRect);
        this.buildUIElements();
        this.hide();
    }
    /**
     * Bounds the cross center to the specified box.
     * @param rect - The bounding box.
     */
    boundToRect(rect) {
        return new Point2D_1.Point2D(this.x, this.y).boundToRect(rect);
    }
    /**
     * Moves cross to specified point, applying bounding and taking into account square movement modificator.
     * @param p - The new cross center location.
     * @param rect - The bounding box.
     * @param square - The square movement flag.
     * @param ref - The reference point for square.
     */
    move(p, boundRect, square = false, ref = null) {
        const np = new Point2D_1.Point2D(p).boundToRect(boundRect);
        if (square) {
            const dx = Math.abs(np.x - ref.x);
            const vx = Math.sign(np.x - ref.x);
            const dy = Math.abs(np.y - ref.y);
            const vy = Math.sign(np.y - ref.y);
            const d = Math.min(dx, dy);
            np.x = ref.x + d * vx;
            np.y = ref.y + d * vy;
        }
        this.center.move(np);
        this.vl.node.setAttribute("x1", np.x.toString());
        this.vl.node.setAttribute("x2", np.x.toString());
        this.vl.node.setAttribute("y2", boundRect.height.toString());
        this.hl.node.setAttribute("y1", np.y.toString());
        this.hl.node.setAttribute("x2", boundRect.width.toString());
        this.hl.node.setAttribute("y2", np.y.toString());
    }
    /**
     * Resizes the cross element to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.vl.node.setAttribute("y2", height.toString());
        this.hl.node.setAttribute("x2", width.toString());
    }
    /**
     * Builds the visual presentation of the element.
     */
    buildUIElements() {
        const verticalLine = this.paper.line(0, 0, 0, this.boundRect.height);
        const horizontalLine = this.paper.line(0, 0, this.boundRect.width, 0);
        this.node = this.paper.g();
        this.node.addClass("crossStyle");
        this.node.add(verticalLine);
        this.node.add(horizontalLine);
        this.hl = horizontalLine;
        this.vl = verticalLine;
        this.center = new Point2D_1.Point2D(0, 0);
    }
}
exports.CrossElement = CrossElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Component/Element.ts":
/*!***********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Component/Element.ts ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abstract class for building blocks of selectors.
 */
class Element {
    /**
     * Creates new `Element` object.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param boundRect - The parent bounding box for selection.
     */
    constructor(paper, boundRect) {
        /**
         * The element visibility flag.
         */
        this.isVisible = true;
        this.paper = paper;
        this.boundRect = boundRect;
    }
    /**
     * The `width` of the element.
     */
    get width() {
        return this.boundRect.width;
    }
    /**
     * The `height` of the element.
     */
    get height() {
        return this.boundRect.height;
    }
    /**
     * Makes elemement visually hidden.
     */
    hide() {
        this.node.node.setAttribute("visibility", "hidden");
        this.isVisible = false;
    }
    /**
     * Makes element visible.
     */
    show() {
        this.node.node.setAttribute("visibility", "visible");
        this.isVisible = true;
    }
    /**
     * Resizes element to specified `width` and `height`.
     * @param width - New element `width`.
     * @param height - New element `height`.
     */
    resize(width, height) {
        this.boundRect.resize(width, height);
    }
}
exports.Element = Element;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Component/MaskElement.ts":
/*!***************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Component/MaskElement.ts ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Element_1 = __webpack_require__(/*! ./Element */ "./src/canvastools/ts/CanvasTools/Selection/Component/Element.ts");
const RectElement_1 = __webpack_require__(/*! ./RectElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/RectElement.ts");
/**
 * The mask element for selectors
 */
class MaskElement extends Element_1.Element {
    /**
     * Creates a new `MaskElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param boundRect - The parent bounding box for selection.
     * @param maskOut - The element to be used as mask filter.
     */
    constructor(paper, boundRect, maskOut) {
        super(paper, boundRect);
        this.maskOut = maskOut;
        this.buildUIElements();
        this.resize(boundRect.width, boundRect.height);
        this.hide();
    }
    /**
     * Resize the element to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.mask.resize(width, height);
        this.maskIn.resize(width, height);
    }
    /**
     * Builds the visual presentation of the element.
     */
    buildUIElements() {
        this.mask = this.createMask();
        this.maskIn = this.createMaskIn();
        this.maskOut.node.addClass("maskOutStyle");
        const combinedMask = this.paper.g();
        combinedMask.add(this.maskIn.node);
        combinedMask.add(this.maskOut.node);
        this.mask.node.attr({
            mask: combinedMask,
        });
        this.node = this.mask.node;
    }
    /**
     * Helper function to build the mask rect.
     */
    createMask() {
        const r = new RectElement_1.RectElement(this.paper, this.boundRect, this.boundRect);
        r.node.addClass("maskStyle");
        return r;
    }
    /**
     * Helper function to build the mask-in rect.
     */
    createMaskIn() {
        const r = new RectElement_1.RectElement(this.paper, this.boundRect, this.boundRect);
        r.node.addClass("maskInStyle");
        return r;
    }
}
exports.MaskElement = MaskElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Component/RectElement.ts":
/*!***************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Component/RectElement.ts ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const Rect_1 = __webpack_require__(/*! ../../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const Element_1 = __webpack_require__(/*! ./Element */ "./src/canvastools/ts/CanvasTools/Selection/Component/Element.ts");
/**
 * The rect element for selectors
 */
class RectElement extends Element_1.Element {
    /**
     * The `x`-coordinate of the cross center.
     */
    get x() {
        return this.originPoint.x;
    }
    /**
     * The `y`-coordinate of the cross center.
     */
    get y() {
        return this.originPoint.y;
    }
    /**
     * Creates the new `RectElement`.
     * @param paper - The `Snap.Paper` object to draw on.
     * @param boundRect - The parent bounding box for selection.
     * @param rect - The rect size.
     */
    constructor(paper, boundRect, rect) {
        super(paper, boundRect);
        this.rect = new Rect_1.Rect(rect.width, rect.height);
        this.originPoint = new Point2D_1.Point2D(0, 0);
        this.buildUIElements();
        this.hide();
    }
    /**
     * Moves rect element to specified location.
     * @param p - The new rect location.
     */
    move(p) {
        this.node.node.setAttribute("x", p.x.toString());
        this.node.node.setAttribute("y", p.y.toString());
        this.originPoint.move(p);
    }
    /**
     * Resizes the element to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        this.rect.resize(width, height);
        this.node.node.setAttribute("height", height.toString());
        this.node.node.setAttribute("width", width.toString());
    }
    /**
     * Builds the visual presentation of the element.
     */
    buildUIElements() {
        this.node = this.paper.rect(0, 0, this.rect.width, this.rect.height);
    }
}
exports.RectElement = RectElement;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Selectors/PointSelector.ts":
/*!*****************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Selectors/PointSelector.ts ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const RegionData_1 = __webpack_require__(/*! ../../Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
const CrossElement_1 = __webpack_require__(/*! ../Component/CrossElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts");
const Selector_1 = __webpack_require__(/*! ./Selector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts");
/**
 * The selector to define a point-region.
 */
class PointSelector extends Selector_1.Selector {
    /**
     * Creates new `PointSelector` object.
     * @param parent - The parent SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, callbacks) {
        super(parent, paper, boundRect, callbacks);
        this.buildUIElements();
        this.hide();
    }
    /**
     * Resizes the selector to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.crossA.resize(width, height);
    }
    /**
     * Hides the selector.
     */
    hide() {
        super.hide();
        this.hideAll([this.crossA, this.point]);
    }
    /**
     * Shows the selector.
     */
    show() {
        super.show();
        this.showAll([this.crossA, this.point]);
    }
    /**
     * Builds selector's UI.
     */
    buildUIElements() {
        this.node = this.paper.g();
        this.node.addClass("pointSelector");
        this.crossA = new CrossElement_1.CrossElement(this.paper, this.boundRect);
        this.point = this.paper.circle(0, 0, PointSelector.DEFAULT_POINT_RADIUS);
        this.point.addClass("pointStyle");
        this.node.add(this.crossA.node);
        this.node.add(this.point);
        const listeners = [
            {
                event: "pointerenter",
                base: this.parentNode,
                listener: () => this.show(),
                bypass: false,
            },
            {
                event: "pointerleave",
                base: this.parentNode,
                listener: () => this.hide(),
                bypass: false,
            },
            {
                event: "pointerdown",
                base: this.parentNode,
                listener: (e) => {
                    this.show();
                    this.movePoint(this.point, this.crossA);
                    if (typeof this.callbacks.onSelectionBegin === "function") {
                        this.callbacks.onSelectionBegin();
                    }
                },
                bypass: false,
            },
            {
                event: "pointerup",
                base: this.parentNode,
                listener: (e) => {
                    if (typeof this.callbacks.onSelectionEnd === "function") {
                        this.callbacks.onSelectionEnd(RegionData_1.RegionData.BuildPointRegionData(this.crossA.x, this.crossA.y));
                    }
                },
                bypass: false,
            },
            {
                event: "pointermove",
                base: this.parentNode,
                listener: (e) => {
                    const rect = this.parentNode.getClientRects();
                    const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
                    this.show();
                    this.moveCross(this.crossA, p);
                    this.movePoint(this.point, this.crossA);
                    e.preventDefault();
                },
                bypass: false,
            },
        ];
        this.subscribeToEvents(listeners);
    }
}
/**
 * Default radius for the point element. Can be redefined through css styles.
 */
PointSelector.DEFAULT_POINT_RADIUS = 6;
exports.PointSelector = PointSelector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Selectors/PolygonSelector.ts":
/*!*******************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Selectors/PolygonSelector.ts ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const RegionData_1 = __webpack_require__(/*! ../../Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
const CrossElement_1 = __webpack_require__(/*! ../Component/CrossElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts");
const Selector_1 = __webpack_require__(/*! ./Selector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts");
/**
 * The selector to define a polygon-region.
 */
class PolygonSelector extends Selector_1.Selector {
    /**
     * Creates new `PolygonSelector` object.
     * @param parent - The parent SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, callbacks) {
        super(parent, paper, boundRect, callbacks);
        /**
         * Default point radius.
         */
        this.pointRadius = 3;
        /**
         * Current state of selector.
         */
        this.isCapturing = false;
        this.buildUIElements();
        this.reset();
        this.hide();
    }
    /**
     * Resizes the selector to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.crossA.resize(width, height);
    }
    /**
     * Hides the selector.
     */
    hide() {
        super.hide();
        this.hideAll([this.crossA, this.nextPoint, this.nextSegment, this.polygon, this.pointsGroup]);
    }
    /**
     * Shows the selector.
     */
    show() {
        super.show();
        this.showAll([this.crossA, this.nextPoint, this.nextSegment, this.polygon, this.pointsGroup]);
    }
    /**
     * Disables and hides this selector.
     */
    disable() {
        this.reset();
        super.disable();
    }
    /**
     * Builds selector's UI.
     */
    buildUIElements() {
        this.node = this.paper.g();
        this.node.addClass("polygonSelector");
        this.crossA = new CrossElement_1.CrossElement(this.paper, this.boundRect);
        this.nextPoint = this.paper.circle(0, 0, this.pointRadius);
        this.nextPoint.addClass("nextPointStyle");
        this.nextSegment = this.paper.g();
        this.nextL1 = this.paper.line(0, 0, 0, 0);
        this.nextLN = this.paper.line(0, 0, 0, 0);
        this.nextL1.addClass("nextSegmentStyle");
        this.nextLN.addClass("nextSegmentStyle");
        this.nextSegment.add(this.nextL1);
        this.nextSegment.add(this.nextLN);
        this.pointsGroup = this.paper.g();
        this.pointsGroup.addClass("polygonGroupStyle");
        this.polygon = this.paper.polygon([]);
        this.polygon.addClass("polygonStyle");
        this.node.add(this.polygon);
        this.node.add(this.pointsGroup);
        this.node.add(this.crossA.node);
        this.node.add(this.nextSegment);
        this.node.add(this.nextPoint);
        const listeners = [
            {
                event: "pointerenter",
                base: this.parentNode,
                listener: () => this.show(),
                bypass: false,
            },
            {
                event: "pointerleave",
                base: this.parentNode,
                listener: (e) => {
                    if (!this.isCapturing) {
                        this.hide();
                    }
                    else {
                        const rect = this.parentNode.getClientRects();
                        const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
                        this.moveCross(this.crossA, p);
                        this.movePoint(this.nextPoint, p);
                    }
                },
                bypass: false,
            },
            {
                event: "pointerdown",
                base: this.parentNode,
                listener: (e) => {
                    if (!this.isCapturing) {
                        this.isCapturing = true;
                        if (typeof this.callbacks.onSelectionBegin === "function") {
                            this.callbacks.onSelectionBegin();
                        }
                    }
                },
                bypass: false,
            },
            {
                event: "click",
                base: this.parentNode,
                listener: (e) => {
                    if (e.detail <= 1) {
                        window.requestAnimationFrame(() => {
                            const p = new Point2D_1.Point2D(this.crossA.x, this.crossA.y);
                            this.addPoint(p.x, p.y);
                            this.lastPoint = p;
                        });
                    }
                },
                bypass: false,
            },
            {
                event: "pointermove",
                base: this.parentNode,
                listener: (e) => {
                    window.requestAnimationFrame(() => {
                        const rect = this.parentNode.getClientRects();
                        const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
                        this.show();
                        this.moveCross(this.crossA, p);
                        this.movePoint(this.nextPoint, p);
                        if (this.lastPoint != null) {
                            this.moveLine(this.nextLN, this.lastPoint, p);
                            this.moveLine(this.nextL1, this.points[0], p);
                        }
                        else {
                            this.moveLine(this.nextLN, p, p);
                            this.moveLine(this.nextL1, p, p);
                        }
                    });
                    e.preventDefault();
                },
                bypass: false,
            },
            {
                event: "dblclick",
                base: this.parentNode,
                listener: () => this.submitPolygon(),
                bypass: false,
            },
            {
                event: "keyup",
                base: window,
                listener: (e) => {
                    if (e.code === "Escape") {
                        this.submitPolygon();
                    }
                },
                bypass: true,
            },
        ];
        this.subscribeToEvents(listeners);
    }
    /**
     * Resets the selector.
     */
    reset() {
        this.points = new Array();
        this.lastPoint = null;
        let ps = this.pointsGroup.children();
        while (ps.length > 0) {
            ps[0].remove();
            ps = this.pointsGroup.children();
        }
        this.polygon.attr({
            points: "",
        });
        if (this.isCapturing) {
            this.isCapturing = false;
        }
    }
    /**
     * Adds a new point to polygon at specified coordinates
     * @param x - x-coordinate of the new point.
     * @param y - y-coordinate of the new point.
     */
    addPoint(x, y) {
        this.points.push(new Point2D_1.Point2D(x, y));
        const point = this.paper.circle(x, y, this.pointRadius);
        point.addClass("polygonPointStyle");
        this.pointsGroup.add(point);
        let pointsStr = "";
        this.points.forEach((p) => {
            pointsStr += `${p.x},${p.y},`;
        });
        this.polygon.attr({
            points: pointsStr.substr(0, pointsStr.length - 1),
        });
    }
    /**
     * Submits the new polygon region to the callback function.
     */
    submitPolygon() {
        if (typeof this.callbacks.onSelectionEnd === "function") {
            const box = this.polygon.getBBox();
            this.callbacks.onSelectionEnd(new RegionData_1.RegionData(box.x, box.y, box.width, box.height, this.points.map((p) => p.copy()), RegionData_1.RegionDataType.Polygon));
        }
        this.reset();
    }
}
exports.PolygonSelector = PolygonSelector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Selectors/PolylineSelector.ts":
/*!********************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Selectors/PolylineSelector.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const RegionData_1 = __webpack_require__(/*! ../../Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
const CrossElement_1 = __webpack_require__(/*! ../Component/CrossElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts");
const Selector_1 = __webpack_require__(/*! ./Selector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts");
/**
 * The selector to define a polyline-region.
 */
class PolylineSelector extends Selector_1.Selector {
    /**
     * Creates new `PolylineSelector` object.
     * @param parent - The parent SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, callbacks) {
        super(parent, paper, boundRect, callbacks);
        /**
         * Default point radius.
         */
        this.pointRadius = 3;
        /**
         * Current state of selector.
         */
        this.isCapturing = false;
        this.buildUIElements();
        this.reset();
        this.hide();
    }
    /**
     * Resizes the selector to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.crossA.resize(width, height);
    }
    /**
     * Hides the selector.
     */
    hide() {
        super.hide();
        this.crossA.hide();
        this.nextPoint.node.setAttribute("visibility", "hidden");
        this.nextSegment.node.setAttribute("visibility", "hidden");
        this.polyline.node.setAttribute("visibility", "hidden");
        this.pointsGroup.node.setAttribute("visibility", "hidden");
    }
    /**
     * Shows the selector.
     */
    show() {
        super.show();
        this.crossA.show();
        this.nextPoint.node.setAttribute("visibility", "visible");
        this.nextSegment.node.setAttribute("visibility", "visible");
        this.polyline.node.setAttribute("visibility", "visible");
        this.pointsGroup.node.setAttribute("visibility", "visible");
    }
    /**
     * Disables and hides this selector.
     */
    disable() {
        this.reset();
        super.disable();
    }
    /**
     * Builds selector's UI.
     */
    buildUIElements() {
        this.node = this.paper.g();
        this.node.addClass("polylineSelector");
        this.crossA = new CrossElement_1.CrossElement(this.paper, this.boundRect);
        this.nextPoint = this.paper.circle(0, 0, this.pointRadius);
        this.nextPoint.addClass("nextPointStyle");
        this.nextSegment = this.paper.line(0, 0, 0, 0);
        this.nextSegment.addClass("nextSegmentStyle");
        this.pointsGroup = this.paper.g();
        this.pointsGroup.addClass("polylineGroupStyle");
        this.polyline = this.paper.polyline([]);
        this.polyline.addClass("polylineStyle");
        this.node.add(this.polyline);
        this.node.add(this.pointsGroup);
        this.node.add(this.crossA.node);
        this.node.add(this.nextSegment);
        this.node.add(this.nextPoint);
        const listeners = [
            { event: "pointerenter", listener: this.onPointerEnter, base: this.parentNode, bypass: false },
            { event: "pointerleave", listener: this.onPointerLeave, base: this.parentNode, bypass: false },
            { event: "pointerdown", listener: this.onPointerDown, base: this.parentNode, bypass: false },
            { event: "click", listener: this.onClick, base: this.parentNode, bypass: false },
            { event: "pointermove", listener: this.onPointerMove, base: this.parentNode, bypass: false },
            { event: "dblclick", listener: this.onDoubleClick, base: this.parentNode, bypass: false },
            { event: "keyup", listener: this.onKeyUp, base: window, bypass: true },
        ];
        this.subscribeToEvents(listeners);
    }
    /**
     * Resets the selector.
     */
    reset() {
        this.points = new Array();
        this.lastPoint = null;
        let ps = this.pointsGroup.children();
        while (ps.length > 0) {
            ps[0].remove();
            ps = this.pointsGroup.children();
        }
        this.polyline.attr({
            points: "",
        });
        if (this.isCapturing) {
            this.isCapturing = false;
        }
    }
    /**
     * Adds a new point to polyline at specified coordinates
     * @param x - x-coordinate of the new point.
     * @param y - y-coordinate of the new point.
     */
    addPoint(x, y) {
        this.points.push(new Point2D_1.Point2D(x, y));
        const point = this.paper.circle(x, y, this.pointRadius);
        point.addClass("polylinePointStyle");
        this.pointsGroup.add(point);
        let pointsStr = "";
        this.points.forEach((p) => {
            pointsStr += `${p.x},${p.y},`;
        });
        this.polyline.attr({
            points: pointsStr.substr(0, pointsStr.length - 1),
        });
    }
    /**
     * Listener for the pointer enter event.
     * @param e PointerEvent
     */
    onPointerEnter(e) {
        window.requestAnimationFrame(() => {
            this.show();
        });
    }
    /**
     * Listener for the pointer leave event.
     * @param e PointerEvent
     */
    onPointerLeave(e) {
        if (!this.isCapturing) {
            window.requestAnimationFrame(() => {
                this.hide();
            });
        }
        else {
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
            this.moveCross(this.crossA, p);
            this.movePoint(this.nextPoint, p);
        }
    }
    /**
     * Listener for the pointer down event.
     * @param e PointerEvent
     */
    onPointerDown(e) {
        if (!this.isCapturing) {
            this.isCapturing = true;
            if (typeof this.callbacks.onSelectionBegin === "function") {
                this.callbacks.onSelectionBegin();
            }
        }
    }
    /**
     * Listener for the mouse click event.
     * @param e MouseEvent
     */
    onClick(e) {
        if (e.detail <= 1) {
            window.requestAnimationFrame(() => {
                const p = new Point2D_1.Point2D(this.crossA.x, this.crossA.y);
                this.addPoint(p.x, p.y);
                this.lastPoint = p;
            });
        }
    }
    /**
     * Listener for the pointer move event.
     * @param e PointerEvent
     */
    onPointerMove(e) {
        window.requestAnimationFrame(() => {
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
            this.show();
            this.moveCross(this.crossA, p);
            this.movePoint(this.nextPoint, p);
            if (this.lastPoint != null) {
                this.moveLine(this.nextSegment, this.lastPoint, p);
            }
            else {
                this.moveLine(this.nextSegment, p, p);
            }
        });
        e.preventDefault();
    }
    /**
     * Listener for the mouse double click event.
     * @param e MouseEvent
     */
    onDoubleClick(e) {
        this.submitPolyline();
    }
    /**
     * Submits the new polygon region to the callback function.
     */
    submitPolyline() {
        if (typeof this.callbacks.onSelectionEnd === "function") {
            const box = this.polyline.getBBox();
            this.callbacks.onSelectionEnd(new RegionData_1.RegionData(box.x, box.y, box.width, box.height, this.getPolylinePoints(), RegionData_1.RegionDataType.Polyline));
        }
        this.reset();
    }
    /**
     * Returns the polyline points, closes it if required.
     * @param close - A flag to "close" the polyline if last point is near to the first one.
     * @param threshold - The threshold to calculate what is "near".
     */
    getPolylinePoints(close = true, threshold = 5) {
        const points = this.points.map((p) => p.copy());
        if (points.length >= 3 && close) {
            const fp = points[0];
            const lp = points[points.length - 1];
            const distanceSquare = (fp.x - lp.x) * (fp.x - lp.x) + (fp.y - lp.y) * (fp.y - lp.y);
            if (distanceSquare <= threshold * threshold) {
                points[points.length - 1] = fp.copy();
            }
        }
        return points;
    }
    /**
     * Listener for the key up event.
     * @param e KeyboardEvent
     */
    onKeyUp(e) {
        // Holding shift key enable square drawing mode
        if (e.code === "Escape") {
            this.submitPolyline();
        }
    }
}
exports.PolylineSelector = PolylineSelector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Selectors/RectCopySelector.ts":
/*!********************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Selectors/RectCopySelector.ts ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const Rect_1 = __webpack_require__(/*! ../../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const RegionData_1 = __webpack_require__(/*! ../../Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
const CrossElement_1 = __webpack_require__(/*! ../Component/CrossElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts");
const RectElement_1 = __webpack_require__(/*! ../Component/RectElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/RectElement.ts");
const Selector_1 = __webpack_require__(/*! ./Selector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts");
/**
 * The selector to define a rect-region using a template.
 */
class RectCopySelector extends Selector_1.Selector {
    /**
     * Creates new `RectCopySelector` object.
     * @param parent - The parent SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box.
     * @param copyRect - The template rect for selection.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, copyRect, callbacks) {
        super(parent, paper, boundRect, callbacks);
        this.copyRect = copyRect;
        this.buildUIElements();
        this.hide();
    }
    /**
     * Updates the template for selector.
     * @param copyRect - New template rect.
     */
    setTemplate(copyRect) {
        this.copyRect = new Rect_1.Rect(copyRect.width, copyRect.height);
        this.copyRectEl.resize(copyRect.width, copyRect.height);
        this.moveCopyRect(this.copyRectEl, this.crossA);
    }
    /**
     * Resizes the selector to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.crossA.resize(width, height);
    }
    /**
     * Hides the selector.
     */
    hide() {
        super.hide();
        this.hideAll([this.crossA, this.copyRectEl]);
    }
    /**
     * Shows the selector.
     */
    show() {
        super.show();
        this.showAll([this.crossA, this.copyRectEl]);
    }
    /**
     * Builds selector's UI.
     */
    buildUIElements() {
        this.node = this.paper.g();
        this.node.addClass("rectCopySelector");
        this.crossA = new CrossElement_1.CrossElement(this.paper, this.boundRect);
        this.copyRectEl = new RectElement_1.RectElement(this.paper, this.boundRect, this.copyRect);
        this.copyRectEl.node.addClass("copyRectStyle");
        this.node.add(this.crossA.node);
        this.node.add(this.copyRectEl.node);
        const listeners = [
            { event: "pointerenter", listener: this.onPointerEnter, base: this.parentNode, bypass: false },
            { event: "pointerleave", listener: this.onPointerLeave, base: this.parentNode, bypass: false },
            { event: "pointerdown", listener: this.onPointerDown, base: this.parentNode, bypass: false },
            { event: "pointerup", listener: this.onPointerUp, base: this.parentNode, bypass: false },
            { event: "pointermove", listener: this.onPointerMove, base: this.parentNode, bypass: false },
            { event: "wheel", listener: this.onWheel, base: this.parentNode, bypass: false },
        ];
        this.subscribeToEvents(listeners);
    }
    /**
     * Helper function to move rect to specified point.
     * @param copyRect - The rect element to move.
     * @param p - The new location.
     */
    moveCopyRect(copyRect, p) {
        const x = p.x - copyRect.rect.width / 2;
        const y = p.y - copyRect.rect.height / 2;
        copyRect.move(new Point2D_1.Point2D(x, y));
    }
    /**
     * Listener for the pointer enter event.
     * @param e PointerEvent
     */
    onPointerEnter(e) {
        window.requestAnimationFrame(() => {
            this.crossA.show();
            this.copyRectEl.show();
        });
    }
    /**
     * Listener for the pointer leave event.
     * @param e PointerEvent
     */
    onPointerLeave(e) {
        window.requestAnimationFrame(() => {
            this.hide();
        });
    }
    /**
     * Listener for the pointer down event.
     * @param e PointerEvent
     */
    onPointerDown(e) {
        window.requestAnimationFrame(() => {
            this.show();
            this.moveCopyRect(this.copyRectEl, this.crossA);
            if (typeof this.callbacks.onSelectionBegin === "function") {
                this.callbacks.onSelectionBegin();
            }
        });
    }
    /**
     * Listener for the pointer up event.
     * @param e PointerEvent
     */
    onPointerUp(e) {
        window.requestAnimationFrame(() => {
            if (typeof this.callbacks.onSelectionEnd === "function") {
                let p1 = new Point2D_1.Point2D(this.crossA.x - this.copyRect.width / 2, this.crossA.y - this.copyRect.height / 2);
                let p2 = new Point2D_1.Point2D(this.crossA.x + this.copyRect.width / 2, this.crossA.y + this.copyRect.height / 2);
                p1 = p1.boundToRect(this.boundRect);
                p2 = p2.boundToRect(this.boundRect);
                const width = p2.x - p1.x;
                const height = p2.y - p1.y;
                const regionData = RegionData_1.RegionData.BuildRectRegionData(p1.x, p1.y, width, height);
                this.callbacks.onSelectionEnd(regionData);
            }
        });
    }
    /**
     * Listener for the pointer move event.
     * @param e PointerEvent
     */
    onPointerMove(e) {
        window.requestAnimationFrame(() => {
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
            this.crossA.show();
            this.copyRectEl.show();
            this.moveCross(this.crossA, p);
            this.moveCopyRect(this.copyRectEl, this.crossA);
        });
        e.preventDefault();
    }
    /**
     * Listener for the wheel event.
     * @param e WheelEvent
     */
    onWheel(e) {
        let width = this.copyRect.width;
        let height = this.copyRect.height;
        const k = height / width;
        if (e.shiftKey) {
            if (e.deltaY > 0) {
                width *= 1.1;
                height *= 1.1;
            }
            else {
                width /= 1.1;
                height /= 1.1;
            }
        }
        else {
            if (e.deltaY > 0) {
                width += 1.0;
                height += k;
            }
            else {
                width -= 1.0;
                height -= k;
            }
        }
        if (width < 1.0) {
            width = 1.0;
            height = k;
        }
        if (height < 1.0) {
            height = 1.0;
            width = 1.0 / k;
        }
        window.requestAnimationFrame(() => {
            this.copyRect.resize(width, height);
            this.copyRectEl.resize(width, height);
            this.moveCopyRect(this.copyRectEl, this.crossA);
        });
    }
}
exports.RectCopySelector = RectCopySelector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Selectors/RectSelector.ts":
/*!****************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Selectors/RectSelector.ts ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point2D_1 = __webpack_require__(/*! ../../Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const Rect_1 = __webpack_require__(/*! ../../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const RegionData_1 = __webpack_require__(/*! ../../Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
const CrossElement_1 = __webpack_require__(/*! ../Component/CrossElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/CrossElement.ts");
const MaskElement_1 = __webpack_require__(/*! ../Component/MaskElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/MaskElement.ts");
const RectElement_1 = __webpack_require__(/*! ../Component/RectElement */ "./src/canvastools/ts/CanvasTools/Selection/Component/RectElement.ts");
const Selector_1 = __webpack_require__(/*! ./Selector */ "./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts");
/**
 * Enum to specify selection mode.
 */
var SelectionModificator;
(function (SelectionModificator) {
    SelectionModificator[SelectionModificator["RECT"] = 0] = "RECT";
    SelectionModificator[SelectionModificator["SQUARE"] = 1] = "SQUARE";
})(SelectionModificator = exports.SelectionModificator || (exports.SelectionModificator = {}));
/**
 * The selector to define a rect-region.
 */
class RectSelector extends Selector_1.Selector {
    /**
     * Creates new `RectSelector` object.
     * @param parent - The parent SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, callbacks) {
        super(parent, paper, boundRect, callbacks);
        /**
         * Internal flag for selection state.
         */
        this.capturingState = false;
        /**
         * Internal flag for selection mode.
         */
        this.isTwoPoints = false;
        /**
         * Internal flag for selection type.
         */
        this.selectionModificator = SelectionModificator.RECT;
        this.buildUIElements();
        this.hide();
    }
    /**
     * Resizes the selector to specified `width` and `height`.
     * @param width - The new `width`.
     * @param height - The new `height`.
     */
    resize(width, height) {
        super.resize(width, height);
        this.resizeAll([this.mask, this.crossA, this.crossB]);
    }
    /**
     * Hides the selector.
     */
    hide() {
        super.hide();
        this.hideAll([this.crossA, this.crossB, this.mask]);
    }
    /**
     * Shows the selector.
     */
    show() {
        super.show();
        this.crossA.show();
    }
    /**
     * Builds selector's UI.
     */
    buildUIElements() {
        this.node = this.paper.g();
        this.node.addClass("rectSelector");
        this.crossA = new CrossElement_1.CrossElement(this.paper, this.boundRect);
        this.crossB = new CrossElement_1.CrossElement(this.paper, this.boundRect);
        this.selectionBox = new RectElement_1.RectElement(this.paper, this.boundRect, new Rect_1.Rect(0, 0));
        this.selectionBox.node.addClass("selectionBoxStyle");
        this.mask = new MaskElement_1.MaskElement(this.paper, this.boundRect, this.selectionBox);
        this.node.add(this.mask.node);
        this.node.add(this.crossA.node);
        this.node.add(this.crossB.node);
        const listeners = [
            { event: "pointerenter", listener: this.onPointerEnter, base: this.parentNode, bypass: false },
            { event: "pointerleave", listener: this.onPointerLeave, base: this.parentNode, bypass: false },
            { event: "pointerdown", listener: this.onPointerDown, base: this.parentNode, bypass: false },
            { event: "pointerup", listener: this.onPointerUp, base: this.parentNode, bypass: false },
            { event: "pointermove", listener: this.onPointerMove, base: this.parentNode, bypass: false },
            { event: "keydown", listener: this.onKeyDown, base: window, bypass: false },
            { event: "keyup", listener: this.onKeyUp, base: window, bypass: true },
        ];
        this.subscribeToEvents(listeners);
    }
    /**
     * Helper function to move the rect element to specified locations.
     * @param box - The box to move.
     * @param pa - The first corner point.
     * @param pb - The opposite corner point.
     */
    moveSelectionBox(box, pa, pb) {
        const x = (pa.x < pb.x) ? pa.x : pb.x;
        const y = (pa.y < pb.y) ? pa.y : pb.y;
        const w = Math.abs(pa.x - pb.x);
        const h = Math.abs(pa.y - pb.y);
        box.move(new Point2D_1.Point2D(x, y));
        box.resize(w, h);
    }
    /**
     * Listener for the pointer enter event.
     * @param e PointerEvent
     */
    onPointerEnter(e) {
        window.requestAnimationFrame(() => {
            this.crossA.show();
        });
    }
    /**
     * Listener for the pointer leave event.
     * @param e PointerEvent
     */
    onPointerLeave(e) {
        window.requestAnimationFrame(() => {
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
            if (!this.capturingState) {
                this.hideAll([this.crossA, this.crossB, this.selectionBox]);
            }
            else if (this.isTwoPoints && this.capturingState) {
                this.moveCross(this.crossB, p);
                this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
            }
        });
    }
    /**
     * Listener for the pointer down event.
     * @param e PointerEvent
     */
    onPointerDown(e) {
        window.requestAnimationFrame(() => {
            if (!this.isTwoPoints) {
                this.capturingState = true;
                this.parentNode.setPointerCapture(e.pointerId);
                this.moveCross(this.crossB, this.crossA);
                this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                this.showAll([this.mask, this.crossB, this.selectionBox]);
                if (typeof this.callbacks.onSelectionBegin === "function") {
                    this.callbacks.onSelectionBegin();
                }
            }
        });
    }
    /**
     * Listener for the pointer up event.
     * @param e PointerEvent
     */
    onPointerUp(e) {
        window.requestAnimationFrame(() => {
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
            if (!this.isTwoPoints) {
                this.capturingState = false;
                this.parentNode.releasePointerCapture(e.pointerId);
                this.hideAll([this.crossB, this.mask]);
                if (typeof this.callbacks.onSelectionEnd === "function") {
                    const x = Math.min(this.crossA.x, this.crossB.x);
                    const y = Math.min(this.crossA.y, this.crossB.y);
                    const w = Math.abs(this.crossA.x - this.crossB.x);
                    const h = Math.abs(this.crossA.y - this.crossB.y);
                    this.callbacks.onSelectionEnd(RegionData_1.RegionData.BuildRectRegionData(x, y, w, h));
                }
            }
            else {
                if (this.capturingState) {
                    this.capturingState = false;
                    this.hideAll([this.crossB, this.mask]);
                    if (typeof this.callbacks.onSelectionEnd === "function") {
                        const x = Math.min(this.crossA.x, this.crossB.x);
                        const y = Math.min(this.crossA.y, this.crossB.y);
                        const w = Math.abs(this.crossA.x - this.crossB.x);
                        const h = Math.abs(this.crossA.y - this.crossB.y);
                        this.callbacks.onSelectionEnd(RegionData_1.RegionData.BuildRectRegionData(x, y, w, h));
                    }
                    this.moveCross(this.crossA, p);
                    this.moveCross(this.crossB, p);
                }
                else {
                    this.capturingState = true;
                    this.moveCross(this.crossB, p);
                    this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                    this.showAll([this.crossA, this.crossB, this.selectionBox, this.mask]);
                    if (typeof this.callbacks.onSelectionBegin === "function") {
                        this.callbacks.onSelectionBegin();
                    }
                }
            }
        });
    }
    /**
     * Listener for the pointer move event.
     * @param e PointerEvent
     */
    onPointerMove(e) {
        window.requestAnimationFrame(() => {
            const rect = this.parentNode.getClientRects();
            const p = new Point2D_1.Point2D(e.clientX - rect[0].left, e.clientY - rect[0].top);
            this.crossA.show();
            if (!this.isTwoPoints) {
                if (this.capturingState) {
                    this.moveCross(this.crossB, p, this.selectionModificator === SelectionModificator.SQUARE, this.crossA);
                    this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                }
                else {
                    this.moveCross(this.crossA, p);
                }
            }
            else {
                if (this.capturingState) {
                    this.moveCross(this.crossB, p, this.selectionModificator === SelectionModificator.SQUARE, this.crossA);
                    this.moveSelectionBox(this.selectionBox, this.crossA, this.crossB);
                }
                else {
                    this.moveCross(this.crossA, p);
                    this.moveCross(this.crossB, p);
                }
            }
        });
        e.preventDefault();
    }
    /**
     * Listener for the key down event.
     * @param e KeyboardEvent
     */
    onKeyDown(e) {
        // Holding shift key enable square drawing mode
        if (e.shiftKey) {
            this.selectionModificator = SelectionModificator.SQUARE;
        }
        if (e.ctrlKey && !this.capturingState) {
            this.isTwoPoints = true;
        }
    }
    /**
     * Listener for the key up event.
     * @param e KeyboardEvent
     */
    onKeyUp(e) {
        // Holding shift key enable square drawing mode
        if (!e.shiftKey) {
            this.selectionModificator = SelectionModificator.RECT;
        }
        // Holding Ctrl key to enable two point selection mode
        if (!e.ctrlKey && this.isTwoPoints) {
            this.isTwoPoints = false;
            this.capturingState = false;
            this.moveCross(this.crossA, this.crossB);
            this.hideAll([this.crossB, this.selectionBox, this.mask]);
        }
    }
}
exports.RectSelector = RectSelector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts":
/*!************************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Selection/Selectors/Selector.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Element_1 = __webpack_require__(/*! ../Component/Element */ "./src/canvastools/ts/CanvasTools/Selection/Component/Element.ts");
/**
 * The abstract class to define region selectors.
 */
class Selector extends Element_1.Element {
    /**
     * Creates new selector.
     * @param parent - The parent (host) SVG-element.
     * @param paper - The `Snap.Paper` element to draw on.
     * @param boundRect - The bounding box for selector.
     * @param callbacks - The collection of callbacks.
     */
    constructor(parent, paper, boundRect, callbacks) {
        super(paper, boundRect);
        /**
         * The flag to define if selector is enabled or disabled.
         */
        this.isEnabled = true;
        this.parentNode = parent;
        if (callbacks !== undefined) {
            this.callbacks = callbacks;
        }
        else {
            this.callbacks = {
                onLocked: null,
                onSelectionBegin: null,
                onSelectionEnd: null,
                onUnlocked: null,
            };
        }
    }
    /**
     * Enables and shows this selector.
     */
    enable() {
        if (!this.isEnabled) {
            this.isEnabled = true;
            this.show();
        }
    }
    /**
     * Disables and hides this selector.
     */
    disable() {
        if (this.isEnabled) {
            this.isEnabled = false;
            this.hide();
        }
    }
    /**
     * Helper function to subscribe collection of elements to specified listeners.
     * @param listeners - The collection of `IEventDescriptor` objects.
     */
    subscribeToEvents(listeners) {
        listeners.forEach((e) => {
            e.base.addEventListener(e.event, this.enablify(e.listener.bind(this), e.bypass));
        });
    }
    /**
     * Helper function to wrap listener with the enablement flag.
     * @param f - The function to wrap.
     * @param bypass - The `bypass` flag to define whether event should be captured.
     */
    enablify(f, bypass = false) {
        return (args) => {
            if (this.isEnabled || bypass) {
                f(args);
            }
        };
    }
    /**
     * Shows all the elements in specified array.
     * @param elements - The array of elements to show.
     */
    showAll(elements) {
        window.requestAnimationFrame(() => {
            elements.forEach((element) => {
                if (element.show !== undefined) {
                    element.show();
                }
                else {
                    element.node.setAttribute("visibility", "visible");
                }
            });
        });
    }
    /**
     * Hides all the elements in specified array.
     * @param elements - The array of elements to hide.
     */
    hideAll(elements) {
        window.requestAnimationFrame(() => {
            elements.forEach((element) => {
                if (element.hide !== undefined) {
                    element.hide();
                }
                else {
                    element.node.setAttribute("visibility", "hidden");
                }
            });
        });
    }
    /**
     * Resizes all the elements to the `boundRect` of this element.
     * @param elemenets - The array of elements to resize.
     */
    resizeAll(elements) {
        window.requestAnimationFrame(() => {
            elements.forEach((element) => {
                element.resize(this.boundRect.width, this.boundRect.height);
            });
        });
    }
    /**
     * Helper function to move the cross element to specified position.
     * @param cross - The cross element to move.
     * @param pointTo - The new position of the cross element.
     * @param square - The flag that movement should be related to reference point of a square
     */
    moveCross(cross, pointTo, square = false, ref = null) {
        cross.move(pointTo, this.boundRect, square, ref);
    }
    /**
     * Helper function to move a point element to specified position
     * @param point - The point element to move.
     * @param pointTo - The new position of the point.
     */
    movePoint(point, pointTo) {
        point.attr({
            cx: pointTo.x,
            cy: pointTo.y,
        });
    }
    /**
     * Helper function to move a line element to specified begin and end positions
     * @param line - The line element to move.
     * @param pointFrom - The begin point.
     * @param pointTo - The end point.
     */
    moveLine(line, pointFrom, pointTo) {
        line.attr({
            x1: pointFrom.x,
            x2: pointTo.x,
            y1: pointFrom.y,
            y2: pointTo.y,
        });
    }
}
exports.Selector = Selector;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Toolbar/Toolbar.ts":
/*!***********************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Toolbar/Toolbar.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rect_1 = __webpack_require__(/*! ../Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const ToolbarIcon_1 = __webpack_require__(/*! ./ToolbarIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts");
const ToolbarSelectIcon_1 = __webpack_require__(/*! ./ToolbarSelectIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSelectIcon.ts");
const ToolbarSeparator_1 = __webpack_require__(/*! ./ToolbarSeparator */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSeparator.ts");
const ToolbarSwitchIcon_1 = __webpack_require__(/*! ./ToolbarSwitchIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSwitchIcon.ts");
const ToolbarTriggerIcon_1 = __webpack_require__(/*! ./ToolbarTriggerIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarTriggerIcon.ts");
class Toolbar {
    constructor(svgHost) {
        this.iconSpace = 8;
        this.areHotKeysEnabled = true;
        this.icons = new Array();
        this.buildUIElements(svgHost);
    }
    addSelector(icon, actor) {
        const newIcon = new ToolbarSelectIcon_1.ToolbarSelectIcon(this.paper, icon, (action) => {
            this.select(action);
            actor(action);
        });
        this.addIcon(newIcon);
    }
    addSwitch(icon, actor) {
        const newIcon = new ToolbarSwitchIcon_1.ToolbarSwitchIcon(this.paper, icon, (action) => {
            actor(action);
        });
        this.addIcon(newIcon);
    }
    addSeparator() {
        const newIcon = new ToolbarSeparator_1.ToolbarSeparator(this.paper, ToolbarIcon_1.ToolbarIcon.IconWidth);
        this.addIcon(newIcon);
    }
    addTrigger(icon, actor) {
        const newIcon = new ToolbarTriggerIcon_1.ToolbarTriggerIcon(this.paper, icon, (action) => {
            actor(action);
        });
        this.addIcon(newIcon);
    }
    select(action) {
        this.icons.forEach((icon) => {
            if (icon instanceof ToolbarSelectIcon_1.ToolbarSelectIcon) {
                if (icon.description.action !== action) {
                    icon.unselect();
                }
                else {
                    icon.select();
                }
            }
        });
    }
    setSwitch(action, on) {
        const switchIcon = this.findIconByAction(action);
        if (switchIcon !== undefined && switchIcon instanceof ToolbarSwitchIcon_1.ToolbarSwitchIcon) {
            (on) ? switchIcon.select() : switchIcon.unselect();
        }
    }
    enableHotkeys() {
        this.areHotKeysEnabled = true;
    }
    disableHotkeys() {
        this.areHotKeysEnabled = false;
    }
    buildUIElements(svgHost) {
        this.baseParent = svgHost;
        this.paper = Snap(svgHost);
        this.paperRect = new Rect_1.Rect(svgHost.width.baseVal.value, svgHost.height.baseVal.value);
        const toolbarGroup = this.paper.g();
        toolbarGroup.addClass("toolbarLayer");
        this.recalculateToolbarSize();
        this.backgroundRect = this.paper.rect(0, 0, this.toolbarWidth, this.toolbarHeight);
        this.backgroundRect.addClass("toolbarBGStyle");
        toolbarGroup.add(this.backgroundRect);
        this.iconsLayer = this.paper.g();
        this.iconsLayer.addClass("iconsLayerStyle");
        toolbarGroup.add(this.iconsLayer);
        this.subscribeToKeyboardEvents();
    }
    recalculateToolbarSize(newIcon) {
        if (newIcon === undefined) {
            this.toolbarWidth = ToolbarIcon_1.ToolbarIcon.IconWidth + 2 * this.iconSpace;
            this.toolbarHeight = this.icons.length * (ToolbarIcon_1.ToolbarIcon.IconHeight + this.iconSpace) + this.iconSpace;
        }
        else {
            const width = newIcon.width + 2 * this.iconSpace;
            if (width > this.toolbarWidth) {
                this.toolbarWidth = width;
            }
            this.toolbarHeight = this.toolbarHeight + newIcon.height + this.iconSpace;
        }
    }
    updateToolbarSize() {
        this.backgroundRect.attr({
            height: this.toolbarHeight,
            width: this.toolbarWidth,
        });
    }
    addIcon(newIcon) {
        this.icons.push(newIcon);
        this.iconsLayer.add(newIcon.node);
        newIcon.move(this.iconSpace, this.toolbarHeight + this.iconSpace);
        this.recalculateToolbarSize(newIcon);
        this.updateToolbarSize();
    }
    findIconByKeycode(keycode) {
        return this.icons.find((icon) => {
            return icon.description !== null && icon.description.keycode === keycode;
        });
    }
    findIconByAction(action) {
        return this.icons.find((icon) => {
            return icon.description !== null && icon.description.action === action;
        });
    }
    subscribeToKeyboardEvents() {
        window.addEventListener("keyup", (e) => {
            if (!(e.target instanceof HTMLInputElement) &&
                !(e.target instanceof HTMLTextAreaElement) &&
                !(e.target instanceof HTMLSelectElement)) {
                if (this.areHotKeysEnabled && !e.ctrlKey && !e.altKey) {
                    const icon = this.findIconByKeycode(e.code);
                    if (icon !== undefined) {
                        if (icon instanceof ToolbarSelectIcon_1.ToolbarSelectIcon || icon instanceof ToolbarSwitchIcon_1.ToolbarSwitchIcon
                            || icon instanceof ToolbarTriggerIcon_1.ToolbarTriggerIcon) {
                            icon.activate();
                        }
                    }
                }
            }
        });
    }
}
exports.Toolbar = Toolbar;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts":
/*!***************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ToolbarItemType;
(function (ToolbarItemType) {
    ToolbarItemType[ToolbarItemType["SELECTOR"] = 0] = "SELECTOR";
    ToolbarItemType[ToolbarItemType["SWITCH"] = 1] = "SWITCH";
    ToolbarItemType[ToolbarItemType["SEPARATOR"] = 2] = "SEPARATOR";
    ToolbarItemType[ToolbarItemType["TRIGGER"] = 3] = "TRIGGER";
})(ToolbarItemType = exports.ToolbarItemType || (exports.ToolbarItemType = {}));
class ToolbarIcon {
    constructor(paper, icon) {
        this.isSelected = false;
        this.paper = paper;
        if (icon !== undefined && icon !== null) {
            this.description = icon;
            if (icon.width !== undefined) {
                this.width = icon.width;
            }
            else {
                this.width = ToolbarIcon.IconWidth;
            }
            if (icon.height !== undefined) {
                this.height = icon.height;
            }
            else {
                this.height = ToolbarIcon.IconHeight;
            }
        }
        else {
            this.description = null;
            this.width = ToolbarIcon.IconWidth;
            this.height = ToolbarIcon.IconHeight;
        }
    }
    move(x, y) {
        this.x = x;
        this.y = y;
    }
    resize(width, height) {
        this.width = width;
        this.height = height;
    }
    select() {
        this.node.addClass("selected");
        this.isSelected = true;
    }
    unselect() {
        this.node.removeClass("selected");
        this.isSelected = false;
    }
    toggleSelection() {
        if (this.isSelected) {
            this.unselect();
        }
        else {
            this.select();
        }
    }
}
ToolbarIcon.IconWidth = 48;
ToolbarIcon.IconHeight = 48;
exports.ToolbarIcon = ToolbarIcon;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSelectIcon.ts":
/*!*********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSelectIcon.ts ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ToolbarIcon_1 = __webpack_require__(/*! ./ToolbarIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts");
class ToolbarSelectIcon extends ToolbarIcon_1.ToolbarIcon {
    constructor(paper, icon, onAction) {
        super(paper, icon);
        this.onAction = onAction;
        this.buildIconUI();
    }
    activate() {
        this.onAction(this.description.action);
        this.select();
    }
    move(x, y) {
        super.move(x, y);
        this.iconBackgrounRect.attr({ x, y });
        if (this.iconImageSVG !== undefined) {
            this.iconImageSVG.attr({ x, y });
        }
    }
    resize(width, height) {
        super.resize(width, height);
        this.iconBackgrounRect.attr({
            height: this.height,
            width: this.width,
        });
        this.iconImageSVG.attr({
            height: this.height,
            width: this.width,
        });
    }
    buildIconUI() {
        this.node = this.paper.g();
        this.node.addClass("iconStyle");
        this.node.addClass("selector");
        this.iconBackgrounRect = this.paper.rect(0, 0, this.width, this.height);
        this.iconBackgrounRect.addClass("iconBGRectStyle");
        this.iconImage = this.paper.g();
        if (this.description.iconUrl !== undefined) {
            Snap.load(this.description.iconUrl, (fragment) => {
                this.iconImage.append(fragment);
                this.iconImageSVG = this.iconImage.children().find((element) => {
                    return (element.type === "svg");
                });
                if (this.iconImageSVG !== undefined) {
                    this.iconImageSVG.attr({
                        height: this.height,
                        width: this.width,
                    });
                    this.move(this.x, this.y);
                }
            });
        }
        this.iconImage.addClass("iconImageStyle");
        const title = Snap.parse(`<title>${this.description.tooltip}</title>`);
        this.node.add(this.iconBackgrounRect);
        this.node.add(this.iconImage);
        this.node.append(title);
        this.node.click((e) => {
            this.activate();
        });
    }
}
exports.ToolbarSelectIcon = ToolbarSelectIcon;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSeparator.ts":
/*!********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSeparator.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ToolbarIcon_1 = __webpack_require__(/*! ./ToolbarIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts");
/* import * as SNAPSVG_TYPE from "snapsvg";
declare var Snap: typeof SNAPSVG_TYPE; */
class ToolbarSeparator extends ToolbarIcon_1.ToolbarIcon {
    constructor(paper, width) {
        super(paper, null);
        this.buildIconUI();
        this.resize(width, 1);
    }
    move(x, y) {
        super.move(x, y);
        this.iconSeparator.attr({
            x1: x,
            x2: x + this.width,
            y1: y,
            y2: y,
        });
    }
    resize(width, height) {
        super.resize(width, 1);
        this.iconSeparator.attr({
            width: this.width,
        });
    }
    buildIconUI() {
        this.node = this.paper.g();
        this.node.addClass("iconStyle");
        this.node.addClass("separator");
        this.iconSeparator = this.paper.line(0, 0, this.width, 0);
        this.node.add(this.iconSeparator);
    }
}
exports.ToolbarSeparator = ToolbarSeparator;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSwitchIcon.ts":
/*!*********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Toolbar/ToolbarSwitchIcon.ts ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ToolbarIcon_1 = __webpack_require__(/*! ./ToolbarIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts");
/* import * as SNAPSVG_TYPE from "snapsvg";
declare var Snap: typeof SNAPSVG_TYPE; */
class ToolbarSwitchIcon extends ToolbarIcon_1.ToolbarIcon {
    constructor(paper, icon, onAction) {
        super(paper, icon);
        this.onAction = onAction;
        this.buildIconUI();
    }
    activate() {
        this.onAction(this.description.action);
        this.toggleSelection();
    }
    move(x, y) {
        super.move(x, y);
        this.iconBackgrounRect.attr({ x, y });
        if (this.iconImageSVG !== undefined) {
            this.iconImageSVG.attr({ x, y });
        }
    }
    resize(width, height) {
        super.resize(width, height);
        this.iconBackgrounRect.attr({
            height: this.height,
            width: this.width,
        });
        this.iconImageSVG.attr({
            height: this.height,
            width: this.width,
        });
    }
    buildIconUI() {
        this.node = this.paper.g();
        this.node.addClass("iconStyle");
        this.node.addClass("switch");
        this.iconBackgrounRect = this.paper.rect(0, 0, this.width, this.height);
        this.iconBackgrounRect.addClass("iconBGRectStyle");
        this.iconImage = this.paper.g();
        if (this.description.iconUrl !== undefined) {
            Snap.load(this.description.iconUrl, (fragment) => {
                this.iconImage.append(fragment);
                this.iconImageSVG = this.iconImage.children().find((element) => {
                    return (element.type === "svg");
                });
                if (this.iconImageSVG !== undefined) {
                    this.iconImageSVG.attr({
                        height: this.height,
                        width: this.width,
                    });
                    this.move(this.x, this.y);
                }
            });
        }
        this.iconImage.addClass("iconImageStyle");
        const title = Snap.parse(`<title>${this.description.tooltip}</title>`);
        this.node.add(this.iconBackgrounRect);
        this.node.add(this.iconImage);
        this.node.append(title);
        this.node.click((e) => {
            this.activate();
        });
    }
}
exports.ToolbarSwitchIcon = ToolbarSwitchIcon;


/***/ }),

/***/ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarTriggerIcon.ts":
/*!**********************************************************************!*\
  !*** ./src/canvastools/ts/CanvasTools/Toolbar/ToolbarTriggerIcon.ts ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ToolbarIcon_1 = __webpack_require__(/*! ./ToolbarIcon */ "./src/canvastools/ts/CanvasTools/Toolbar/ToolbarIcon.ts");
class ToolbarTriggerIcon extends ToolbarIcon_1.ToolbarIcon {
    constructor(paper, icon, onAction) {
        super(paper, icon);
        this.onAction = onAction;
        this.buildIconUI();
    }
    activate() {
        this.onAction(this.description.action);
    }
    move(x, y) {
        super.move(x, y);
        this.iconBackgrounRect.attr({ x, y });
        if (this.iconImageSVG !== undefined) {
            this.iconImageSVG.attr({ x, y });
        }
    }
    resize(width, height) {
        super.resize(width, height);
        this.iconBackgrounRect.attr({
            height: this.height,
            width: this.width,
        });
        this.iconImageSVG.attr({
            height: this.height,
            width: this.width,
        });
    }
    buildIconUI() {
        this.node = this.paper.g();
        this.node.addClass("iconStyle");
        this.node.addClass("selector");
        this.iconBackgrounRect = this.paper.rect(0, 0, this.width, this.height);
        this.iconBackgrounRect.addClass("iconBGRectStyle");
        this.iconImage = this.paper.g();
        if (this.description.iconUrl !== undefined) {
            Snap.load(this.description.iconUrl, (fragment) => {
                this.iconImage.append(fragment);
                this.iconImageSVG = this.iconImage.children().find((element) => {
                    return (element.type === "svg");
                });
                if (this.iconImageSVG !== undefined) {
                    this.iconImageSVG.attr({
                        height: this.height,
                        width: this.width,
                    });
                    this.move(this.x, this.y);
                }
            });
        }
        this.iconImage.addClass("iconImageStyle");
        const title = Snap.parse(`<title>${this.description.tooltip}</title>`);
        this.node.add(this.iconBackgrounRect);
        this.node.add(this.iconImage);
        this.node.append(title);
        this.node.click((e) => {
            this.activate();
        });
    }
}
exports.ToolbarTriggerIcon = ToolbarTriggerIcon;


/***/ }),

/***/ "./src/canvastools/ts/ct.ts":
/*!**********************************!*\
  !*** ./src/canvastools/ts/ct.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Toolbar_1 = __webpack_require__(/*! ./CanvasTools/Toolbar/Toolbar */ "./src/canvastools/ts/CanvasTools/Toolbar/Toolbar.ts");
const RegionsManager_1 = __webpack_require__(/*! ./CanvasTools/Region/RegionsManager */ "./src/canvastools/ts/CanvasTools/Region/RegionsManager.ts");
const PointRegion_1 = __webpack_require__(/*! ./CanvasTools/Region/Point/PointRegion */ "./src/canvastools/ts/CanvasTools/Region/Point/PointRegion.ts");
const RectRegion_1 = __webpack_require__(/*! ./CanvasTools/Region/Rect/RectRegion */ "./src/canvastools/ts/CanvasTools/Region/Rect/RectRegion.ts");
const AreaSelector_1 = __webpack_require__(/*! ./CanvasTools/Selection/AreaSelector */ "./src/canvastools/ts/CanvasTools/Selection/AreaSelector.ts");
const ISelectorSettings_1 = __webpack_require__(/*! ./CanvasTools/Interface/ISelectorSettings */ "./src/canvastools/ts/CanvasTools/Interface/ISelectorSettings.ts");
const CanvasTools_Filter_1 = __webpack_require__(/*! ./CanvasTools/CanvasTools.Filter */ "./src/canvastools/ts/CanvasTools/CanvasTools.Filter.ts");
const Rect_1 = __webpack_require__(/*! ./CanvasTools/Core/Rect */ "./src/canvastools/ts/CanvasTools/Core/Rect.ts");
const Point2D_1 = __webpack_require__(/*! ./CanvasTools/Core/Point2D */ "./src/canvastools/ts/CanvasTools/Core/Point2D.ts");
const RegionData_1 = __webpack_require__(/*! ./CanvasTools/Core/RegionData */ "./src/canvastools/ts/CanvasTools/Core/RegionData.ts");
const Tag_1 = __webpack_require__(/*! ./CanvasTools/Core/Tag */ "./src/canvastools/ts/CanvasTools/Core/Tag.ts");
const TagsDescriptor_1 = __webpack_require__(/*! ./CanvasTools/Core/TagsDescriptor */ "./src/canvastools/ts/CanvasTools/Core/TagsDescriptor.ts");
const CanvasTools_Editor_1 = __webpack_require__(/*! ./CanvasTools/CanvasTools.Editor */ "./src/canvastools/ts/CanvasTools/CanvasTools.Editor.ts");
const RGBColor_1 = __webpack_require__(/*! ./CanvasTools/Core/Colors/RGBColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/RGBColor.ts");
const LABColor_1 = __webpack_require__(/*! ./CanvasTools/Core/Colors/LABColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/LABColor.ts");
const XYZColor_1 = __webpack_require__(/*! ./CanvasTools/Core/Colors/XYZColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/XYZColor.ts");
const HSLColor_1 = __webpack_require__(/*! ./CanvasTools/Core/Colors/HSLColor */ "./src/canvastools/ts/CanvasTools/Core/Colors/HSLColor.ts");
const Palette_1 = __webpack_require__(/*! ./CanvasTools/Core/Colors/Palette */ "./src/canvastools/ts/CanvasTools/Core/Colors/Palette.ts");
const Color_1 = __webpack_require__(/*! ./CanvasTools/Core/Colors/Color */ "./src/canvastools/ts/CanvasTools/Core/Colors/Color.ts");
__webpack_require__(/*! snapsvg-cjs */ "./node_modules/snapsvg-cjs/dist/snap.svg-cjs.js");
/* import * as SNAPSVG_TYPE from "snapsvg";
declare var Snap: typeof SNAPSVG_TYPE; */
class CanvasTools {
}
/**
 * Core internal classes.
 */
CanvasTools.Core = {
    Rect: Rect_1.Rect,
    Point2D: Point2D_1.Point2D,
    RegionData: RegionData_1.RegionData,
    TagsDescriptor: TagsDescriptor_1.TagsDescriptor,
    Tag: Tag_1.Tag,
    Colors: {
        RGBColor: RGBColor_1.RGBColor,
        LABColor: LABColor_1.LABColor,
        XYZColor: XYZColor_1.XYZColor,
        HSLColor: HSLColor_1.HSLColor,
        Palette: Palette_1.Palette,
        Color: Color_1.Color,
    },
};
/**
 * Classes for new region selection (creation).
 */
CanvasTools.Selection = {
    AreaSelector: AreaSelector_1.AreaSelector,
    SelectionMode: ISelectorSettings_1.SelectionMode,
};
/**
 * Classes for regions management.
 */
CanvasTools.Region = {
    RegionsManager: RegionsManager_1.RegionsManager,
    PointRegion: PointRegion_1.PointRegion,
    RectRegion: RectRegion_1.RectRegion,
};
/**
 * Classes and functions to apply filters to the source image.
 */
CanvasTools.Filters = {
    InvertFilter: CanvasTools_Filter_1.InvertFilter,
    GrayscaleFilter: CanvasTools_Filter_1.GrayscaleFilter,
    BlurDiffFilter: CanvasTools_Filter_1.BlurDiffFilter,
    ContrastFilter: CanvasTools_Filter_1.ContrastFilter,
    BrightnessFilter: CanvasTools_Filter_1.BrightnessFilter,
    SaturationFilter: CanvasTools_Filter_1.SaturationFilter,
};
/**
 * The Editor component.
 */
CanvasTools.Editor = CanvasTools_Editor_1.Editor;
/**
 * The Toolbar component.
 */
CanvasTools.Toolbar = Toolbar_1.Toolbar;
exports.CanvasTools = CanvasTools;
/* CSS */
__webpack_require__(/*! ./../css/canvastools.css */ "./src/canvastools/css/canvastools.css");


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvY3NzL2NhbnZhc3Rvb2xzLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZS9ldmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NuYXBzdmctY2pzL2Rpc3Qvc25hcC5zdmctY2pzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy9jc3MvY2FudmFzdG9vbHMuY3NzPzNmNzMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL0NhbnZhc1Rvb2xzLkVkaXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvQ2FudmFzVG9vbHMuRmlsdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Db3JlL0NvbG9ycy9Db2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvQ29yZS9Db2xvcnMvSFNMQ29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL0NvcmUvQ29sb3JzL0xBQkNvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Db3JlL0NvbG9ycy9QYWxldHRlLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Db3JlL0NvbG9ycy9SR0JDb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvQ29yZS9Db2xvcnMvU1JHQkNvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Db3JlL0NvbG9ycy9YWVpDb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvQ29yZS9Qb2ludDJELnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Db3JlL1JlY3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL0NvcmUvUmVnaW9uRGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvQ29yZS9UYWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL0NvcmUvVGFnc0Rlc2NyaXB0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9JbnRlcmZhY2UvSVNlbGVjdG9yU2V0dGluZ3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9Db21wb25lbnQvQW5jaG9yc0NvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL0NvbXBvbmVudC9EcmFnQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vQ29tcG9uZW50L1JlZ2lvbkNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL0NvbXBvbmVudC9UYWdzQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vUG9pbnQvRHJhZ0VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9Qb2ludC9Qb2ludFJlZ2lvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL1BvaW50L1RhZ3NFbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vUG9seWdvbi9BbmNob3JzRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL1BvbHlnb24vRHJhZ0VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9Qb2x5Z29uL1BvbHlnb25SZWdpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9Qb2x5Z29uL1RhZ3NFbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vUG9seWxpbmUvQW5jaG9yc0VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9Qb2x5bGluZS9EcmFnRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL1BvbHlsaW5lL1BvbHlsaW5lUmVnaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vUG9seWxpbmUvVGFnc0VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9SZWN0L0FuY2hvcnNFbGVtZW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL1JlY3QvRHJhZ0VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9SZWN0L1JlY3RSZWdpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1JlZ2lvbi9SZWN0L1RhZ3NFbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vUmVnaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9SZWdpb24vUmVnaW9uTWVudS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvUmVnaW9uL1JlZ2lvbnNNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9TZWxlY3Rpb24vQXJlYVNlbGVjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9TZWxlY3Rpb24vQ29tcG9uZW50L0Nyb3NzRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvU2VsZWN0aW9uL0NvbXBvbmVudC9FbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9TZWxlY3Rpb24vQ29tcG9uZW50L01hc2tFbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9TZWxlY3Rpb24vQ29tcG9uZW50L1JlY3RFbGVtZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9TZWxlY3Rpb24vU2VsZWN0b3JzL1BvaW50U2VsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1NlbGVjdGlvbi9TZWxlY3RvcnMvUG9seWdvblNlbGVjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9TZWxlY3Rpb24vU2VsZWN0b3JzL1BvbHlsaW5lU2VsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1NlbGVjdGlvbi9TZWxlY3RvcnMvUmVjdENvcHlTZWxlY3Rvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvU2VsZWN0aW9uL1NlbGVjdG9ycy9SZWN0U2VsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1NlbGVjdGlvbi9TZWxlY3RvcnMvU2VsZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc3Rvb2xzL3RzL0NhbnZhc1Rvb2xzL1Rvb2xiYXIvVG9vbGJhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvVG9vbGJhci9Ub29sYmFySWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvVG9vbGJhci9Ub29sYmFyU2VsZWN0SWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvQ2FudmFzVG9vbHMvVG9vbGJhci9Ub29sYmFyU2VwYXJhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Ub29sYmFyL1Rvb2xiYXJTd2l0Y2hJY29uLnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXN0b29scy90cy9DYW52YXNUb29scy9Ub29sYmFyL1Rvb2xiYXJUcmlnZ2VySWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2FudmFzdG9vbHMvdHMvY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQSwyQkFBMkIsbUJBQU8sQ0FBQyxtR0FBa0Q7QUFDckY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLDZGQUE2RixnRUFBZ0UsdWlCQUF1aUIsNkRBQTZELDQ3QkFBNDdCLCtEQUErRCxtcUNBQW1xQywrREFBK0QsK29CQUErb0IsNERBQTRELG15QkFBbXlCLEtBQUssaURBQWlELHNCQUFzQixnQ0FBZ0MsbUNBQW1DLHFCQUFxQixxQkFBcUIsZ0NBQWdDLEtBQUssOEJBQThCLGdDQUFnQyxLQUFLLG1DQUFtQywyQkFBMkIsb0JBQW9CLHVCQUF1QixxQkFBcUIsb0JBQW9CLHFCQUFxQiw2QkFBNkIsK0JBQStCLEtBQUssZ0NBQWdDLDJCQUEyQixvQkFBb0IsdUJBQXVCLHFCQUFxQixvQkFBb0IscUJBQXFCLEtBQUssZ0NBQWdDLHNDQUFzQyxLQUFLLHNRQUFzUSw2QkFBNkIsS0FBSyxzQkFBc0IsdUNBQXVDLEtBQUssd0JBQXdCLDBCQUEwQix5QkFBeUIsNEJBQTRCLG1DQUFtQyxLQUFLLHlCQUF5Qix3QkFBd0IsNEJBQTRCLG1DQUFtQyxpQ0FBaUMsS0FBSyxvQkFBb0IsNkJBQTZCLEtBQUssOEJBQThCLHdCQUF3QixnQ0FBZ0MsOEJBQThCLGlDQUFpQyxLQUFLLCtCQUErQix3QkFBd0IsTUFBTSw4QkFBOEIscUVBQXFFLHVCQUF1QixtQkFBbUIsMEJBQTBCLEtBQUssNEJBQTRCLHdCQUF3Qiw2QkFBNkIsS0FBSyxzQkFBc0Isd0JBQXdCLEtBQUssNEJBQTRCLHFDQUFxQyxLQUFLLG1DQUFtQyxxQ0FBcUMsS0FBSyxnQ0FBZ0Msa0NBQWtDLEtBQUssNEJBQTRCLHdCQUF3QixLQUFLLG1DQUFtQywwQkFBMEIsS0FBSywyREFBMkQsd0JBQXdCLDhCQUE4QixnQ0FBZ0MsS0FBSyxxREFBcUQsaURBQWlELHlEQUF5RCxvREFBb0QseURBQXlELDREQUE0RCxrREFBa0QsMkRBQTJELHVEQUF1RCx1REFBdUQscURBQXFELEtBQUssMERBQTBELDBDQUEwQyxLQUFLLHNCQUFzQiwwQ0FBMEMsd0NBQXdDLEtBQUsseUNBQXlDLDJDQUEyQyxLQUFLLDRCQUE0QiwrQ0FBK0MsS0FBSyxrSUFBa0kseUNBQXlDLEtBQUssNEJBQTRCLDJDQUEyQyxLQUFLLGlFQUFpRSwwQ0FBMEMsMkNBQTJDLEtBQUssaURBQWlELDZDQUE2QywyQ0FBMkMsS0FBSyxvREFBb0QsNkNBQTZDLCtCQUErQixLQUFLLGdDQUFnQyx3Q0FBd0MsS0FBSywwQkFBMEIsK0NBQStDLEtBQUssb0VBQW9FLHdDQUF3QywwQ0FBMEMsS0FBSyx5QkFBeUIseUNBQXlDLHFCQUFxQixLQUFLLHNGQUFzRix5Q0FBeUMscUJBQXFCLEtBQUssbUZBQW1GLDBDQUEwQywyQ0FBMkMsc0JBQXNCLEtBQUsseURBQXlELDZDQUE2QyxLQUFLLHNEQUFzRCw2Q0FBNkMsMkNBQTJDLEtBQUssa0NBQWtDLCtDQUErQywwQ0FBMEMsS0FBSyx3REFBd0QsaUNBQWlDLCtCQUErQixLQUFLLGlDQUFpQywwQ0FBMEMsMENBQTBDLEtBQUssdURBQXVELDZDQUE2QyxpQ0FBaUMsK0JBQStCLEtBQUssb0RBQW9ELDZDQUE2QyxLQUFLLDRLQUE0Syw0Q0FBNEMsMEJBQTBCLCtDQUErQyxLQUFLLGdLQUFnSyx5Q0FBeUMsMEJBQTBCLCtDQUErQyxLQUFLLDBCQUEwQixtQkFBbUIsd0JBQXdCLGlEQUFpRCxPQUFPLG1DQUFtQywwQkFBMEIsS0FBSyx3QkFBd0Isd0JBQXdCLG9DQUFvQyxpQ0FBaUMsTUFBTSx1QkFBdUIsMEJBQTBCLHlDQUF5QywrQkFBK0IsS0FBSyxtQkFBbUIsMkVBQTJFLHdCQUF3Qiw4QkFBOEIsS0FBSyxtQkFBbUIsMEJBQTBCLHlDQUF5Qyx5QkFBeUIsS0FBSyx5QkFBeUIseUNBQXlDLEtBQUssb01BQW9NLDZCQUE2QixLQUFLLCtTQUErUyx3QkFBd0IsTUFBTSxrREFBa0Qsc0JBQXNCLEtBQUssaUdBQWlHLHFCQUFxQixLQUFLLDZRQUE2USx3QkFBd0IsOEJBQThCLEtBQUssNkRBQTZELHNCQUFzQixLQUFLLHVJQUF1SSxzQkFBc0IsS0FBSywrd0JBQSt3QiwyQkFBMkIsb0JBQW9CLHFCQUFxQiw2QkFBNkIsS0FBSywwQkFBMEIsdUJBQXVCLDhCQUE4QixxQkFBcUIsNkJBQTZCLE1BQU0sa0NBQWtDLG1CQUFtQiwwQkFBMEIsd0JBQXdCLDZCQUE2QixLQUFLLHNCQUFzQixtQkFBbUIsd0JBQXdCLDRCQUE0Qiw2QkFBNkIsS0FBSyx1QkFBdUIsZ0RBQWdELHdCQUF3Qiw0QkFBNEIsNkJBQTZCLEtBQUssMENBQTBDLHVCQUF1QixxQkFBcUIsMEJBQTBCLDZCQUE2QixNQUFNLG9DQUFvQyx1QkFBdUIsd0NBQXdDLDBCQUEwQiw2QkFBNkIsTUFBTSwwQ0FBMEMsMEJBQTBCLDBCQUEwQix5Q0FBeUMsNkJBQTZCLEtBQUssK0NBQStDLHVDQUF1Qyx3QkFBd0IsNkJBQTZCLEtBQUssNkNBQTZDLHVCQUF1Qiw4QkFBOEIsd0NBQXdDLDZCQUE2QixLQUFLLHVDQUF1Qyx1QkFBdUIsZUFBZSx3Q0FBd0MsMEJBQTBCLDZCQUE2QixLQUFLLHdDQUF3QyxxQ0FBcUMsMEJBQTBCLHlDQUF5Qyw2QkFBNkIsS0FBSyw2Q0FBNkMsdUNBQXVDLHdCQUF3Qiw2QkFBNkIsS0FBSyw0Q0FBNEMsdUJBQXVCLDhCQUE4Qix3Q0FBd0MsNkJBQTZCLEtBQUssc0NBQXNDLHVCQUF1QixlQUFlLHdDQUF3QywwQkFBMEIsNkJBQTZCLEtBQUssdU1BQXVNLG1CQUFtQixLQUFLLG9CQUFvQiw0QkFBNEIsS0FBSyw2Q0FBNkMsMEJBQTBCLEtBQUssbURBQW1ELG9DQUFvQyxLQUFLLHVEQUF1RCxtQkFBbUIsS0FBSyxzQ0FBc0MscUJBQXFCLEtBQUssK0NBQStDLDBCQUEwQixLQUFLLGlEQUFpRCxvQ0FBb0MsS0FBSyw2Q0FBNkMscUJBQXFCLEtBQUssc0RBQXNELGtDQUFrQywwQkFBMEIsS0FBSyw4Q0FBOEMsc0NBQXNDLEtBQUssOENBQThDLHdDQUF3QyxLQUFLLG1DQUFtQyxxQkFBcUIsNEJBQTRCLEtBQUs7O0FBRTc5aEI7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7O0FBRWxFO0FBQ0E7Ozs7Ozs7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLHFGQUFxRixNQUFNO0FBQzNGO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxZQUFZLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLHNCQUFzQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFVBQVU7QUFDcEc7QUFDQSxrRkFBa0YsV0FBVztBQUM3RjtBQUNBLDRGQUE0RixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixXQUFXO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdELGFBQWE7QUFDYiw4QkFBOEIsOEJBQThCO0FBQzVELGFBQWE7QUFDYiw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxNQUFNLFdBQVcsT0FBTyxZQUFZLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sR0FBRyxTQUFTO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0NBQW9DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLGFBQWE7QUFDN0Isb0JBQW9CLGFBQWE7QUFDakMsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixRQUFRO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSyxrQkFBa0IsR0FBRyxPQUFPLEdBQUcsOENBQThDLE1BQU0sb0dBQW9HLFFBQVE7QUFDaFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLE9BQU8sRUFBRSxRQUFRLHVDQUF1QyxPQUFPLEVBQUUsUUFBUSx1Q0FBdUMsT0FBTyxFQUFFLFFBQVE7QUFDdE47QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU8sa0NBQWtDLE9BQU8sa0NBQWtDLE9BQU87QUFDeks7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPLGNBQWMsUUFBUSxrQ0FBa0MsT0FBTyxjQUFjLFFBQVEsa0NBQWtDLE9BQU8sY0FBYyxRQUFRO0FBQzNPO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixRQUFRO0FBQ1I7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1REFBdUQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxREFBcUQ7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O1lBRXhHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ3hFLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBQ3hFLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDO1lBRXhFOzt1RUFFMkQ7WUFDM0QsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDO1NBQzFFO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFD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QVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUUsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBRTVCLE1BQU0sQ0FBQyxHQUFHLFVBQVUsR0FBRyxHQUFHLENBQUM7UUFFM0IsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQztRQUM1QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3JDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEIsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN0QixNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLE1BQU0sRUFBRSxHQUFHLEtBQUssR0FBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1lBQzlDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFFLEtBQUssR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDMUQsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUUsS0FBSyxHQUFHLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFH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RyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ2pFLE1BQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDNUIsTUFBTSxFQUFFLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDNUIsTUFBTSxVQUFVLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakMsTUFBTSxVQUFVLEdBQUcsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakMsTUFBTSxDQUFDLEdBQUcsVUFBVSxHQUFHLFVBQVUsR0FBRyxVQUFVLEdBQUcsVUFBVSxHQUFHLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFDdEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVNLGFBQWEsQ0FBQyxLQUFlO1FBQ2hDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDakMsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUVsQyxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDZixNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDZixNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUM7UUFDZixNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUM7UUFDakIsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBRWpCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDO1FBQ2hDLE1BQU0sT0FBTyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBRWhDLE1BQU0sTUFBTSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDdkIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDeEMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUN4QyxNQUFNLElBQUksR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUN4QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RCxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztRQUM1QyxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztRQUM1QyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLEdB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O2dCQUNOLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNaLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQ3pCLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNaLEtBQUssR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixNQUFNO2FBQ1Q7WUFDRCxLQUFLLEdBQUcsQ0FBQyxDQUFDO2dCQUNOLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQ3pCLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNaLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7Z0JBQzFCLEtBQUssR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixNQUFNO2FBQ1Q7U0FDSjtRQUVELElBQUksS0FBSyxHQUFXLEVBQUUsQ0FBQztRQUN2QixJQUFJLFlBQVksS0FBSyxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbEQsS0FBSyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0UsS0FBSyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbEY7UUFDRCxJQUFJLFlBQVksS0FBSyxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbEQsSUFBSSxLQUFLLEVBQUU7Z0JBQ1AsS0FBSyxHQUFHLENBQUMsWUFBWSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQzthQUM5QztpQkFBTSxJQUFJLEtBQUssRUFBRTtnQkFDZCxLQUFLLEdBQUcsQ0FBQyxZQUFZLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO2FBQzlDO2lCQUFNO2dCQUNILEtBQUssR0FBRyxZQUFZLENBQUM7YUFDeEI7U0FDSjtRQUVELElBQUksWUFBWSxLQUFLLEtBQUssRUFBRTtZQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMzQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUNwQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNsRTtpQkFBTTtnQkFDSCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDekU7WUFFRCxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsTUFBTSxFQUFFLEdBQUcsSUFBSSxpQkFBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN2RixNQUFNLEVBQUUsR0FBRyxJQUFJLGlCQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXZGLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbEMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLGlCQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksaUJBQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFekUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLGtDQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7T0FHRztJQUNPLG1CQUFtQixDQUFDLENBQWU7UUFDekMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7UUFDbEQsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7O09BR0c7SUFDTyxtQkFBbUIsQ0FBQyxDQUFlO1FBQ3pDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLDJCQUEyQixDQUFDLElBQWtCLEVBQUUsS0FBYTtRQUNuRSxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNoQiwwQ0FBMEM7Z0JBQzFDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxpQkFBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNwRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO2dCQUUvQiwrQ0FBK0M7Z0JBQy9DLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUU7b0JBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO3dCQUNsQixFQUFFLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO3dCQUNyQixFQUFFLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO3dCQUNyQixPQUFPLEVBQUUsT0FBTztxQkFDbkIsQ0FBQyxDQUFDO2dCQUNQLENBQUMsQ0FBQyxDQUFDO2dCQUNILElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO2FBQzlCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlO1FBQ25CLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLENBQUMsRUFBRTtZQUM3Qiw0QkFBNEI7WUFDNUIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDekQ7YUFBTTtZQUNILDZEQUE2RDtZQUM3RCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM3RDtJQUNMLENBQUM7Q0FFSjtBQXZSRCx3Q0F1UkM7Ozs7Ozs7Ozs7Ozs7OztBQ2hTRCxvSkFBMkQ7QUFFM0Q7O0dBRUc7QUFDSCxNQUFhLFdBQVksU0FBUSw2QkFBYTtJQUMxQzs7Ozs7O09BTUc7SUFDSCxZQUFZLEtBQWlCLEVBQUUsWUFBa0IsSUFBSSxFQUFFLFVBQXNCLEVBQUUsU0FBMkI7UUFDdEcsS0FBSyxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBRS9DLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4RixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUV4QyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFN0IsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTTtRQUNULE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUU7WUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ2YsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7Z0JBQ2pCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDWixDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSjtBQWhDRCxrQ0FnQ0M7Ozs7Ozs7Ozs7Ozs7OztBQzFDRCwyR0FBdUM7QUFRdkMsMkdBQW1DO0FBQ25DLDBJQUFtRDtBQUNuRCw4SEFBNEM7QUFDNUMsOEhBQTRDO0FBRTVDOztHQUVHO0FBQ0gsTUFBYSxVQUFXLFNBQVEsZUFBTTtJQTBCbEM7Ozs7Ozs7OztPQVNHO0lBQ0gsWUFBWSxLQUFpQixFQUFFLFlBQWtCLElBQUksRUFBRSxVQUFzQixFQUFFLFNBQTJCLEVBQzlGLEVBQVUsRUFBRSxjQUE4QixFQUFFLGlCQUFzQztRQUMxRixLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUV0RixJQUFJLFNBQVMsS0FBSyxJQUFJLEVBQUU7WUFDcEIsSUFBSSxDQUFDLFVBQVUsR0FBRztnQkFDZCxNQUFNLEVBQUUsSUFBSSxXQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQztnQkFDMUYsSUFBSSxFQUFFLFNBQVM7YUFDbEIsQ0FBQztTQUNMO1FBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFVBQVUsQ0FBQyxJQUFvQixFQUFFLE9BQTRCO1FBQ2hFLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUN0RixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxLQUFhLEVBQUUsTUFBYztRQUN2QyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUM7UUFDeEcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFFBQVEsQ0FBQyxTQUEwQixFQUFFLFVBQXNCLEVBQUUsS0FBc0IsRUFDMUUsaUJBQTBCLEtBQUs7UUFDM0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsS0FBSyxFQUM3QyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQy9FLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7T0FHRztJQUNLLE9BQU8sQ0FBQyxLQUFpQjtRQUM3QixJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFakMsTUFBTSxTQUFTLEdBQUc7WUFDZCxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ2xDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3hELGlCQUFpQixFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ3ZELENBQUM7UUFFRixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksZ0NBQWMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUM5RixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUkseUJBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUMzRixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUkseUJBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFDNUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQ3hDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRXhELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNoRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBYyxDQUFDLENBQUM7UUFFdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNoRSxDQUFDO0NBQ0o7QUFuSEQsZ0NBbUhDOzs7Ozs7Ozs7Ozs7Ozs7QUM3SEQsb0pBQTJEO0FBRTNEOztHQUVHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsNkJBQWE7SUFxQjFDOzs7Ozs7Ozs7T0FTRztJQUNILFlBQVksS0FBaUIsRUFBRSxTQUFlLEVBQUUsVUFBc0IsRUFBRSxJQUFvQixFQUFFLE9BQWUsRUFDakcsVUFBeUIsRUFBRSxpQkFBc0M7UUFDekUsS0FBSyxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFFbEYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLGNBQXVCLEtBQUs7UUFDdEMsNkJBQTZCO1FBQzdCLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNYLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUU7Z0JBQzlCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLElBQUksRUFBRTtvQkFDL0QsMEJBQTBCO29CQUMxQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQzt3QkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO3dCQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7d0JBQ2pCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7cUJBQ1osQ0FBQyxDQUFDO29CQUVILDBCQUEwQjtvQkFDMUIsSUFBSSxXQUFXLEVBQUU7d0JBQ2IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO3dCQUNoRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUM7cUJBQ2hEO29CQUVELE1BQU0sYUFBYSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUM7MkJBQ25DLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUUvRCxJQUFJLGFBQWEsRUFBRTt3QkFDZixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDOzRCQUN2QixNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQzs0QkFDL0IsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUU7NEJBQzlCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7NEJBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQzt5QkFDaEIsQ0FBQyxDQUFDO3dCQUNILElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDOzRCQUNyQixVQUFVLEVBQUUsU0FBUzs0QkFDckIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQzs0QkFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU07eUJBQ2xDLENBQUMsQ0FBQztxQkFDTjt5QkFBTTt3QkFDSCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDOzRCQUN2QixNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQzs0QkFDakMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUM7NEJBQy9CLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzs0QkFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7eUJBQ1osQ0FBQyxDQUFDO3dCQUNILElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDOzRCQUNyQixVQUFVLEVBQUUsUUFBUTs0QkFDcEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQzs0QkFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU07eUJBQ2xDLENBQUMsQ0FBQztxQkFDTjtpQkFDSjtxQkFBTTtvQkFDSCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQzt3QkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO3dCQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7d0JBQ2pCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7cUJBQ1osQ0FBQyxDQUFDO29CQUNILElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7d0JBQ3ZCLE1BQU0sRUFBRSxDQUFDO3dCQUNULEtBQUssRUFBRSxDQUFDO3FCQUNYLENBQUMsQ0FBQztvQkFDSCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQzt3QkFDckIsVUFBVSxFQUFFLFFBQVE7d0JBQ3BCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUM7d0JBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNO3FCQUNsQyxDQUFDLENBQUM7aUJBQ047Z0JBRUQsOENBQThDO2dCQUM5QyxJQUFJLFdBQVcsRUFBRTtvQkFDYixJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO3dCQUMvQixHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7b0JBQ2pCLENBQUMsQ0FBQyxDQUFDO29CQUNILElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO2lCQUMzQjtnQkFFRCwwQkFBMEI7Z0JBQzFCLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDdkQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNaLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO29CQUMvQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBRTFCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztvQkFDMUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDN0IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRXBDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUVoRCxJQUFJLFdBQVcsRUFBRTs0QkFDYixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDM0MsS0FBSyxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDOzRCQUNwQyxLQUFLLENBQUMsUUFBUSxDQUFDLGdCQUFnQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzs0QkFDNUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs0QkFDbEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ2xDOzZCQUFNOzRCQUNILE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ3BDLEtBQUssQ0FBQyxJQUFJLENBQUM7Z0NBQ1AsQ0FBQztnQ0FDRCxDQUFDLEVBQUUsRUFBRTs2QkFDUixDQUFDLENBQUM7eUJBQ047cUJBQ0o7aUJBQ0o7WUFDTCxDQUFDLENBQUMsQ0FBQztTQUNOO2FBQU07WUFDSCxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFO2dCQUM5QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQztvQkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO29CQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7b0JBQ2pCLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ1osQ0FBQyxDQUFDO2dCQUVILHFCQUFxQjtnQkFDckIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztnQkFDeEMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQztvQkFDdkIsTUFBTSxFQUFFLENBQUM7b0JBQ1QsS0FBSyxFQUFFLENBQUM7aUJBQ1gsQ0FBQyxDQUFDO2dCQUVILHVCQUF1QjtnQkFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDL0IsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNqQixDQUFDLENBQUMsQ0FBQztnQkFDSCxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztZQUM1QixDQUFDLENBQUMsQ0FBQztTQUNOO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ08sYUFBYSxDQUFDLElBQW9CO1FBQ3hDLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtZQUNmLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxJQUFJLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQyxRQUFRLEdBQUc7b0JBQ1o7d0JBQ0ksSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLE9BQU8sdUJBQXVCO3dCQUM3QyxLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVc7eUNBQ3ZCLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHO3FCQUMvQztvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLDhCQUE4Qjt3QkFDaEUsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjOzhDQUNyQjtxQkFDekI7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLHlCQUF5QixJQUFJLENBQUMsT0FBTyx1QkFBdUI7d0JBQ2xFLEtBQUssRUFBRSxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYzt5Q0FDMUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUc7cUJBQy9DO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8seUJBQXlCO3dCQUMzRCxLQUFLLEVBQUUsUUFBUSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRztxQkFDN0M7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLGdCQUFnQixJQUFJLENBQUMsT0FBTyxlQUFlO3dCQUNqRCxLQUFLLEVBQUUsVUFBVSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVM7d0NBQ3ZCLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFO3FCQUMzQztvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLHFCQUFxQjt3QkFDdkQsS0FBSyxFQUFFLGNBQWM7cUJBQ3hCO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8scUJBQXFCO3dCQUN2RCxLQUFLLEVBQUUsbUJBQW1CO3FCQUM3QjtvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLDJCQUEyQjt3QkFDN0QsS0FBSyxFQUFFLDZCQUE2QjtxQkFDdkM7aUJBQ0osQ0FBQztnQkFFRixJQUFJLENBQUMsYUFBYSxHQUFHO29CQUNqQjt3QkFDSSxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyx1QkFBdUI7d0JBQzdDLEtBQUssRUFBRSxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWTt5Q0FDeEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXO21EQUNkO3FCQUM5QjtvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLDhCQUE4Qjt3QkFDaEUsS0FBSyxFQUFFLFNBQVMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjOzhDQUNyQjtxQkFDekI7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLHlCQUF5QixJQUFJLENBQUMsT0FBTyx1QkFBdUI7d0JBQ2xFLEtBQUssRUFBRSxTQUFTLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWTt5Q0FDeEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUc7cUJBQy9DO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8seUJBQXlCO3dCQUMzRCxLQUFLLEVBQUUsUUFBUSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRztxQkFDOUM7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLGdCQUFnQixJQUFJLENBQUMsT0FBTyx1QkFBdUI7d0JBQ3pELEtBQUssRUFBRSxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHO3FCQUM3QztvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLHFCQUFxQjt3QkFDdkQsS0FBSyxFQUFFLGVBQWU7cUJBQ3pCO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sZUFBZTt3QkFDakQsS0FBSyxFQUFFLFVBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTO3dDQUN2QixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVM7bURBQ1g7cUJBQzlCO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8scUJBQXFCO3dCQUN2RCxLQUFLLEVBQUUsY0FBYztxQkFDeEI7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLGdCQUFnQixJQUFJLENBQUMsT0FBTyxxQkFBcUI7d0JBQ3ZELEtBQUssRUFBRTtpREFDa0I7cUJBQzVCO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sMkJBQTJCO3dCQUM3RCxLQUFLLEVBQUU7aURBQ2tCO3FCQUM1QjtpQkFDSixDQUFDO2FBQ0w7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7Z0JBQ25CLElBQUksQ0FBQyxhQUFhLEdBQUc7b0JBQ2pCO3dCQUNJLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLHVCQUF1Qjt3QkFDN0MsS0FBSyxFQUFFOzttREFFb0I7cUJBQzlCO29CQUNEO3dCQUNJLElBQUksRUFBRSx5QkFBeUIsSUFBSSxDQUFDLE9BQU8sdUJBQXVCO3dCQUNsRSxLQUFLLEVBQUU7bUVBQ29DO3FCQUM5QztvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLGVBQWU7d0JBQ2pELEtBQUssRUFBRSxvQkFBb0I7cUJBQzlCO29CQUNEO3dCQUNJLElBQUksRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8scUJBQXFCO3dCQUN2RCxLQUFLLEVBQUUsa0JBQWtCO3FCQUM1QjtvQkFDRDt3QkFDSSxJQUFJLEVBQUUsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLDJCQUEyQjt3QkFDN0QsS0FBSyxFQUFFLGtCQUFrQjtxQkFDNUI7aUJBQ0osQ0FBQzthQUNMO1lBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRTtnQkFDekQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDM0IsTUFBTSxJQUFJLEdBQUc7d0JBQ1QsSUFBSSxFQUFFLG1DQUFtQyxHQUFHLENBQUMsSUFBSSxFQUFFO3dCQUNuRCxLQUFLLEVBQUUsU0FBUyxHQUFHLENBQUMsV0FBVyxHQUFHO3FCQUNyQyxDQUFDO29CQUVGLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEMsQ0FBQyxDQUFDLENBQUM7YUFDTjtTQUNKO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ08sZ0JBQWdCO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxPQUFPLENBQUMsS0FBaUIsRUFBRSxJQUFvQjtRQUNuRCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUVoQyxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUVwRCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDcEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRTdDLHFCQUFxQjtRQUNyQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUV4RCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRTdDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUV0QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2xELENBQUM7Q0FDSjtBQXpWRCxrQ0F5VkM7Ozs7Ozs7Ozs7Ozs7OztBQzVWRCx5SkFBOEQ7QUFFOUQ7eUNBQ3lDO0FBRXpDLE1BQXNCLE1BQU8sU0FBUSxpQ0FBZTtJQW9DaEQ7Ozs7Ozs7OztPQVNHO0lBQ0gsWUFBWSxLQUFpQixFQUFFLFlBQWtCLElBQUksRUFBRSxVQUFzQixFQUFFLFNBQTJCLEVBQzlGLEVBQVUsRUFBRSxjQUE4QixFQUFFLGlCQUFzQztRQUMxRixLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7UUF0Qm5EOztXQUVHO1FBQ08sZUFBVSxHQUFrQixJQUFJLENBQUM7UUFxQnZDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUM7UUFFM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFVLElBQUksQ0FBQyxRQUFRLFFBQVEsQ0FBQztRQUMvQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQzFDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztRQUUzQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxZQUFZO1FBQ2YsUUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFFBQVEsQ0FBQyxTQUEwQixFQUFFLFVBQXNCLEVBQUUsS0FBc0IsRUFDMUUsaUJBQTBCLEtBQUs7UUFDM0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2QsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxVQUFVLENBQUMsSUFBb0IsRUFBRSxPQUE0QjtRQUNoRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsT0FBTyxDQUFDO0lBQ3JDLENBQUM7SUFjTSxJQUFJLENBQUMsSUFBUyxFQUFFLElBQVU7UUFDN0IsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLEtBQWEsRUFBRSxNQUFjO1FBQ3ZDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNO1FBQ1QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUN4QixPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNO1FBQ1QsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUN4QixPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRO1FBQ1gsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDeEIsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOztPQUVHO0lBQ08sRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25GLENBQUM7SUFFRDs7T0FFRztJQUNLLGdCQUFnQjtRQUNwQixNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLEtBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2QyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqQyxPQUFPLEtBQUssQ0FBQyxLQUFzQixDQUFDO0lBQ3hDLENBQUM7Q0FDSjtBQXRLRCx3QkFzS0M7Ozs7Ozs7Ozs7Ozs7OztBQzdLRCx5SkFBOEQ7QUFHOUQ7O0dBRUc7QUFDSCxNQUFhLFdBQVksU0FBUSxpQ0FBZTtJQXdFNUM7Ozs7OztPQU1HO0lBQ0gsWUFBWSxLQUFpQixFQUFFLFlBQWtCLElBQUksRUFBRSxVQUFzQixFQUFFLFNBQTJCO1FBQ3RHLEtBQUssQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztRQWhEbkQ7O1dBRUc7UUFDSyxpQkFBWSxHQUFXLEVBQUUsQ0FBQztRQVlsQzs7V0FFRztRQUNLLE9BQUUsR0FBVyxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUU1Qzs7V0FFRztRQUNLLE9BQUUsR0FBVyxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUU1Qzs7V0FFRztRQUNLLE9BQUUsR0FBVyxFQUFFLENBQUM7UUFFeEI7O1dBRUc7UUFDSyxPQUFFLEdBQVcsQ0FBQyxDQUFDO1FBZ0JuQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksU0FBUyxDQUFDLE1BQWMsRUFBRSxJQUFZLEVBQUUsS0FBNEQ7UUFDdkcsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNoQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkYsUUFBUSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUVsQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3RSxRQUFRLENBQUMsU0FBUyxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFFbEQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM5QixRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUV0QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkYsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU5QixJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVuQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDYixLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxRQUFRLENBQUMsTUFBYztRQUMxQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFFN0IsTUFBTSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtZQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztnQkFDaEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFO2dCQUNWLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRTthQUNiLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQWdCTSxJQUFJLENBQUMsSUFBUyxFQUFFLElBQVU7UUFDN0IsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFdkIsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFFN0IsTUFBTSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtZQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztnQkFDaEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFO2dCQUNWLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRTthQUNiLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLEtBQWEsRUFBRSxNQUFjO1FBQ3ZDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTVCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBRTdCLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUU7WUFDOUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7Z0JBQ2hCLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRTtnQkFDVixDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUU7YUFDYixDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU07UUFDVCxhQUFhO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNJLElBQUk7UUFDUCxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFO1lBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO2dCQUNoQixVQUFVLEVBQUUsUUFBUTthQUN2QixDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUVQLENBQUM7SUFFRDs7T0FFRztJQUNJLElBQUk7UUFDUCxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FBRyxFQUFFO1lBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO2dCQUNoQixVQUFVLEVBQUUsU0FBUzthQUN4QixDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSSxZQUFZLENBQUMsTUFBYztRQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxPQUFPO1FBQ1gsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFDcEMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBdUIsQ0FBQztRQUV2RixhQUFhO1FBQ2IsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXJDLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBRTdCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXhDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN6QyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxFQUFnQixDQUFDO1FBRTNDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFeEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUMzQixJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQkFBcUI7UUFDekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF5Qkk7UUFFSix3QkFBd0I7UUFDeEIsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRTtZQUNwRCxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztTQUN2RDthQUFNO1lBQ0gsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDOUI7UUFDRCxrQ0FBa0M7UUFDbEMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUU7WUFDOUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDckQ7YUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxpQ0FBaUM7WUFDOUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztTQUN4QzthQUFNLEVBQUUseUNBQXlDO1lBQzlDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7U0FDL0Q7SUFFTCxDQUFDOztBQXhTRDs7R0FFRztBQUNXLDBCQUFjLEdBQUc7SUFDM0IsTUFBTSxFQUFFO1FBQ0osUUFBUSxFQUFFLEVBQUU7UUFDWixJQUFJLEVBQUUsa0ZBQWtGO1lBQ2xGLDJEQUEyRDtLQUNwRTtDQUNKLENBQUM7QUFWTixrQ0EwU0M7Ozs7Ozs7Ozs7Ozs7OztBQ3RURCxpSEFBMEM7QUFDMUMsd0dBQW9DO0FBQ3BDLHNKQUFnRTtBQUloRSxnSUFBK0M7QUFDL0MscUlBQWtEO0FBQ2xELCtJQUF3RDtBQUN4RCxvSkFBMkQ7QUFDM0Qsc0hBQTJDO0FBQzNDLDBIQUFnRTtBQUdoRTs7R0FFRztBQUNILE1BQWEsY0FBYztJQXNFdkI7Ozs7T0FJRztJQUNILFlBQVksT0FBc0IsRUFBRSxTQUFtQztRQWxDdkU7O1dBRUc7UUFDSyxrQkFBYSxHQUFZLEtBQUssQ0FBQztRQUV2Qzs7V0FFRztRQUNLLG9CQUFlLEdBQUcsS0FBSyxDQUFDO1FBY2hDOztXQUVHO1FBQ0ssc0JBQWlCLEdBQXVCO1lBQzVDLG9CQUFvQixFQUFFLElBQUk7U0FDN0IsQ0FBQztRQVFFLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDO1FBQzFCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxXQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXJGLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztRQUVuQyxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7WUFFM0IsSUFBSSxPQUFPLFNBQVMsQ0FBQyxRQUFRLEtBQUssVUFBVSxFQUFFO2dCQUMxQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxDQUFDLE1BQWMsRUFBRSxVQUFzQixFQUFFLEtBQXNCLEVBQzlELGlCQUEwQixLQUFLLEVBQUUsRUFBRTtvQkFDMUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztvQkFDL0QsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztnQkFDbEUsQ0FBQyxDQUFDO2FBQ0w7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDNUQ7U0FDSjthQUFNO1lBQ0gsSUFBSSxDQUFDLFNBQVMsR0FBRztnQkFDYixRQUFRLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2dCQUN4QyxtQkFBbUIsRUFBRSxJQUFJO2dCQUN6QixpQkFBaUIsRUFBRSxJQUFJO2FBQzFCLENBQUM7U0FDTDtRQUVELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFyREQ7O09BRUc7SUFDSCxJQUFXLFFBQVE7UUFDZixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDOUIsQ0FBQztJQWtERDs7Ozs7T0FLRztJQUNJLFNBQVMsQ0FBQyxFQUFVLEVBQUUsVUFBc0IsRUFBRSxjQUE4QjtRQUMvRSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssMkJBQWMsQ0FBQyxLQUFLLEVBQUU7WUFDMUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQ3ZEO2FBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLDJCQUFjLENBQUMsUUFBUSxFQUFFO1lBQ3BELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQzFEO2FBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLDJCQUFjLENBQUMsSUFBSSxFQUFFO1lBQ2hELElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUN0RDthQUFNLElBQUksVUFBVSxDQUFDLElBQUksS0FBSywyQkFBYyxDQUFDLE9BQU8sRUFBRTtZQUNuRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUN6RDtRQUNELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLGFBQWEsQ0FBQyxFQUFVLEVBQUUsVUFBc0IsRUFBRSxjQUE4QjtRQUNuRixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWpCLE1BQU0sTUFBTSxHQUFHLElBQUksdUJBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFDMUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFFdEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxjQUFjLENBQUMsRUFBVSxFQUFFLFVBQXNCLEVBQUUsY0FBOEI7UUFDcEYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVqQixNQUFNLE1BQU0sR0FBRyxJQUFJLHlCQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQzFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRXZELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksaUJBQWlCLENBQUMsRUFBVSxFQUFFLFVBQXNCLEVBQUUsY0FBOEI7UUFDdkYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVqQixNQUFNLE1BQU0sR0FBRyxJQUFJLCtCQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQzFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRTFELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksZ0JBQWdCLENBQUMsRUFBVSxFQUFFLFVBQXNCLEVBQUUsY0FBOEI7UUFDdEYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVqQixNQUFNLE1BQU0sR0FBRyxJQUFJLDZCQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQzFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRXpELElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBbUJRO0lBRUo7O09BRUc7SUFDSSxnQkFBZ0I7UUFDbkIsZ0RBQWdEO1FBQ2hELE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQy9CLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQzVCLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ2xDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEMsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSSx3QkFBd0I7UUFDM0IsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDeEQsT0FBTztnQkFDSCxFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7Z0JBQ2IsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUNYLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztnQkFDWCxLQUFLLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLO2dCQUM3QixNQUFNLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNO2FBQ2xDLENBQUM7UUFDTixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNJLGtCQUFrQjtRQUNyQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUN4RCxPQUFPO2dCQUNILEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRTtnQkFDYixVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVU7YUFDaEMsQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGdCQUFnQixDQUFDLEVBQVU7UUFDOUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXpDLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtZQUNoQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzdCO1FBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixLQUFLLElBQUksRUFBRTtZQUMzQyxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixFQUFFLENBQUM7U0FDdEM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxnQkFBZ0I7UUFDbkIsS0FBSyxNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQy9CLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN0QixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3hCO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLGNBQWMsQ0FBQyxFQUFVLEVBQUUsY0FBOEI7UUFDNUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXpDLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtZQUNoQixNQUFNLENBQUMsVUFBVSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUM3RDtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSSw0QkFBNEIsQ0FBQyxjQUE4QjtRQUM5RCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUU3QyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDdkIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksZ0JBQWdCLENBQUMsRUFBVTtRQUM5QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxLQUFhLEVBQUUsTUFBYztRQUN2QyxNQUFNLEVBQUUsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7UUFDeEMsTUFBTSxFQUFFLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBRTFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVyQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWpCLDZDQUE2QztRQUM3QyxLQUFLLE1BQU0sTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDL0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLGlCQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1NBQzVFO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxNQUFlO1FBQ3pCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7U0FDOUI7YUFBTTtZQUNILElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO1NBQzFCO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQzVCLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNwQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDWCxJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlDLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxFQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDMUQ7UUFFRCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUVyRCxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUM1QixNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxnQkFBZ0I7UUFDbkIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ25CO2FBQU07WUFDSCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDakI7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxnQkFBZ0I7UUFDbkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixHQUFHLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDO1FBRTNGLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDdkIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGdCQUFnQixDQUFDLEVBQVU7UUFDL0IsSUFBSSxNQUFNLEdBQVcsSUFBSSxDQUFDO1FBQzFCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNWLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7WUFDOUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQzNCLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzVCO1lBQ0QsQ0FBQyxFQUFFLENBQUM7U0FDUDtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNLLGlCQUFpQjtRQUNyQixTQUFTLFNBQVMsQ0FBQyxHQUFhLEVBQUUsSUFBWSxFQUFFLEtBQWE7WUFDekQsSUFBSSxLQUFhLENBQUM7WUFDbEIsSUFBSSxjQUFzQixDQUFDO1lBRTNCLElBQUksSUFBSSxHQUFHLEtBQUssRUFBRTtnQkFDZCxLQUFLLEdBQUcsS0FBSyxDQUFDO2dCQUNkLGNBQWMsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBRXBELHNCQUFzQjtnQkFDdEIsU0FBUyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUN6QyxTQUFTLENBQUMsR0FBRyxFQUFFLGNBQWMsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDN0M7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNmLENBQUM7UUFFRCxTQUFTLFNBQVMsQ0FBQyxHQUFhLEVBQUUsS0FBYSxFQUFFLElBQVksRUFBRSxLQUFhO1lBQ3hFLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDbkMsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDO1lBRTFCLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQy9CLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxVQUFVLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO29CQUM3QixjQUFjLEVBQUUsQ0FBQztpQkFDcEI7YUFDSjtZQUNELElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQ2pDLE9BQU8sY0FBYyxDQUFDO1FBQzFCLENBQUM7UUFFRCxTQUFTLElBQUksQ0FBQyxHQUFhLEVBQUUsQ0FBUyxFQUFFLENBQVM7WUFDN0MsTUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEIsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDbkMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ1osU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3ZEO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0sscUJBQXFCO1FBQ3pCLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBVSxDQUFDO1FBRW5DLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUMvQixJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUU7Z0JBQ25CLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDM0I7U0FDSjtRQUVELE9BQU8sVUFBVSxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSyxZQUFZLENBQUMsTUFBYztRQUMvQixlQUFlO1FBQ2YsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRXRCLGlCQUFpQjtRQUNqQixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNyQyxPQUFPLENBQUMsS0FBSyxNQUFNLENBQUM7UUFDeEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWpCLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLEtBQUssVUFBVSxFQUFFO1lBQ3ZELElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQy9EO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0sscUJBQXFCO1FBQ3pCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ2hELEtBQUssTUFBTSxNQUFNLElBQUksVUFBVSxFQUFFO1lBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDN0I7UUFFRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEtBQUssSUFBSSxFQUFFO1lBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUN0QztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSyxZQUFZLENBQUMsTUFBYztRQUMvQixJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7WUFDakIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM3QixNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7WUFFaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLFVBQVUsRUFBRTtnQkFDekQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDOUM7U0FDSjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNLLGdCQUFnQjtRQUNwQixJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDYixLQUFLLE1BQU0sTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDL0IsQ0FBQyxHQUFHLE1BQU0sQ0FBQztZQUNYLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUVYLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxVQUFVLEVBQUU7Z0JBQ3pELElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3pDO1NBQ0o7UUFDRCxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7WUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM3QjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNLLGdCQUFnQjtRQUNwQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFFbkMsSUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2QsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDNUI7YUFBTSxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDbkIsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7Z0JBQ2pDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUU7b0JBQzVCLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2lCQUN2RTtnQkFDRCxDQUFDLEVBQUUsQ0FBQzthQUNQO1NBQ0o7UUFFRCxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRTtZQUM5QixNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM1QjtRQUVELElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ssYUFBYSxDQUFDLE1BQWMsRUFBRSxFQUFVLEVBQUUsRUFBVSxFQUFFLEVBQVUsRUFBRSxFQUFVLEVBQUUsVUFBbUIsS0FBSztRQUMxRyxJQUFJLENBQVMsQ0FBQztRQUNkLElBQUksQ0FBUyxDQUFDO1FBQ2QsSUFBSSxDQUFTLENBQUM7UUFDZCxJQUFJLENBQVMsQ0FBQztRQUNkLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDVixDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMzQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3RDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDekM7YUFBTTtZQUNILENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDdkQsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUV4RCxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3RDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDekM7UUFFRCxNQUFNLEVBQUUsR0FBRyxJQUFJLGlCQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDekQsTUFBTSxFQUFFLEdBQUcsSUFBSSxpQkFBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFakUsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNoQixNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLG1CQUFtQixDQUFDLEVBQVUsRUFBRSxFQUFVO1FBQzlDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNsQixJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLHFCQUFxQixDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsVUFBbUIsS0FBSztRQUMxRSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUM3QyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDbEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLGNBQWMsQ0FBQyxNQUFjLEVBQUUsVUFBc0IsRUFBRSxLQUFzQixFQUM5RCxpQkFBMEIsS0FBSztRQUNsRCx1QkFBdUI7UUFDdkIsSUFBSSxLQUFLLEtBQUssa0NBQWUsQ0FBQyxTQUFTLEVBQUU7WUFDckMsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDakIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNoQztZQUNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDakIsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLFVBQVUsRUFBRTtnQkFDekQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxDQUFDO2FBQzlEO1lBQ0QsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLFVBQVUsRUFBRTtnQkFDMUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQzNEO1lBQ0QsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7WUFDN0IsdUJBQXVCO1NBQzFCO2FBQU0sSUFBSSxLQUFLLEtBQUssa0NBQWUsQ0FBQyxNQUFNLEVBQUU7WUFDekMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxVQUFVLEVBQUU7Z0JBQ3JELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDdEQ7WUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztZQUM1QixxQkFBcUI7U0FDeEI7YUFBTSxJQUFJLEtBQUssS0FBSyxrQ0FBZSxDQUFDLE9BQU8sRUFBRTtZQUMxQyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0JBQ3RCLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQy9CLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2dCQUN6QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztnQkFFeEIsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsS0FBSyxVQUFVLEVBQUU7b0JBQ3hELElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7aUJBQ3pEO2FBQ0o7U0FDSjthQUFNLElBQUksS0FBSyxLQUFLLGtDQUFlLENBQUMsZUFBZSxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUMzRSxTQUFTO1lBQ1QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxjQUFjLEVBQUU7b0JBQ2pCLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ2hDO2dCQUNELE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQy9CLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxVQUFVLEVBQUU7b0JBQ3pELElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQztpQkFDOUQ7Z0JBQ0QsV0FBVzthQUNkO2lCQUFNO2dCQUNILE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDakIsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLFVBQVUsRUFBRTtvQkFDekQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsY0FBYyxDQUFDLENBQUM7aUJBQ3ZEO2FBQ0o7U0FDSjtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSyxlQUFlLENBQUMsTUFBZTtRQUNuQyxLQUFLLE1BQU0sTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDL0IsSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFFO2dCQUNuQixNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7YUFDckI7U0FDSjtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSyxPQUFPLENBQUMsS0FBaUI7UUFDN0IsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNwQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRWxELElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSx3QkFBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksdUJBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFL0YsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLE1BQWMsRUFBRSxFQUFFO1lBQ3RELElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxpQkFBaUI7UUFDckIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQWEsRUFBRSxFQUFFO1lBQ2hELElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsS0FBSyxJQUFJLEVBQUU7Z0JBQzdDLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEVBQUUsQ0FBQzthQUN4QztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQWEsRUFBRSxFQUFFO1lBQy9DLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsS0FBSyxJQUFJLEVBQUU7Z0JBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEVBQUUsQ0FBQzthQUN0QztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ25DLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLFlBQVksZ0JBQWdCLENBQUM7Z0JBQ3ZDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxZQUFZLG1CQUFtQixDQUFDO2dCQUMxQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sWUFBWSxpQkFBaUIsQ0FBQyxFQUFFO2dCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDaEIsUUFBUSxDQUFDLENBQUMsT0FBTyxFQUFFO3dCQUNmLE1BQU07d0JBQ04sS0FBSyxDQUFDOzRCQUNGLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDOzRCQUN4QixNQUFNO3dCQUVWLG9CQUFvQjt3QkFDcEIsS0FBSyxFQUFFLENBQUM7d0JBQ1IsS0FBSyxDQUFDOzRCQUNGLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDOzRCQUM3QixNQUFNO3dCQUNWLFlBQVk7d0JBQ1osS0FBSyxFQUFFOzRCQUNILElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTtnQ0FDWCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUU7b0NBQzFCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQ0FDbkM7cUNBQU0sSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRTtvQ0FDaEMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lDQUNyQztxQ0FBTSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFO29DQUNoQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2lDQUMzQzs2QkFDSjs0QkFDRCxNQUFNO3dCQUNWLGNBQWM7d0JBQ2QsS0FBSyxFQUFFOzRCQUNILElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTtnQ0FDWCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUU7b0NBQzFCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUNBQ2xDO3FDQUFNLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUU7b0NBQ2hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUNBQ3BDO3FDQUFNLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0NBQ2hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2lDQUMxQzs2QkFDSjs0QkFDRCxNQUFNO3dCQUNWLGNBQWM7d0JBQ2QsS0FBSyxFQUFFOzRCQUNILElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTtnQ0FDWCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUU7b0NBQzFCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztpQ0FDbkM7cUNBQU0sSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRTtvQ0FDaEMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2lDQUNyQztxQ0FBTSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFO29DQUNoQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2lDQUMzQzs2QkFDSjs0QkFDRCxNQUFNO3dCQUNWLGVBQWU7d0JBQ2YsS0FBSyxFQUFFOzRCQUNILElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTtnQ0FDWCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUU7b0NBQzFCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUNBQ2xDO3FDQUFNLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUU7b0NBQ2hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUNBQ3BDO3FDQUFNLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0NBQ2hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2lDQUMxQzs2QkFDSjs0QkFDRCxNQUFNO3dCQUNWLFVBQVU7d0JBQ1YsT0FBTyxDQUFDLENBQUMsT0FBTztxQkFDbkI7b0JBQ0QsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO2lCQUN0QjthQUNKO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDckMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sWUFBWSxnQkFBZ0IsQ0FBQztnQkFDdkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLFlBQVksbUJBQW1CLENBQUM7Z0JBQzFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxZQUFZLGlCQUFpQixDQUFDLEVBQUU7Z0JBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNoQixRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUU7d0JBQ1oscUJBQXFCO3dCQUNyQixLQUFLLE1BQU0sQ0FBQzt3QkFDWixLQUFLLFNBQVM7NEJBQ1YsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFO2dDQUNYLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDOzZCQUMzQjs0QkFDRCxNQUFNO3FCQUNiO29CQUNELHNCQUFzQjtpQkFDekI7YUFDSjtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGNBQWMsQ0FBQyxNQUFjO1FBQ2pDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFaEIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkMsQ0FBQztDQUNKO0FBNTBCRCx3Q0E0MEJDOzs7Ozs7Ozs7Ozs7Ozs7QUM3MUJELHdHQUFvQztBQUdwQyx5SkFBa0Y7QUFFbEYsc0pBQTBEO0FBQzFELCtKQUFnRTtBQUNoRSw0SkFBOEQ7QUFDOUQsK0pBQWdFO0FBQ2hFLG1KQUF3RDtBQUd4RDs7Ozs7R0FLRztBQUNILE1BQWEsWUFBWTtJQXdFckI7Ozs7T0FJRztJQUNILFlBQVksT0FBc0IsRUFBRSxTQUE4QjtRQVZsRTs7V0FFRztRQUNLLGNBQVMsR0FBWSxJQUFJLENBQUM7UUFROUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUM7UUFDMUIsSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1NBQzlCO2FBQU07WUFDSCxJQUFJLENBQUMsU0FBUyxHQUFHO2dCQUNiLFFBQVEsRUFBRSxJQUFJO2dCQUNkLGdCQUFnQixFQUFFLElBQUk7Z0JBQ3RCLGNBQWMsRUFBRSxJQUFJO2dCQUNwQixVQUFVLEVBQUUsSUFBSTthQUNuQixDQUFDO1NBQ0w7UUFFRCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsS0FBYSxFQUFFLE1BQWM7UUFDdkMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDN0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3hDO2FBQU07WUFDSCxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNwRztRQUVELElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3ZDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTTtRQUNULElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3JFO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ksT0FBTztRQUNWLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMzQjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNJLElBQUk7UUFDUCxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDZCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxJQUFJO1FBQ1AsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQWFNLGdCQUFnQixDQUFDLFFBQTJDO1FBQy9ELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVmLElBQUksUUFBUSxLQUFLLElBQUksSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQzdDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRztnQkFDcEIsSUFBSSxFQUFFLGlDQUFhLENBQUMsSUFBSTthQUMzQixDQUFDO1NBQ0w7YUFBTSxJQUFLLFFBQThCLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUMzRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsUUFBNkIsQ0FBQztTQUN6RDthQUFNO1lBQ0gsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsSUFBSSxFQUFFLFFBQXlCLEVBQUUsQ0FBQztTQUMvRDtRQUVELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7UUFFakQsSUFBSSxhQUFhLEtBQUssaUNBQWEsQ0FBQyxJQUFJLEVBQUU7WUFDdEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDckIsT0FBTztTQUNWO2FBQU0sSUFBSSxhQUFhLEtBQUssaUNBQWEsQ0FBQyxRQUFRLEVBQUU7WUFDakQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7WUFDdEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQztZQUNoRCxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDL0M7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsQ0FBQzthQUN2RTtTQUNKO2FBQU0sSUFBSSxhQUFhLEtBQUssaUNBQWEsQ0FBQyxJQUFJLEVBQUU7WUFDN0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1NBQ3JDO2FBQU0sSUFBSSxhQUFhLEtBQUssaUNBQWEsQ0FBQyxLQUFLLEVBQUU7WUFDOUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1NBQ3RDO2FBQU0sSUFBSSxhQUFhLEtBQUssaUNBQWEsQ0FBQyxRQUFRLEVBQUU7WUFDakQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7U0FDekM7YUFBTSxJQUFJLGFBQWEsS0FBSyxpQ0FBYSxDQUFDLE9BQU8sRUFBRTtZQUNoRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7U0FDeEM7UUFFRCw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNmO2FBQU07WUFDSCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDZjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNJLG1CQUFtQjtRQUN0QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksV0FBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXJHLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFaEQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLDJCQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2xHLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLG1DQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUMzQyxJQUFJLFdBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzdFLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSw2QkFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNwRyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxtQ0FBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDMUcsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXhHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUVsQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRS9CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFckIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUQsQ0FBQzs7QUEvT0Q7OztHQUdHO0FBQ1csZ0NBQW1CLEdBQVMsSUFBSSxXQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBTC9ELG9DQWlQQzs7Ozs7Ozs7Ozs7Ozs7O0FDblFELG9IQUE2QztBQUk3QywwSEFBb0M7QUFHcEM7O0dBRUc7QUFDSCxNQUFhLFlBQWEsU0FBUSxpQkFBTztJQWdCckM7O09BRUc7SUFDSCxJQUFXLENBQUM7UUFDUixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsQ0FBQztRQUNSLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxZQUFZLEtBQWlCLEVBQUUsU0FBZTtRQUMxQyxLQUFLLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFdBQVcsQ0FBQyxJQUFVO1FBQ3pCLE9BQU8sSUFBSSxpQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksSUFBSSxDQUFDLENBQVcsRUFBRSxTQUFlLEVBQUUsU0FBa0IsS0FBSyxFQUFFLE1BQWdCLElBQUk7UUFDbkYsTUFBTSxFQUFFLEdBQVksSUFBSSxpQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUUxRCxJQUFJLE1BQU0sRUFBRTtZQUNSLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFbkMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0IsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDdEIsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVyQixJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUU3RCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM1RCxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxLQUFhLEVBQUUsTUFBYztRQUN2QyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFB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LEVBQUosV0FBSTtJQUNKLE9BQU8sRUFBUCxpQkFBTztJQUNQLFVBQVUsRUFBVix1QkFBVTtJQUNWLGNBQWMsRUFBZCwrQkFBYztJQUNkLEdBQUcsRUFBSCxTQUFHO0lBQ0gsTUFBTSxFQUFFO1FBQ0osUUFBUSxFQUFSLG1CQUFRO1FBQ1IsUUFBUSxFQUFSLG1CQUFRO1FBQ1IsUUFBUSxFQUFSLG1CQUFRO1FBQ1IsUUFBUSxFQUFSLG1CQUFRO1FBQ1IsT0FBTyxFQUFQLGlCQUFPO1FBQ1AsS0FBSyxFQUFMLGFBQUs7S0FDUjtDQUNKLENBQUM7QUFFRjs7R0FFRztBQUNXLHFCQUFTLEdBQUc7SUFDdEIsWUFBWSxFQUFaLDJCQUFZO0lBQ1osYUFBYSxFQUFiLGlDQUFhO0NBQ2hCLENBQUM7QUFFRjs7R0FFRztBQUNXLGtCQUFNLEdBQUc7SUFDbkIsY0FBYyxFQUFkLCtCQUFjO0lBQ2QsV0FBVyxFQUFYLHlCQUFXO0lBQ1gsVUFBVSxFQUFWLHVCQUFVO0NBQ2IsQ0FBQztBQUVGOztHQUVHO0FBQ1csbUJBQU8sR0FBRztJQUNwQixZQUFZLEVBQVosaUNBQVk7SUFDWixlQUFlLEVBQWYsb0NBQWU7SUFDZixjQUFjLEVBQWQsbUNBQWM7SUFDZCxjQUFjLEVBQWQsbUNBQWM7SUFDZCxnQkFBZ0IsRUFBaEIscUNBQWdCO0lBQ2hCLGdCQUFnQixFQUFoQixxQ0FBZ0I7Q0FDbkIsQ0FBQztBQUVGOztHQUVHO0FBQ1csa0JBQU0sR0FBRywyQkFBUSxDQUFDO0FBRWhDOztHQUVHO0FBQ1csbUJBQU8sR0FBRyxpQkFBUyxDQUFDO0FBekR0QyxrQ0EwREM7QUFFRCxTQUFTO0FBQ1QsNkZBQWtDIiwiZmlsZSI6ImN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvY2FudmFzdG9vbHMvdHMvY3QudHNcIik7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIENhbnZhc1Rvb2xzLmNzcyAqL1xcclxcblxcclxcbi8qIDEuIEVkaXRvciAqL1xcclxcbi8qIDEuMS4gQ3Vyc29ycyAqL1xcclxcbi5DYW52YXNUb29sc0VkaXRvciB7XFxyXFxuICAgIC0tY3Vyc29yLXBvaW50ZXI6IC13ZWJraXQtaW1hZ2Utc2V0KHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEQUFBQUF3Q0FZQUFBQlhBdm1IQUFBQlVrbEVRVlJvUSszWU1XNkVNQkFGME5rVG1OT2tUa1Z0Q2pkVWNJRmNBWTRDTlExSFNOcWtTeDhKcEJ3QVRwRElsbGhwdGV6Q2VrZzhYeklWRXJJMWJ6NjJKWitNTWE5ZDF6MFQ2SE1pb2g5anpCc3F3Z0ZzODFFUkRxQ1Vvbm1lSVJFT1VGVVZEY05BYmR2Q0ljNkF1cTZwS0FvNHhBWEFyZ1UweEJVQURiRUtRRUxjQktBZzdnSVFFSnNBNlloZEFNbUkzUUNwaUljQUVoRVBBNlFodkFDU0VONEFLUWdXUUFLQ0RRaU5PQVFRRW5FWUlCVGlVRUFJeE9HQS8wYnNBcFJsU1UzVGVOMGMvZlZ0eHlaZ0tUNU4weStsMUxlUElzdXlsenpQUDMzR2JvMjVDMWlLMTFwLzlIMy90RFZaaU84M0FRakYyNGF0QWxDS1h3VWdGWDhGUUN2K0FqQ09vOXNxSlMvWXRVM0NyWUVrU1dpYUpyaml6d25ZRjdUT0wybTRCRkNMZHdsb3JkK2xIbEo3RGthYkFQUVRBYUhqaXduRUJKZ2RpTDhRczRIczRURUJkZ3VaRThRRW1BMWtELzhGVU9waVFPOXpjblFBQUFBQVNVVk9SSzVDWUlJPScpIDJ4KSwgcG9pbnRlcjtcXHJcXG4gICAgLS1jdXJzb3ItbW92ZTogLXdlYmtpdC1pbWFnZS1zZXQodXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQURBQUFBQXdDQVlBQUFCWEF2bUhBQUFDZ0VsRVFWUm9RKzJaUzI3Q01CQ0d5UUZ5Z25aSmIxRXA2U1kzeUpwSGV3ZVdRTlZqVkFIV3ZrRTJoWHRRVmx3QWNRQ3FpUWh5Z3NjZVA4YnFBa3VvcXBxTS84OGV6L3d1eVNEd21FNm4zOGZqTWF2citpVndhR1c0Sk9Ra0lMNnFxbmVJV1JURlBnWkVNSUJXL0dnMGF0WmtzOWxFZ1FnQ0lJdGZyOWNOd0hnOGpnTGhEYUFTMzZabERBZ3ZBSjM0V0JET0FCVHhNU0NjQUd6RWMwTllBN2lJNTRTd0FwRHJ2S3Avek9mendXS3hhUDRFUDVmTEpkcG1RdlVKTXNCc05uczlIQTVmbUNJaFJLWUNLTXR5aDcyVHB1bStxcW9QbjJaS0FvQ1ZQNS9QUXlGRXJwbnNndXdBT2tkWmx0dlQ2ZlRrMDdHTkFHM2F3RXB5QU1ETythU1RGa0RPZVU0QUgrK0VBc2pWQm53Tkp3RDRKMWZ2cEFUb2w4b2tTVmdCTHBlTHMzZTZBMURWK1JnQXJnYXdBNEExcVZnQUxoQTNBRjJIQlFES3NHbGtjanhJSVhuWXVOaEdtY2tldE4zVkJKSG4rUUErTUxiYmJmT2hERlY4S2tSaUVrOFJ3UFVNQmVJR0FBK3ZWaXN1TFU1eEo1UEpBRzU0UlZIODFuVTlWQVhwcEJBR29UTmxjdEFzeXpvcHROdWhOcWlqQmM1T2YxREV3enQzaDFnRkVmc1FVOFYzQU9URDNJZUlXVVp0eE44QllCQ3hBR3pGS3dGVUVERUFYTVNqQUgwSXFBU2NaZzVTMWxSdHNETDJuK3cwV2lwMU5kam9FU0pkYUp6RWExTklwbWErVWo1alRZclMvWXc3MEFhNVh1by9zYUJDaURma1V2K0R2Wk9tNlNIS3BiNFZFUGpmS3M1cEl5OEllUWY2RUM3ZXliVlVlaDFpMWN2dFR0aEFjSWduSDJKZkNDN3hYZ0E2N3lRRGM0cjNCakJCY0lzUEFvQkJ4QkFmREtBUEFiKzdlaHRLOC9JcW83b0plbCt6QnFuekppRHJQbUFLZVAyaU8vZXhCNlk1MkhiQVp1SlF6d2JmZ1ZEQ3FIRWVBTlNWNG5ydXNRTmNLMHVOK3dkZ1poUmVQUXUwMHdBQUFBQkpSVTVFcmtKZ2dnPT0nKSAyeCkgOCA4LCBtb3ZlO1xcclxcbiAgICAtLWN1cnNvci1yZXNpemU6IC13ZWJraXQtaW1hZ2Utc2V0KHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFEQUFBQUF3Q0FZQUFBQlhBdm1IQUFBREtFbEVRVlJvUSsyWks2d2FRUlNHQjhXMjVpSkJnV2lUclFLTktXbzFaRjFMd3VNMnRlQVJnTUNEYnhkSXFDU2dVU2dzb0xxaVRXaENBaExVQmJYTjJiQmtnTjE1TVd5NUtWam04WDl6SHZNUEJKRGtUN0ZZL0xaY0xqK09ScVAza3BkMlhTNGdjeE1RYnhqR002eXBhZG92UHlDa0FUamljN21jZlNiZGJ0Y1hDQ2tBdVBoT3AyTUQ1UE41WHlDdUJuQVQ3NlNsSHhCWEFaREUrd1VoRE1BaTNnOElJUUJIZkNnVVF1VnltYW1STlp0TnRObHNwQmMyTndEZUtwbVV1d3lTMldLNUFVUkYzMnJlQStCV0o4dTZMalVDaDV6L3dycWd5TGhEVGJ3VG1Vc0V3QXFXQ2lxeU9UYkhFaTFzVDJGbjNlYm1BS0lHMEZXWUkvN3A2UWx0dDF0WW13b0FjeWFUeVNmVE5OL0FCRlZWWDVMSlpNOHdqSzhNMGJHY3ZYZ2pjU0VNdjJGanNSaXExK3RFZ0VxbEV1MzMrejlCZUR3ZVI2bFV5dFk3SG8vUmZENjNRWFJkLzlCb05QNFFRS3hxdFlvV2l3VzNBVHdCT0xjSHRWcU5DZ0FDVjZ1VkFpNDBuVTZmYUJ3T2g3WXJqVVFpTDZacHZxVUJ3SDY4QnZBSTRPWnRhQURaYkhiUTYvWFNnOEhnUXJ3akZpQXltUXdxRm92ZkRjUHc2bVoyQkdBL1hpdHVBM2daTXhvQW5INHdHRlJtc3hreHpST0pCTnJ2OTZRb25BRHdRQVJJcnBJR2dCQ3lTcVVTQXFORytvRGhhN1ZhcEZxNkFHQ0ZPQUpBN3JYYjdSTWRkd1R3ZXpRYXVWNTBKeWwwRGtFRGdCUlNGRVdaVHFjc0tiUnpXcXpMWUZJS2VZby9DYW1UU2pnRURjQ0hJaWFLdjhqSmN3Z2FnSE5ocmRkckJkTFByWTBXQ2dVVURvZEpwdy9MSENPQXRWR3FlTmVpd2lHaTBTajFIamhjWktacG1ncDBHL3dpZys2a3F1cE8xM1dWOHlKakV1L1pGZkFuSXp3RE9hekVad0E1UkdhWFRDWi9FSG8vWGdvV1BFOFBUMDVtOFVSaC84ak1jWW1ubnF6UGRwcGJQQlVBdTZWZjU0T0cyTnp2NUV1cXo3OFRuWjR5L2o4QVNUOXNDUldzV3hpRUlvRGZFK0JHV1Q3Z1dPRjVxbW1hTlBGTVhjaExuSnQzOGhyTGF3OVlEc1FaSXhRQlp6SUx4QzNGWHhVQkZvaGJpNWNDZ0YxMno3Z1Y5ME84TklCekNNdXluSjlIcEJhc3RDNUVLMno0WG5hMzhkcnpxaUoyVy9Ud1IzZks2dzNMMDJGWXhrb0hZTmxVNXBnSGdNelRGRm5yRVFHUlU1TTU1OVZINEM5b2NZbFBSQjVJdVFBQUFBQkpSVTVFcmtKZ2dnPT0nKSAyeCkgOCA4LCBuZXN3LXJlc2l6ZTtcXHJcXG4gICAgLS1jdXJzb3ItZGVsZXRlOiAtd2Via2l0LWltYWdlLXNldCh1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBREFBQUFBd0NBWUFBQUJYQXZtSEFBQUJuMGxFUVZSb1ErM1lNVzZFTUJBQXdMMFhtTmVraFlyYUZHNm80QVA1QXZBVHFHbDRBclJKbHo0U1NIa0F2SURJbGpqbEJIZXNBUWV2aEt1VHpwaWRYYThSM0lRUWRWbVdIaEFkTndBWWhSQU5WWVFDeU9SVFJTZ0FZd3lHWVNDSlVJQWtTYUJ0V3lpS2doemlEa2pURktJb0lvZDRBTWhlMEVTby90azQ1TDEzanhsQUV6RzZyZ3VlaHorRjY3cUdwbW5rYmN3Qk5CQ3FmK1Qyd3c0NU44c3k4d0Frd200QUFqSEs3YU83aGVRMk1yNkYvbTZKRjQxdFp4TXY3V2ZOMHduYkVydm5MWjVDejFhMUVhRUZRUFRFN296cUxxQU5zQTJ4Q1dBVFlqUEFGc1F1Z0EySTNZQ3pFWWNBemtRY0JqZ0xjU2pnRE1UaGdQOUdvQUJ4SEVPZTU3b1BTVFhmOU5lT1ZjQVV2Ty83MzR5eG55MktJQWpld3pEODJuTHQyalV2QVZQd25QUFBxcXJlMWhZNzQvK25BQXJCVDI5RnM5ZENLc0V2QWlnRlB3TlFDLzRCMEhXZE9pcHRidGlsUTBJMXNlTTQwUGM5dWVEdkZaQS9xR1YrcW9hcUFOWGdWUVU0NXgrMlBxUXdEOFpEUHJCaWJtUnF6Z1V3bFZuc3VsY0ZzSmt5TmUrcWdLbk1ZdGU5S29ETmxLbDVWd1ZNWlJhN0x2a0svQUl5YTRCQXZtSDlZUUFBQUFCSlJVNUVya0pnZ2c9PScpIDJ4KSwgcG9pbnRlcjtcXHJcXG4gICAgLS1jdXJzb3ItYWRkOiAtd2Via2l0LWltYWdlLXNldCh1cmwoJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBREFBQUFBd0NBWUFBQUJYQXZtSEFBQUNFRWxFUVZSb1ErMllzVzdDTUJDR25aRXM0V202aG9sMkRFT2tLa01FTDlCWEFONEVtQ3F4TUxaYnNyWmI5MG9nOVFGZ2dUSFZXWmdHWStKTGJOZXhsSk9RSXNVKzMzZi9uZTNneFhHY3JkZnJBWEhVUEVKSUVjZHhyZ05pdFZvOUg0L0hSejRYdnUrL3AybjZhaUpIRkFBYzY0QTRxeG55Z2Vyd2ZRK2VBZ1JCUUE2SGd6SUVBeWdLbWhOcW51Y3ArNjFTamdKTXAxT3kzVzdKY3JsVVdzd3F3R3cySStQeFdBbkNPZ0JJVlJQaXIxWktPdk1sZEtjRVFIMWx1NVFRS01Dc0JrUVJoaUVaREs1MzRiS3Y4alA0ejdLTTVIbE8yME01K3JNVDJnUDhRa2dJNGR5cXdHQ2QrWHh1SGdCWlR1MEdRRUFVVUQ1OENZR2l6Q0Rqc0pVeWd4S0NuL0VTS3BkQlJUbTFzNGxGTll6cGlWWnNvMVVOS0lOb1BZQ3NKNXdBcUlLd2Rwa1RuUU95UTBaVVRuQ2RQcDFPVC96Y1hxLzNadlE2M1FSQVZrNnlCT2g2TDd4SzFIRXVhK3c2dnBxTVZRYXdyWVFXQUpzUTJnQnNRV2dGc0FHaEhlQy9JVkFBazhtRUxCYUxKcHVFMGpjMlprRXBBQXQrT0J4K0IwSHdnM0hLanhtTlJpOUprbncxbVN1YlV3bkFnbytpNkhPejJUekluTmw0ZnhmQWhlRFpWOUhOWjZFcndRc0JYQXIrQnNDMTRLOEFkcnNkM1NyYjNMQ2lUWUkyY2IvZkovdjkzcm5nTHdyQWcydVpaMnBRQlZ3Tm5pb1FSZEZIV3c4cHpNR281UTlXekVLbXhuUUFwaktMOWRzcGdNMlVxWEdkQXFZeWkvWGJLWURObEtseG5RS21Nb3YxNjd3Q3Y3TXU3a0JMUDdiaUFBQUFBRWxGVGtTdVFtQ0MnKSAyeCksIHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi8qIDEuMi4gTGF5b3V0ICovXFxyXFxuLkNhbnZhc1Rvb2xzRWRpdG9yIHtcXHJcXG4gICAgZGlzcGxheTogZ3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnI7XFxyXFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyOyBcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxyXFxufVxcclxcblxcclxcbi5DYW52YXNUb29sc0VkaXRvciAqIHtcXHJcXG4gICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxyXFxufVxcclxcblxcclxcbi5DYW52YXNUb29sc0VkaXRvciBjYW52YXMge1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICAgIGdyaWQtcm93OiAxO1xcclxcbiAgICBncmlkLWNvbHVtbjogMTtcXHJcXG4gICAgei1pbmRleDogMTAwO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzExMTtcXHJcXG59XFxyXFxuXFxyXFxuLkNhbnZhc1Rvb2xzRWRpdG9yIHN2ZyB7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgZ3JpZC1yb3c6IDE7XFxyXFxuICAgIGdyaWQtY29sdW1uOiAxO1xcclxcbiAgICB6LWluZGV4OiAxMDE7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbi5DYW52YXNUb29sc0VkaXRvciBzdmcge1xcclxcbiAgICBjdXJzb3I6IHZhcigtLWN1cnNvci1wb2ludGVyKTtcXHJcXG59XFxyXFxuXFxyXFxuLyogMi4gUmVnaW9uc01hbmFnZXJcXHJcXG5cXHJcXG4ucmVnaW9uTWFuYWdlclxcclxcbi0tPi5yZWdpb25TdHlsZVxcclxcbiAgICAtLT4gLnRhZ3NMYXllclxcclxcbiAgICAtLT4gLmRyYWdMYXllclxcclxcbiAgICAtLT4gLmFuY2hvcnNMYXllclxcclxcbiAgICBcXHJcXG4tLT4gLm1lbnVMYXllclxcclxcbiAgICAtLT4gLm1lbnVSZWN0U3R5bGVcXHJcXG4qL1xcclxcblxcclxcbi8qIDIuMS4gR2VuZXJhbCBzZXR0aW5ncyBhbmQgbGF5b3V0ICovXFxyXFxuLnJlZ2lvbk1hbmFnZXIge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLnJlZ2lvblN0eWxlIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IHZpc2libGVQYWludGVkO1xcclxcbn1cXHJcXG5cXHJcXG4uZHJhZ1JlY3RTdHlsZSB7XFxyXFxuICAgIGZpbGw6IHRyYW5zcGFyZW50OyBcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbiAgICBjdXJzb3I6IHZhcigtLWN1cnNvci1tb3ZlKTtcXHJcXG59XFxyXFxuXFxyXFxuLmRyYWdQb2ludFN0eWxlIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbiAgICBjdXJzb3I6IHZhcigtLWN1cnNvci1tb3ZlKTtcXHJcXG4gICAgZmlsdGVyOiB1cmwoI2JsYWNrLWdsb3cpO1xcclxcbn1cXHJcXG5cXHJcXG4udGFnc0xheWVyIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnUmVjdFN0eWxlIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAyO1xcclxcbiAgICBzdHJva2UtZGFzaGFycmF5OiAwLjUgNDtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBmaWx0ZXI6IHVybCgjYmxhY2stZ2xvdyk7XFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnUG9pbnRTdHlsZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMTsgXFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnVGV4dFN0eWxlIHtcXHJcXG4gICAgZm9udC1mYW1pbHk6ICdTZWdvZSBVSScsIFRhaG9tYSwgR2VuZXZhLCBWZXJkYW5hLCBzYW5zLXNlcmlmO1xcclxcbiAgICBmb250LXNpemU6IDlwdDtcXHJcXG4gICAgZmlsbDogI2ZmZjtcXHJcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5zZWNvbmRhcnlUYWdTdHlsZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5hbmNob3JTdHlsZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMjtcXHJcXG59XFxyXFxuXFxyXFxuLmFuY2hvclN0eWxlLmdob3N0IHtcXHJcXG4gICAgY3Vyc29yOiB2YXIoLS1jdXJzb3ItcmVzaXplKTtcXHJcXG59XFxyXFxuXFxyXFxuLmFuY2hvclN0eWxlLmdob3N0LmRlbGV0ZSB7XFxyXFxuICAgIGN1cnNvcjogdmFyKC0tY3Vyc29yLWRlbGV0ZSk7XFxyXFxufVxcclxcblxcclxcbi5hbmNob3JTdHlsZS5naG9zdC5hZGQge1xcclxcbiAgICBjdXJzb3I6IHZhcigtLWN1cnNvci1hZGQpO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5jaG9yU3R5bGUuZ2hvc3Qge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDA7XFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnQm91bmRSZWN0U3R5bGUge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNTtcXHJcXG59XFxyXFxuXFxyXFxuLnByaW1hcnlUYWdQb2x5bGluZVN0eWxlLCAucHJpbWFyeVRhZ1BvbHlnb25TdHlsZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMjtcXHJcXG4gICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xcclxcbiAgICBzdHJva2UtZGFzaGFycmF5OiAwLjUgNDtcXHJcXG59XFxyXFxuXFxyXFxuLyogMi4yLiBEZWZhdWx0IGNvbG9ycyAqL1xcclxcbi5yZWdpb25NYW5hZ2VyIHtcXHJcXG4gICAgLS1kZWZhdWx0LWNvbG9yLXB1cmU6IHJnYigxMjgsIDEyOCwgMTI4KTtcXHJcXG4gICAgLS1kZWZhdWx0LWNvbG9yLWFjY2VudDogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjgpO1xcclxcbiAgICAtLWRlZmF1bHQtY29sb3ItZGFyazogcmdiYSg2NCwgNjQsIDY0LCAwLjgpO1xcclxcbiAgICAtLWRlZmF1bHQtY29sb3Itc2hhZG93OiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNCk7XFxyXFxuICAgIC0tZGVmYXVsdC1jb2xvci1oaWdobGlnaHQ6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC4yKTtcXHJcXG4gICAgLS1kZWZhdWx0LWNvbG9yLXdoaXRlOiByZ2IoMjU1LCAyNTUsIDI1NSk7XFxyXFxuICAgIC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudDogcmdiKDI1NSwgMjU1LCAyNTUsIDApO1xcclxcbiAgICAtLWRlZmF1bHQtY29sb3ItZ2hvc3Q6IHJnYigyNTUsIDI1NSwgMjU1LCAwLjUpO1xcclxcbiAgICAtLWRlZmF1bHQtY29sb3ItZGVsZXRlOiByZ2JhKDIxNiwgMjQsIDY1LCAxLjApO1xcclxcbiAgICAtLWRlZmF1bHQtY29sb3ItYWRkOiByZ2JhKDIxLCAxMjcsIDI0MCwgMS4wKTtcXHJcXG59XFxyXFxuXFxyXFxuLyogMi4yLjEuIFNoYXJlZCBjb2xvcnMgKi9cXHJcXG4uc2Vjb25kYXJ5VGFnU3R5bGUge1xcclxcbiAgICBmaWxsOiB2YXIoLS1kZWZhdWx0LWNvbG9yLWFjY2VudCk7XFxyXFxufVxcclxcblxcclxcbi5hbmNob3JTdHlsZSB7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci1kYXJrKTtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1wdXJlKTtcXHJcXG59XFxyXFxuXFxyXFxuLnJlZ2lvblN0eWxlOmhvdmVyIC5hbmNob3JTdHlsZSB7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci13aGl0ZSk7XFxyXFxufVxcclxcblxcclxcbi5hbmNob3JTdHlsZS5naG9zdCB7XFxyXFxuICAgIGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3ItdHJhbnNwYXJlbnQpO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5jaG9yU3R5bGUuZ2hvc3Q6aG92ZXIsXFxyXFxuLnJlZ2lvblN0eWxlLnNlbGVjdGVkIC5hbmNob3JTdHlsZS5naG9zdCxcXHJcXG4ucmVnaW9uU3R5bGUuc2VsZWN0ZWQgLmFuY2hvclN0eWxlLmdob3N0OmhvdmVyIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1naG9zdCk7XFxyXFxufVxcclxcblxcclxcbi5hbmNob3JTdHlsZTpob3ZlciB7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci13aGl0ZSk7XFxyXFxufVxcclxcblxcclxcbi8qIDIuMi4yLiBSZWN0IHJlZ2lvbiBjb2xvcnMgKi9cXHJcXG4ucHJpbWFyeVRhZ1JlY3RTdHlsZSB7XFxyXFxuICAgIGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3Itc2hhZG93KTtcXHJcXG4gICAgc3Ryb2tlOnZhcigtLWRlZmF1bHQtY29sb3ItYWNjZW50KTtcXHJcXG59XFxyXFxuXFxyXFxuLnJlZ2lvblN0eWxlOmhvdmVyIC5wcmltYXJ5VGFnUmVjdFN0eWxlIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1oaWdobGlnaHQpO1xcclxcbiAgICBzdHJva2U6IHZhcigtLWRlZmF1bHQtY29sb3Itd2hpdGUpO1xcclxcbn1cXHJcXG5cXHJcXG4ucmVnaW9uU3R5bGUuc2VsZWN0ZWQgLnByaW1hcnlUYWdSZWN0U3R5bGUge1xcclxcbiAgICBmaWxsOiB2YXIoLS1kZWZhdWx0LWNvbG9yLWhpZ2hsaWdodCk7XFxyXFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnVGV4dEJHU3R5bGUge1xcclxcbiAgICBmaWxsOiB2YXIoLS1kZWZhdWx0LWNvbG9yLWRhcmspO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5jaG9yQm9uZVN0eWxlIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7XFxyXFxufVxcclxcblxcclxcbi8qIDIuMi4zLiBQb2ludCByZWdpb24gIGNvbG9ycyAqL1xcclxcbi5wcmltYXJ5VGFnUG9pbnRTdHlsZSB7XFxyXFxuICAgIGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3ItcHVyZSk7XFxyXFxuICAgIHN0cm9rZTp2YXIoLS1kZWZhdWx0LWNvbG9yLXdoaXRlKTtcXHJcXG59XFxyXFxuXFxyXFxuLmRyYWdQb2ludFN0eWxlIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1naG9zdCk7XFxyXFxuICAgIG9wYWNpdHk6IDAuNTtcXHJcXG59XFxyXFxuXFxyXFxuLnJlZ2lvblN0eWxlOmhvdmVyIC5kcmFnUG9pbnRTdHlsZSxcXHJcXG4ucmVnaW9uU3R5bGUuc2VsZWN0ZWQgLmRyYWdQb2ludFN0eWxlIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1naG9zdCk7XFxyXFxuICAgIG9wYWNpdHk6IDEuMDtcXHJcXG59XFxyXFxuXFxyXFxuLyogMi4yLjQuIFBvbHlsaW5lLCBwb2x5Z29uIHJlZ2lvbiBjb2xvcnMgKi9cXHJcXG4ucHJpbWFyeVRhZ0JvdW5kUmVjdFN0eWxlIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1zaGFkb3cpO1xcclxcbiAgICBzdHJva2U6dmFyKC0tZGVmYXVsdC1jb2xvci1hY2NlbnQpO1xcclxcbiAgICBvcGFjaXR5OiAwLjI1O1xcclxcbn1cXHJcXG5cXHJcXG4ucmVnaW9uU3R5bGUuc2VsZWN0ZWQgLnByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZSB7XFxyXFxuICAgIGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3ItaGlnaGxpZ2h0KTtcXHJcXG59XFxyXFxuXFxyXFxuLnJlZ2lvblN0eWxlOmhvdmVyIC5wcmltYXJ5VGFnQm91bmRSZWN0U3R5bGUge1xcclxcbiAgICBmaWxsOiB2YXIoLS1kZWZhdWx0LWNvbG9yLWhpZ2hsaWdodCk7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci13aGl0ZSk7XFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnUG9seWxpbmVTdHlsZSB7XFxyXFxuICAgIGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3ItdHJhbnNwYXJlbnQpO1xcclxcbiAgICBzdHJva2U6IHZhcigtLWRlZmF1bHQtY29sb3ItcHVyZSk7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25TdHlsZS5zZWxlY3RlZCAucHJpbWFyeVRhZ1BvbHlsaW5lU3R5bGUge1xcclxcbiAgICBmaWx0ZXI6IHVybCgjYmxhY2stZ2xvdyk7XFxyXFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5wcmltYXJ5VGFnUG9seWdvblN0eWxlIHtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci1zaGFkb3cpO1xcclxcbiAgICBzdHJva2U6IHZhcigtLWRlZmF1bHQtY29sb3ItcHVyZSk7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25TdHlsZS5zZWxlY3RlZCAucHJpbWFyeVRhZ1BvbHlnb25TdHlsZSB7XFxyXFxuICAgIGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3ItaGlnaGxpZ2h0KTtcXHJcXG4gICAgZmlsdGVyOiB1cmwoI2JsYWNrLWdsb3cpO1xcclxcbiAgICBzdHJva2UtZGFzaGFycmF5OiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4ucmVnaW9uU3R5bGU6aG92ZXIgLnByaW1hcnlUYWdQb2x5Z29uU3R5bGUge1xcclxcbiAgICBmaWxsOiB2YXIoLS1kZWZhdWx0LWNvbG9yLWhpZ2hsaWdodCk7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25TdHlsZTpob3ZlciAuYW5jaG9yU3R5bGUuZ2hvc3QuZGVsZXRlLFxcclxcbi5yZWdpb25TdHlsZS5zZWxlY3RlZCAuYW5jaG9yU3R5bGUuZ2hvc3QuZGVsZXRlLFxcclxcbi5hbmNob3JTdHlsZS5naG9zdC5kZWxldGUsXFxyXFxuLmFuY2hvclN0eWxlLmdob3N0LmRlbGV0ZTpob3ZlciB7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci1kZWxldGUpO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25TdHlsZTpob3ZlciAuYW5jaG9yU3R5bGUuZ2hvc3QuYWRkLFxcclxcbi5yZWdpb25TdHlsZS5zZWxlY3RlZCAuYW5jaG9yU3R5bGUuZ2hvc3QuYWRkLFxcclxcbi5hbmNob3JTdHlsZS5naG9zdC5hZGQsXFxyXFxuLmFuY2hvclN0eWxlLmdob3N0LmFkZDpob3ZlciB7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci1hZGQpO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDJweDtcXHJcXG4gICAgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7XFxyXFxufVxcclxcblxcclxcbi5hbmNob3JMaW5lU3R5bGUge1xcclxcbiAgICBmaWxsOiBub25lO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDU7XFxyXFxuICAgIHN0cm9rZTogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7ICBcXHJcXG59XFxyXFxuXFxyXFxuc3ZnOm5vdCg6cm9vdCkgLm1lbnVMYXllciB7XFxyXFxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcclxcbn1cXHJcXG5cXHJcXG4ubWVudVJlY3RTdHlsZSB7IFxcclxcbiAgICBzdHJva2Utd2lkdGg6MDtcXHJcXG4gICAgZmlsbDogcmdiYSg2NCwgNjQsIDY0LCAwLjgpO1xcclxcbiAgICBmaWx0ZXI6IHVybCgjYmxhY2stZ2xvdyk7IFxcclxcbn1cXHJcXG5cXHJcXG4ubWVudUl0ZW1CYWNrIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxLjU7XFxyXFxuICAgIHN0cm9rZTogcmdiYSgxOTgsIDE5OCwgMTk4LCAwLjIpO1xcclxcbiAgICBmaWxsOiAgcmdiKDMyLCAzMiwgMzIpO1xcclxcbn1cXHJcXG5cXHJcXG4ubWVudUljb24ge1xcclxcbiAgICBmb250LWZhbWlseTogJ1NlZ29lIFVJIEVtb2ppJywgVGFob21hLCBHZW5ldmEsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTBwdDtcXHJcXG4gICAgZmlsbDogcmdiKDY0LCA2NCwgNjQpO1xcclxcbn1cXHJcXG5cXHJcXG4ubWVudUl0ZW0ge1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDEuNTtcXHJcXG4gICAgc3Ryb2tlOiByZ2JhKDE5OCwgMTk4LCAxOTgsIDAuMik7XFxyXFxuICAgIGZpbGw6dHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcblxcclxcbi5tZW51SXRlbTpob3ZlciB7XFxyXFxuICAgIHN0cm9rZTogcmdiYSgxOTgsIDE5OCwgMTk4LCAwLjgpO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBGcmVlemluZyByZWdpb25zICovIFxcclxcblxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkLFxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5kcmFnUmVjdFN0eWxlLFxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5kcmFnUG9pbnRTdHlsZSB7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4ucmVnaW9uTWFuYWdlci5mcm96ZW4gLnJlZ2lvblN0eWxlLm9sZCAuZHJhZ1JlY3RTdHlsZSwgXFxyXFxuLnJlZ2lvbk1hbmFnZXIuZnJvemVuIC5yZWdpb25TdHlsZS5vbGQgLmFuY2hvclN0eWxlLlRMLCBcXHJcXG4ucmVnaW9uTWFuYWdlci5mcm96ZW4gLnJlZ2lvblN0eWxlLm9sZCAuYW5jaG9yU3R5bGUuQlIsIFxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5hbmNob3JTdHlsZS5UUiwgXFxyXFxuLnJlZ2lvbk1hbmFnZXIuZnJvemVuIC5yZWdpb25TdHlsZS5vbGQgLmFuY2hvclN0eWxlLkJMIHtcXHJcXG4gICAgY3Vyc29yOiBkZWZhdWx0OyBcXHJcXG59XFxyXFxuXFxyXFxuLnJlZ2lvbk1hbmFnZXIuZnJvemVuIC5hbmNob3JTdHlsZS5naG9zdCB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkLCBcXHJcXG4ucmVnaW9uTWFuYWdlci5mcm96ZW4gLnJlZ2lvblN0eWxlLm9sZDpob3ZlcntcXHJcXG4gICAgb3BhY2l0eTogMC41O1xcclxcbn1cXHJcXG5cXHJcXG4ucmVnaW9uTWFuYWdlci5mcm96ZW4gLnJlZ2lvblN0eWxlLm9sZCAucHJpbWFyeVRhZ1JlY3RTdHlsZSxcXHJcXG4ucmVnaW9uTWFuYWdlci5mcm96ZW4gLnJlZ2lvblN0eWxlLm9sZCAucHJpbWFyeVRhZ1BvaW50U3R5bGUsXFxyXFxuLnJlZ2lvbk1hbmFnZXIuZnJvemVuIC5yZWdpb25TdHlsZS5vbGQgLnByaW1hcnlUYWdQb2x5bGluZVN0eWxlLFxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5wcmltYXJ5VGFnUG9seWdvblN0eWxlIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxO1xcclxcbiAgICBzdHJva2UtZGFzaGFycmF5OiAwIDA7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5hbmNob3JTdHlsZSB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5wcmltYXJ5VGFnVGV4dFN0eWxlLFxcclxcbi5yZWdpb25NYW5hZ2VyLmZyb3plbiAucmVnaW9uU3R5bGUub2xkIC5wcmltYXJ5VGFnVGV4dEJHU3R5bGUge1xcclxcbiAgICBvcGFjaXR5OiAwLjI1O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBBcmVhU2VsZWN0b3JcXHJcXG5cXHJcXG4uYXJlYVNlbGVjdG9yXFxyXFxuLS0+LnJlY3RTZWxlY3RvclxcclxcbiAgICAtLT4gLm1hc2tTdHlsZVxcclxcbiAgICAgICAgW21hc2tdXFxyXFxuICAgICAgICAgICAgLm1hc2tJblN0eWxlXFxyXFxuICAgICAgICAgICAgLm1hc2tPdXRTdHlsZVxcclxcbiAgICAgICAgLmNyb3NzU3R5bGVcXHJcXG4gICAgICAgICAgICBsaW5lXFxyXFxuICAgICAgICAgICAgbGluZVxcclxcbi0tPi5yZWN0Q29weVNlbGVjdG9yXFxyXFxuICAgIC0tPiAuY3Jvc3NTdHlsZVxcclxcbiAgICAgICAgICAgIGxpbmVcXHJcXG4gICAgICAgICAgICBsaW5lXFxyXFxuICAgICAgICAuY29weVJlY3RTdHlsZVxcclxcbi0tPi5wb2ludFNlbGVjdG9yXFxyXFxuICAgIC0tPiAuY3Jvc3NTdHlsZVxcclxcbiAgICAgICAgLnBvaW50U3R5bGVcXHJcXG4tLT4ucG9seWxpbmVTZWxlY3RvclxcclxcbiAgICAtLT4gLnBvbHlsaW5lU3R5bGVcXHJcXG4gICAgICAgIC5wb2x5bGluZUdyb3VwU3R5bGVcXHJcXG4gICAgICAgIC0tPiAucG9seWxpbmVQb2ludFN0eWxlXFxyXFxuICAgICAgICAubmV4dFNlZ21lbnRTdHlsZVxcclxcbiAgICAgICAgLm5leHRQb2ludFN0eWxlXFxyXFxuLS0+LnBvbHlnb25TZWxlY3RvclxcclxcbiAgICAtLT4gLnBvbHlnb25TdHlsZVxcclxcbiAgICAgICAgLnBvbHlnb25Hcm91cFN0eWxlXFxyXFxuICAgICAgICAtLT4gLnBvbHlnb25Qb2ludFN0eWxlXFxyXFxuICAgICAgICAubmV4dFNlZ21lbnRTdHlsZVxcclxcbiAgICAgICAgLm5leHRQb2ludFN0eWxlXFxyXFxuKi9cXHJcXG5cXHJcXG4qL1xcclxcbiNzZWxlY3Rpb25PdmVybGF5IHtcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNyb3NzU3R5bGUgbGluZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDoxO1xcclxcbiAgICBzdHJva2UtZGFzaGFycmF5OiAzIDM7XFxyXFxuICAgIHN0cm9rZTogIzY2NjtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7IFxcclxcbn1cXHJcXG5cXHJcXG4ucmVjdFNlbGVjdG9yIC5tYXNrU3R5bGUge1xcclxcbiAgICBmaWxsOiAjMDAwO1xcclxcbiAgICBmaWxsLW9wYWNpdHk6IDAuNTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLm1hc2tJblN0eWxlIHtcXHJcXG4gICAgZmlsbDogI2ZmZjtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAwO1xcclxcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLm1hc2tPdXRTdHlsZSB7XFxyXFxuICAgIC8qIFRyYW5zcGFyZW50IGNyb3AqL1xcclxcbiAgICBmaWxsOiAjMDAwO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDA7XFxyXFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4ucmVjdENvcHlTZWxlY3RvciAuY29weVJlY3RTdHlsZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDoxO1xcclxcbiAgICBzdHJva2U6ICM2NjY7XFxyXFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgXFxyXFxufVxcclxcblxcclxcbi5wb2ludFNlbGVjdG9yIC5wb2ludFN0eWxlIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOjI7XFxyXFxuICAgIHN0cm9rZTogcmdiYSgyMSwgMTI3LCAyNDAsIDEuMCk7XFxyXFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTsgXFxyXFxufVxcclxcblxcclxcbi5wb2x5bGluZVNlbGVjdG9yIC5wb2x5bGluZVN0eWxlIHtcXHJcXG4gICAgZmlsbDogdHJhbnNwYXJlbnQ7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMnB4O1xcclxcbiAgICBzdHJva2U6ICByZ2JhKDIxLCAxMjcsIDI0MCwgMC41KTtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5wb2x5bGluZVNlbGVjdG9yIC5wb2x5bGluZVBvaW50U3R5bGUge1xcclxcbiAgICBmaWxsOiAgcmdiYSgyMSwgMTI3LCAyNDAsIDEuMCk7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5wb2x5bGluZVNlbGVjdG9yIC5uZXh0U2VnbWVudFN0eWxlIHtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOjI7XFxyXFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6IDMgMztcXHJcXG4gICAgc3Ryb2tlOiByZ2JhKDIxLCAxMjcsIDI0MCwgMS4wKTtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcbi5wb2x5bGluZVNlbGVjdG9yIC5uZXh0UG9pbnRTdHlsZSB7XFxyXFxuICAgIHN0cm9rZS13aWR0aDoyO1xcclxcbiAgICByOiA2cHg7XFxyXFxuICAgIHN0cm9rZTogcmdiYSgyMSwgMTI3LCAyNDAsIDEuMCk7XFxyXFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvbHlnb25TZWxlY3RvciAucG9seWdvblN0eWxlIHtcXHJcXG4gICAgZmlsbDogcmdiYSgyNTUsMjU1LDI1NSwgMC4yKTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAycHg7XFxyXFxuICAgIHN0cm9rZTogIHJnYmEoMjEsIDEyNywgMjQwLCAwLjUpO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvbHlnb25TZWxlY3RvciAucG9seWdvblBvaW50U3R5bGUge1xcclxcbiAgICBmaWxsOiAgcmdiYSgyMSwgMTI3LCAyNDAsIDEuMCk7XFxyXFxuICAgIHN0cm9rZS13aWR0aDogMDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5wb2x5Z29uU2VsZWN0b3IgLm5leHRTZWdtZW50U3R5bGUge1xcclxcbiAgICBzdHJva2Utd2lkdGg6MjtcXHJcXG4gICAgc3Ryb2tlLWRhc2hhcnJheTogMyAzO1xcclxcbiAgICBzdHJva2U6IHJnYmEoMjEsIDEyNywgMjQwLCAxLjApO1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuLnBvbHlnb25TZWxlY3RvciAubmV4dFBvaW50U3R5bGUge1xcclxcbiAgICBzdHJva2Utd2lkdGg6MjtcXHJcXG4gICAgcjogNnB4O1xcclxcbiAgICBzdHJva2U6IHJnYmEoMjEsIDEyNywgMjQwLCAxLjApO1xcclxcbiAgICBmaWxsOiB0cmFuc3BhcmVudDtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi8qIFRvb2xiYXIgXFxyXFxuXFxyXFxuLnRvb2xiYXJMYXllclxcclxcbi0tPiAudG9vbGJhckJHU3R5bGVcXHJcXG4tLT4gLmljb25zTGF5ZXJTdHlsZVxcclxcbiAgICAtLT4gLmljb25TdHlsZVxcclxcbiAgICAgICAgLS0+IC5pY29uQkdSZWN0U3R5bGVcXHJcXG4gICAgICAgICAgICAuaWNvbkltYWdlU3R5bGVcXHJcXG4qL1xcclxcbi50b29sYmFyQkdTdHlsZSB7XFxyXFxuICAgIGZpbGw6ICM2NjY7XFxyXFxufVxcclxcblxcclxcbi5pY29uU3R5bGUge1xcclxcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcclxcbn1cXHJcXG5cXHJcXG4uaWNvblN0eWxlLnNlbGVjdG9yIC5pY29uQkdSZWN0U3R5bGV7XFxyXFxuICAgIGZpbGw6IHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG5cXHJcXG4uaWNvblN0eWxlLnNlbGVjdG9yOmhvdmVyIC5pY29uQkdSZWN0U3R5bGV7XFxyXFxuICAgIGZpbGw6IHJnYmEoNjgsIDY4LCA2OCwgMC41KTtcXHJcXG59XFxyXFxuXFxyXFxuLmljb25TdHlsZS5zZWxlY3Rvci5zZWxlY3RlZCAuaWNvbkJHUmVjdFN0eWxlIHtcXHJcXG4gICAgZmlsbDogIzMzMztcXHJcXG59XFxyXFxuXFxyXFxuLmljb25TdHlsZSAuaWNvbkltYWdlU3R5bGUgKiB7XFxyXFxuICAgIHN0cm9rZTogI2ZmZjtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLmljb25TdHlsZS5zd2l0Y2ggLmljb25CR1JlY3RTdHlsZXtcXHJcXG4gICAgZmlsbDogdHJhbnNwYXJlbnQ7XFxyXFxufVxcclxcblxcclxcbi5pY29uU3R5bGUuc3dpdGNoOmhvdmVyIC5pY29uQkdSZWN0U3R5bGV7XFxyXFxuICAgIGZpbGw6IHJnYmEoNjgsIDY4LCA2OCwgMC41KTtcXHJcXG59XFxyXFxuXFxyXFxuLmljb25TdHlsZS5zd2l0Y2ggLmljb25JbWFnZVN0eWxlICoge1xcclxcbiAgICBzdHJva2U6ICMzMzM7XFxyXFxufVxcclxcblxcclxcbi5pY29uU3R5bGUuc3dpdGNoLnNlbGVjdGVkIC5pY29uSW1hZ2VTdHlsZSAqIHtcXHJcXG4gICAgc3Ryb2tlOiByZ2IoMTQsIDE4NiwgMjUzKTtcXHJcXG4gICAgc3Ryb2tlLXdpZHRoOiAxLjU7XFxyXFxufVxcclxcblxcclxcbi5pY29uU3R5bGUgLmljb25JbWFnZVN0eWxlIC5hY2NlbnQtZiB7XFxyXFxuICAgIGZpbGw6IHJnYmEoMjEsIDEyNywgMjQwLCAxLjApO1xcclxcbn1cXHJcXG5cXHJcXG4uaWNvblN0eWxlIC5pY29uSW1hZ2VTdHlsZSAuYWNjZW50LXMge1xcclxcbiAgICBzdHJva2U6IHJnYmEoMjEsIDEyNywgMjQwLCAxLjApO1xcclxcbn1cXHJcXG5cXHJcXG4uaWNvblN0eWxlLnNlcGFyYXRvciBsaW5lIHtcXHJcXG4gICAgc3Ryb2tlOiAjMzMzO1xcclxcbiAgICBzdHJva2Utd2lkdGg6IDAuNXB4O1xcclxcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgXFxcXFxuLy8g4pSCIEV2ZSAwLjUuNCAtIEphdmFTY3JpcHQgRXZlbnRzIExpYnJhcnkgICAgICAgICAgICAgICAgICAgICAg4pSCIFxcXFxcbi8vIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpCBcXFxcXG4vLyDilIIgQXV0aG9yIERtaXRyeSBCYXJhbm92c2tpeSAoaHR0cDovL2RtaXRyeS5iYXJhbm92c2tpeS5jb20vKSDilIIgXFxcXFxuLy8g4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYIFxcXFxcblxuKGZ1bmN0aW9uIChnbG9iKSB7XG4gICAgdmFyIHZlcnNpb24gPSBcIjAuNS40XCIsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgc2VwYXJhdG9yID0gL1tcXC5cXC9dLyxcbiAgICAgICAgY29tYXNlcGFyYXRvciA9IC9cXHMqLFxccyovLFxuICAgICAgICB3aWxkY2FyZCA9IFwiKlwiLFxuICAgICAgICBudW1zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudF9ldmVudCxcbiAgICAgICAgc3RvcCxcbiAgICAgICAgZXZlbnRzID0ge246IHt9fSxcbiAgICAgICAgZmlyc3REZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYXN0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvYmp0b3MgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcikge1xuICAgICAgICAgICAgcmV0dXJuIGFyIGluc3RhbmNlb2YgQXJyYXkgfHwgb2JqdG9zLmNhbGwoYXIpID09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfSxcbiAgICAvKlxcXG4gICAgICogZXZlXG4gICAgIFsgbWV0aG9kIF1cblxuICAgICAqIEZpcmVzIGV2ZW50IHdpdGggZ2l2ZW4gYG5hbWVgLCBnaXZlbiBzY29wZSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cblxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgKmV2ZW50KiwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZFxuICAgICAtIHNjb3BlIChvYmplY3QpIGNvbnRleHQgZm9yIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAtIHZhcmFyZ3MgKC4uLikgdGhlIHJlc3Qgb2YgYXJndW1lbnRzIHdpbGwgYmUgc2VudCB0byBldmVudCBoYW5kbGVyc1xuXG4gICAgID0gKG9iamVjdCkgYXJyYXkgb2YgcmV0dXJuZWQgdmFsdWVzIGZyb20gdGhlIGxpc3RlbmVycy4gQXJyYXkgaGFzIHR3byBtZXRob2RzIGAuZmlyc3REZWZpbmVkKClgIGFuZCBgLmxhc3REZWZpbmVkKClgIHRvIGdldCBmaXJzdCBvciBsYXN0IG5vdCBgdW5kZWZpbmVkYCB2YWx1ZS5cbiAgICBcXCovXG4gICAgICAgIGV2ZSA9IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIG9sZHN0b3AgPSBzdG9wLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGV2ZS5saXN0ZW5lcnMobmFtZSksXG4gICAgICAgICAgICAgICAgeiA9IDAsXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBpbmRleGVkID0gW10sXG4gICAgICAgICAgICAgICAgcXVldWUgPSB7fSxcbiAgICAgICAgICAgICAgICBvdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBjZSA9IGN1cnJlbnRfZXZlbnQ7XG4gICAgICAgICAgICBvdXQuZmlyc3REZWZpbmVkID0gZmlyc3REZWZpbmVkO1xuICAgICAgICAgICAgb3V0Lmxhc3REZWZpbmVkID0gbGFzdERlZmluZWQ7XG4gICAgICAgICAgICBjdXJyZW50X2V2ZW50ID0gbmFtZTtcbiAgICAgICAgICAgIHN0b3AgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIGlmIChcInpJbmRleFwiIGluIGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChsaXN0ZW5lcnNbaV0uekluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLnpJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbbGlzdGVuZXJzW2ldLnpJbmRleF0gPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXhlZC5zb3J0KG51bXNvcnQpO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4ZWRbel0gPCAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IHF1ZXVlW2luZGV4ZWRbeisrXV07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobC5hcHBseShzY29wZSwgYXJncykpO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBvbGRzdG9wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbCA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ6SW5kZXhcIiBpbiBsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsLnpJbmRleCA9PSBpbmRleGVkW3pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHorKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gcXVldWVbaW5kZXhlZFt6XV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAobClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2wuekluZGV4XSA9IGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3AgPSBvbGRzdG9wO1xuICAgICAgICAgICAgY3VycmVudF9ldmVudCA9IGNlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAvLyBVbmRvY3VtZW50ZWQuIERlYnVnIG9ubHkuXG4gICAgZXZlLl9ldmVudHMgPSBldmVudHM7XG4gICAgLypcXFxuICAgICAqIGV2ZS5saXN0ZW5lcnNcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHdoaWNoIGdpdmVzIHlvdSBhcnJheSBvZiBhbGwgZXZlbnQgaGFuZGxlcnMgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCBieSB0aGUgZ2l2ZW4gYG5hbWVgLlxuXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZFxuXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBldmVudCBoYW5kbGVyc1xuICAgIFxcKi9cbiAgICBldmUubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IG5hbWUgOiBuYW1lLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICBlID0gZXZlbnRzLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBqaixcbiAgICAgICAgICAgIG5lcyxcbiAgICAgICAgICAgIGVzID0gW2VdLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlID0gZXNbal0ubjtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtlW25hbWVzW2ldXSwgZVt3aWxkY2FyZF1dO1xuICAgICAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBvdXQuY29uY2F0KGl0ZW0uZiB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcyA9IG5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5zZXBhcmF0b3JcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogSWYgZm9yIHNvbWUgcmVhc29ucyB5b3UgZG9u4oCZdCBsaWtlIGRlZmF1bHQgc2VwYXJhdG9ycyAoYC5gIG9yIGAvYCkgeW91IGNhbiBzcGVjaWZ5IHlvdXJzXG4gICAgICogaGVyZS4gQmUgYXdhcmUgdGhhdCBpZiB5b3UgcGFzcyBhIHN0cmluZyBsb25nZXIgdGhhbiBvbmUgY2hhcmFjdGVyIGl0IHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgICAqIGEgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuXG4gICAgIC0gc2VwYXJhdG9yIChzdHJpbmcpIG5ldyBzZXBhcmF0b3IuIEVtcHR5IHN0cmluZyByZXNldHMgdG8gZGVmYXVsdDogYC5gIG9yIGAvYC5cbiAgICBcXCovXG4gICAgZXZlLnNlcGFyYXRvciA9IGZ1bmN0aW9uIChzZXApIHtcbiAgICAgICAgaWYgKHNlcCkge1xuICAgICAgICAgICAgc2VwID0gU3RyKHNlcCkucmVwbGFjZSgvKD89W1xcLlxcXlxcXVxcW1xcLV0pL2csIFwiXFxcXFwiKTtcbiAgICAgICAgICAgIHNlcCA9IFwiW1wiICsgc2VwICsgXCJdXCI7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSAvW1xcLlxcL10vO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCaW5kcyBnaXZlbiBldmVudCBoYW5kbGVyIHdpdGggYSBnaXZlbiBuYW1lLiBZb3UgY2FuIHVzZSB3aWxkY2FyZHMg4oCcYCpg4oCdIGZvciB0aGUgbmFtZXM6XG4gICAgIHwgZXZlLm9uKFwiKi51bmRlci4qXCIsIGYpO1xuICAgICB8IGV2ZShcIm1vdXNlLnVuZGVyLmZsb29yXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgICogVXNlIEBldmUgdG8gdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIG5hbWUgKGFycmF5KSBpZiB5b3UgZG9u4oCZdCB3YW50IHRvIHVzZSBzZXBhcmF0b3JzLCB5b3UgY2FuIHVzZSBhcnJheSBvZiBzdHJpbmdzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHJldHVybmVkIGZ1bmN0aW9uIGFjY2VwdHMgYSBzaW5nbGUgbnVtZXJpYyBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIHotaW5kZXggb2YgdGhlIGhhbmRsZXIuIEl0IGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIG9ubHkgdXNlZCB3aGVuIHlvdSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNvbWUgc3Vic2V0IG9mIGhhbmRsZXJzIHdpbGwgYmUgaW52b2tlZCBpbiBhIGdpdmVuIG9yZGVyLCBkZXNwaXRlIG9mIHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LlxuICAgICA+IEV4YW1wbGU6XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgZWF0SXQpKDIpO1xuICAgICB8IGV2ZS5vbihcIm1vdXNlXCIsIHNjcmVhbSk7XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgY2F0Y2hJdCkoMSk7XG4gICAgICogVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGBjYXRjaEl0YCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgYGVhdEl0YC5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHB1dCB5b3VyIGhhbmRsZXIgYmVmb3JlIG5vbi1pbmRleGVkIGhhbmRsZXJzLCBzcGVjaWZ5IGEgbmVnYXRpdmUgdmFsdWUuXG4gICAgICogTm90ZTogSSBhc3N1bWUgbW9zdCBvZiB0aGUgdGltZSB5b3UgZG9u4oCZdCBuZWVkIHRvIHdvcnJ5IGFib3V0IHotaW5kZXgsIGJ1dCBpdOKAmXMgbmljZSB0byBoYXZlIHRoaXMgZmVhdHVyZSDigJxqdXN0IGluIGNhc2XigJ0uXG4gICAgXFwqL1xuICAgIGV2ZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZiAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gaXNBcnJheShuYW1lWzBdKSA/IG5hbWUgOiBbbmFtZV0gOiBTdHIobmFtZSkuc3BsaXQoY29tYXNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IGlzQXJyYXkobmFtZSkgPyBuYW1lIDogU3RyKG5hbWUpLnNwbGl0KHNlcGFyYXRvciksXG4gICAgICAgICAgICAgICAgICAgIGUgPSBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgICAgICAgICAgZSA9IGUuaGFzT3duUHJvcGVydHkobmFtZXNbaV0pICYmIGVbbmFtZXNbaV1dIHx8IChlW25hbWVzW2ldXSA9IHtuOiB7fX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmYgPSBlLmYgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlLmYubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKGUuZltpXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICFleGlzdCAmJiBlLmYucHVzaChmKTtcbiAgICAgICAgICAgIH0obmFtZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHpJbmRleCkge1xuICAgICAgICAgICAgaWYgKCt6SW5kZXggPT0gK3pJbmRleCkge1xuICAgICAgICAgICAgICAgIGYuekluZGV4ID0gK3pJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuZlxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgZmlyZSBnaXZlbiBldmVudCB3aXRoIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKiBBcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgcmVzdWx0IGZ1bmN0aW9uIHdpbGwgYmUgYWxzb1xuICAgICAqIGNvbmNhdGVkIHRvIHRoZSBsaXN0IG9mIGZpbmFsIGFyZ3VtZW50cy5cbiAgICAgfCBlbC5vbmNsaWNrID0gZXZlLmYoXCJjbGlja1wiLCAxLCAyKTtcbiAgICAgfCBldmUub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICB8ICAgICBjb25zb2xlLmxvZyhhLCBiLCBjKTsgLy8gMSwgMiwgW2V2ZW50IG9iamVjdF1cbiAgICAgfCB9KTtcbiAgICAgLSBldmVudCAoc3RyaW5nKSBldmVudCBuYW1lXG4gICAgIC0gdmFyYXJncyAo4oCmKSBhbmQgYW55IG90aGVyIGFyZ3VtZW50c1xuICAgICA9IChmdW5jdGlvbikgcG9zc2libGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICBldmUuZiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUuYXBwbHkobnVsbCwgW2V2ZW50LCBudWxsXS5jb25jYXQoYXR0cnMpLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSXMgdXNlZCBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlciB0byBzdG9wIHRoZSBldmVudCwgcHJldmVudGluZyBhbnkgc3Vic2VxdWVudCBsaXN0ZW5lcnMgZnJvbSBmaXJpbmcuXG4gICAgXFwqL1xuICAgIGV2ZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wID0gMTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgIC0gc3VibmFtZSAoc3RyaW5nKSAjb3B0aW9uYWwgc3VibmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKipcbiAgICAgPSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgaWYgYHN1Ym5hbWVgIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBvclxuICAgICA9IChib29sZWFuKSBgdHJ1ZWAsIGlmIGN1cnJlbnQgZXZlbnTigJlzIG5hbWUgY29udGFpbnMgYHN1Ym5hbWVgXG4gICAgXFwqL1xuICAgIGV2ZS5udCA9IGZ1bmN0aW9uIChzdWJuYW1lKSB7XG4gICAgICAgIHZhciBjdXIgPSBpc0FycmF5KGN1cnJlbnRfZXZlbnQpID8gY3VycmVudF9ldmVudC5qb2luKFwiLlwiKSA6IGN1cnJlbnRfZXZlbnQ7XG4gICAgICAgIGlmIChzdWJuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlxcXFwufFxcXFwvfF4pXCIgKyBzdWJuYW1lICsgXCIoPzpcXFxcLnxcXFxcL3wkKVwiKS50ZXN0KGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUubnRzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDb3VsZCBiZSB1c2VkIGluc2lkZSBldmVudCBoYW5kbGVyIHRvIGZpZ3VyZSBvdXQgYWN0dWFsIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqKlxuICAgICAqKlxuICAgICA9IChhcnJheSkgbmFtZXMgb2YgdGhlIGV2ZW50XG4gICAgXFwqL1xuICAgIGV2ZS5udHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KGN1cnJlbnRfZXZlbnQpID8gY3VycmVudF9ldmVudCA6IGN1cnJlbnRfZXZlbnQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub2ZmXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIGZ1bmN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgZXZlbnQgbGlzdGVuZXJzIGFzc2lnbmVkIHRvIGdpdmVuIG5hbWUuXG4gICAgICogSWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCBhbGwgdGhlIGV2ZW50cyB3aWxsIGJlIGNsZWFyZWQuXG4gICAgICoqXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSBldmVudCwgZG90IChgLmApIG9yIHNsYXNoIChgL2ApIHNlcGFyYXRlZCwgd2l0aCBvcHRpb25hbCB3aWxkY2FyZHNcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogZXZlLnVuYmluZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBldmUub2ZmXG4gICAgXFwqL1xuICAgIGV2ZS5vZmYgPSBldmUudW5iaW5kID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBldmUuX2V2ZW50cyA9IGV2ZW50cyA9IHtuOiB7fX07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IGlzQXJyYXkobmFtZVswXSkgPyBuYW1lIDogW25hbWVdIDogU3RyKG5hbWUpLnNwbGl0KGNvbWFzZXBhcmF0b3IpO1xuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGV2ZS5vZmYobmFtZXNbaV0sIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IG5hbWUgOiBTdHIobmFtZSkuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzcGxpY2UsXG4gICAgICAgICAgICBpLCBpaSwgaiwgamosXG4gICAgICAgICAgICBjdXIgPSBbZXZlbnRzXSxcbiAgICAgICAgICAgIGlub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXIubGVuZ3RoOyBqICs9IHNwbGljZS5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlID0gW2osIDFdO1xuICAgICAgICAgICAgICAgIGUgPSBjdXJbal0ubjtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gIT0gd2lsZGNhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVbbmFtZXNbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucHVzaChlW25hbWVzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlKSBpZiAoZVtoYXNdKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5wdXNoKGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5zcGxpY2UuYXBwbHkoY3VyLCBzcGxpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gY3VyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSBjdXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoZS5uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBlLmYubGVuZ3RoOyBqIDwgamo7IGorKykgaWYgKGUuZltqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5mLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFlLmYubGVuZ3RoICYmIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZS5uKSBpZiAoZS5uW2hhc10oa2V5KSAmJiBlLm5ba2V5XS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3MgPSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBmdW5jcy5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZnVuY3Nbal0gPT0gZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jcy5sZW5ndGggJiYgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZS5mO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLm5ba2V5XS5mO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUgPSBlLm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJ1bmUgaW5uZXIgbm9kZXMgaW4gcGF0aFxuICAgICAgICBwcnVuZTogZm9yIChpID0gMCwgaWkgPSBpbm9kZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZSA9IGlub2Rlc1tpXTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGUubltlLm5hbWVdLmYpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgZW1wdHkgKGhhcyBsaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgY29udGludWUgcHJ1bmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBlLm5bZS5uYW1lXS5uKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVtcHR5IChoYXMgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY29udGludWUgcHJ1bmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpcyBlbXB0eVxuICAgICAgICAgICAgZGVsZXRlIGUubltlLm5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLm9uY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJpbmRzIGdpdmVuIGV2ZW50IGhhbmRsZXIgd2l0aCBhIGdpdmVuIG5hbWUgdG8gb25seSBydW4gb25jZSB0aGVuIHVuYmluZCBpdHNlbGYuXG4gICAgIHwgZXZlLm9uY2UoXCJsb2dpblwiLCBmKTtcbiAgICAgfCBldmUoXCJsb2dpblwiKTsgLy8gdHJpZ2dlcnMgZlxuICAgICB8IGV2ZShcImxvZ2luXCIpOyAvLyBubyBsaXN0ZW5lcnNcbiAgICAgKiBVc2UgQGV2ZSB0byB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICoqXG4gICAgID0gKGZ1bmN0aW9uKSBzYW1lIHJldHVybiBmdW5jdGlvbiBhcyBAZXZlLm9uXG4gICAgXFwqL1xuICAgIGV2ZS5vbmNlID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIGYyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlLm9mZihuYW1lLCBmMik7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXZlLm9uKG5hbWUsIGYyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUudmVyc2lvblxuICAgICBbIHByb3BlcnR5IChzdHJpbmcpIF1cbiAgICAgKipcbiAgICAgKiBDdXJyZW50IHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuXG4gICAgXFwqL1xuICAgIGV2ZS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBldmUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIllvdSBhcmUgcnVubmluZyBFdmUgXCIgKyB2ZXJzaW9uO1xuICAgIH07XG4gICAgZ2xvYi5ldmUgPSBldmU7XG4gICAgdHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBldmUgOiB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcImV2ZVwiLCBbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlOyB9KSA6IGdsb2IuZXZlID0gZXZlO1xufSkodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcyk7XG4iLCJ3aW5kb3cuZXZlID0gcmVxdWlyZSgnZXZlJylcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIG1pbmEgPSAoZnVuY3Rpb24gKGV2ZSkge1xuICAgIHZhciBhbmltYXRpb25zID0ge30sXG4gICAgcmVxdWVzdEFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE2LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICByZXF1ZXN0SUQsXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9LFxuICAgIGlkZ2VuID0gMCxcbiAgICBpZHByZWZpeCA9IFwiTVwiICsgKCtuZXcgRGF0ZSkudG9TdHJpbmcoMzYpLFxuICAgIElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgZGlmZiA9IGZ1bmN0aW9uIChhLCBiLCBBLCBCKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGEpKSB7XG4gICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGRpZmYoYVtpXSwgYiwgQVtpXSwgQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWYgPSAoQSAtIGEpIC8gKEIgLSBiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBkaWYgKiAoYmIgLSBiKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRpbWVyID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH0sXG4gICAgc3RhID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEucztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHMgPSBhLnMgLSB2YWw7XG4gICAgICAgIGEuYiArPSBhLmR1ciAqIGRzO1xuICAgICAgICBhLkIgKz0gYS5kdXIgKiBkcztcbiAgICAgICAgYS5zID0gdmFsO1xuICAgIH0sXG4gICAgc3BlZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zcGQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5zcGQgPSB2YWw7XG4gICAgfSxcbiAgICBkdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmR1cjtcbiAgICAgICAgfVxuICAgICAgICBhLnMgPSBhLnMgKiB2YWwgLyBhLmR1cjtcbiAgICAgICAgYS5kdXIgPSB2YWw7XG4gICAgfSxcbiAgICBzdG9waXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgZGVsZXRlIGFuaW1hdGlvbnNbYS5pZF07XG4gICAgICAgIGEudXBkYXRlKCk7XG4gICAgICAgIGV2ZShcIm1pbmEuc3RvcC5cIiArIGEuaWQsIGEpO1xuICAgIH0sXG4gICAgcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKGEucGRpZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2EuaWRdO1xuICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICBhLnBkaWYgPSBhLmdldCgpIC0gYS5iO1xuICAgIH0sXG4gICAgcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICghYS5wZGlmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYS5iID0gYS5nZXQoKSAtIGEucGRpZjtcbiAgICAgICAgZGVsZXRlIGEucGRpZjtcbiAgICAgICAgYW5pbWF0aW9uc1thLmlkXSA9IGE7XG4gICAgICAgIGZyYW1lKCk7XG4gICAgfSxcbiAgICB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIHJlcztcbiAgICAgICAgaWYgKGlzQXJyYXkoYS5zdGFydCkpIHtcbiAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gYS5zdGFydC5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2pdID0gK2Euc3RhcnRbal0gK1xuICAgICAgICAgICAgICAgICAgICAoYS5lbmRbal0gLSBhLnN0YXJ0W2pdKSAqIGEuZWFzaW5nKGEucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSArYS5zdGFydCArIChhLmVuZCAtIGEuc3RhcnQpICogYS5lYXNpbmcoYS5zKTtcbiAgICAgICAgfVxuICAgICAgICBhLnNldChyZXMpO1xuICAgIH0sXG4gICAgZnJhbWUgPSBmdW5jdGlvbiAodGltZVN0YW1wKSB7XG4gICAgICAgIC8vIE1hbnVhbCBpbnZva2F0aW9uP1xuICAgICAgICBpZiAoIXRpbWVTdGFtcCkge1xuICAgICAgICAgICAgLy8gRnJhbWUgbG9vcCBzdG9wcGVkP1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0SUQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmcmFtZSBsb29wLi4uXG4gICAgICAgICAgICAgICAgcmVxdWVzdElEID0gcmVxdWVzdEFuaW1GcmFtZShmcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYW5pbWF0aW9ucykgaWYgKGFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gYW5pbWF0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICBiID0gYS5nZXQoKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGEucyA9IChiIC0gYS5iKSAvIChhLmR1ciAvIGEuc3BkKTtcbiAgICAgICAgICAgIGlmIChhLnMgPj0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGEucyA9IDE7XG4gICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwibWluYS5maW5pc2guXCIgKyBhLmlkLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RJRCA9IGxlbiA/IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUpIDogZmFsc2U7XG4gICAgfSxcbiAgICAvKlxcXG4gICAgICogbWluYVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2VuZXJpYyBhbmltYXRpb24gb2YgbnVtYmVyc1xuICAgICAqKlxuICAgICAtIGEgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBBIChudW1iZXIpIGVuZCBfc2xhdmVfIG51bWJlclxuICAgICAtIGIgKG51bWJlcikgc3RhcnQgX21hc3Rlcl8gbnVtYmVyIChzdGFydCB0aW1lIGluIGdlbmVyYWwgY2FzZSlcbiAgICAgLSBCIChudW1iZXIpIGVuZCBfbWFzdGVyXyBudW1iZXIgKGVuZCB0aW1lIGluIGdlbmVyYWwgY2FzZSlcbiAgICAgLSBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSlcbiAgICAgLSBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0IGlzIEBtaW5hLmxpbmVhclxuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBkZXNjcmlwdG9yXG4gICAgIG8ge1xuICAgICBvICAgICAgICAgaWQgKHN0cmluZykgYW5pbWF0aW9uIGlkLFxuICAgICBvICAgICAgICAgc3RhcnQgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlbmQgKG51bWJlcikgZW5kIF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgYiAobnVtYmVyKSBzdGFydCBfbWFzdGVyXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBzIChudW1iZXIpIGFuaW1hdGlvbiBzdGF0dXMgKDAuLjEpLFxuICAgICBvICAgICAgICAgZHVyIChudW1iZXIpIGFuaW1hdGlvbiBkdXJhdGlvbixcbiAgICAgbyAgICAgICAgIHNwZCAobnVtYmVyKSBhbmltYXRpb24gc3BlZWQsXG4gICAgIG8gICAgICAgICBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSksXG4gICAgIG8gICAgICAgICBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlYXNpbmcgKGZ1bmN0aW9uKSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHQgaXMgQG1pbmEubGluZWFyLFxuICAgICBvICAgICAgICAgc3RhdHVzIChmdW5jdGlvbikgc3RhdHVzIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzcGVlZCAoZnVuY3Rpb24pIHNwZWVkIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGR1cmF0aW9uIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzdG9wIChmdW5jdGlvbikgYW5pbWF0aW9uIHN0b3BwZXJcbiAgICAgbyAgICAgICAgIHBhdXNlIChmdW5jdGlvbikgcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgICAgbyAgICAgICAgIHJlc3VtZSAoZnVuY3Rpb24pIHJlc3VtZXMgdGhlIGFuaW1hdGlvblxuICAgICBvICAgICAgICAgdXBkYXRlIChmdW5jdGlvbikgY2FsbGVzIHNldHRlciB3aXRoIHRoZSByaWdodCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBtaW5hID0gZnVuY3Rpb24gKGEsIEEsIGIsIEIsIGdldCwgc2V0LCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB7XG4gICAgICAgICAgICBpZDogSUQoKSxcbiAgICAgICAgICAgIHN0YXJ0OiBhLFxuICAgICAgICAgICAgZW5kOiBBLFxuICAgICAgICAgICAgYjogYixcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICBkdXI6IEIgLSBiLFxuICAgICAgICAgICAgc3BkOiAxLFxuICAgICAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nIHx8IG1pbmEubGluZWFyLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGEsXG4gICAgICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBzdG9wOiBzdG9waXQsXG4gICAgICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgICAgICByZXN1bWU6IHJlc3VtZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGlvbnNbYW5pbS5pZF0gPSBhbmltO1xuICAgICAgICB2YXIgbGVuID0gMCwgaTtcbiAgICAgICAgZm9yIChpIGluIGFuaW1hdGlvbnMpIGlmIChhbmltYXRpb25zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9PSAxICYmIGZyYW1lKCk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEudGltZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLiBFcXVpdmFsZW50IHRvOlxuICAgICB8IGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuICAgICB8IH1cbiAgICBcXCovXG4gICAgbWluYS50aW1lID0gdGltZXI7XG4gICAgLypcXFxuICAgICAqIG1pbmEuZ2V0QnlJZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBhbmltYXRpb24gYnkgaXRzIGlkXG4gICAgIC0gaWQgKHN0cmluZykgYW5pbWF0aW9uJ3MgaWRcbiAgICAgPSAob2JqZWN0KSBTZWUgQG1pbmFcbiAgICBcXCovXG4gICAgbWluYS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2lkXSB8fCBudWxsO1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogbWluYS5saW5lYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERlZmF1bHQgbGluZWFyIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEubGluZWFyID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lYXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlb3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZW91dCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhuLCAxLjcpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWFzZWluXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlaW4gZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lYXNlaW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobiwgLjQ4KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVhc2Vpbm91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZWlub3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZWlub3V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHEgPSAuNDggLSBuIC8gMS4wNCxcbiAgICAgICAgICAgIFEgPSBNYXRoLnNxcnQoLjE3MzQgKyBxICogcSksXG4gICAgICAgICAgICB4ID0gUSAtIHEsXG4gICAgICAgICAgICBYID0gTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKSAqICh4IDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgICB5ID0gLVEgLSBxLFxuICAgICAgICAgICAgWSA9IE1hdGgucG93KE1hdGguYWJzKHkpLCAxIC8gMykgKiAoeSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgICAgdCA9IFggKyBZICsgLjU7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogMyAqIHQgKiB0ICsgdCAqIHQgKiB0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYmFja2luXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCYWNraW4gZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5iYWNraW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBuICogbiAqICgocyArIDEpICogbiAtIHMpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYmFja291dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmFja291dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJhY2tvdXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBuID0gbiAtIDE7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIG4gKiBuICogKChzICsgMSkgKiBuICsgcykgKyAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWxhc3RpY1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWxhc3RpYyBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVsYXN0aWMgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAhIW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBuKSAqIE1hdGguc2luKChuIC0gLjA3NSkgKlxuICAgICAgICAgICAgKDIgKiBNYXRoLlBJKSAvIC4zKSArIDE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5ib3VuY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJvdW5jZSBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJvdW5jZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBzID0gNy41NjI1LFxuICAgICAgICAgICAgcCA9IDIuNzUsXG4gICAgICAgICAgICBsO1xuICAgICAgICBpZiAobiA8IDEgLyBwKSB7XG4gICAgICAgICAgICBsID0gcyAqIG4gKiBuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4gPCAyIC8gcCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMS41IC8gcDtcbiAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjc1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8IDIuNSAvIHApIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAyLjI1IC8gcDtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45Mzc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gMi42MjUgLyBwO1xuICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjk4NDM3NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfTtcbiAgICB3aW5kb3cubWluYSA9IG1pbmE7XG4gICAgcmV0dXJuIG1pbmE7XG59KSh0eXBlb2YgZXZlID09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbiAoKSB7fSA6IGV2ZSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyAtIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbnZhciBTbmFwID0gKGZ1bmN0aW9uKHJvb3QpIHtcblNuYXAudmVyc2lvbiA9IFwiMC41LjFcIjtcbi8qXFxcbiAqIFNuYXBcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBkcmF3aW5nIHN1cmZhY2Ugb3Igd3JhcHMgZXhpc3RpbmcgU1ZHIGVsZW1lbnQuXG4gKipcbiAtIHdpZHRoIChudW1iZXJ8c3RyaW5nKSB3aWR0aCBvZiBzdXJmYWNlXG4gLSBoZWlnaHQgKG51bWJlcnxzdHJpbmcpIGhlaWdodCBvZiBzdXJmYWNlXG4gKiBvclxuIC0gRE9NIChTVkdFbGVtZW50KSBlbGVtZW50IHRvIGJlIHdyYXBwZWQgaW50byBTbmFwIHN0cnVjdHVyZVxuICogb3JcbiAtIGFycmF5IChhcnJheSkgYXJyYXkgb2YgZWxlbWVudHMgKHdpbGwgcmV0dXJuIHNldCBvZiBlbGVtZW50cylcbiAqIG9yXG4gLSBxdWVyeSAoc3RyaW5nKSBDU1MgcXVlcnkgc2VsZWN0b3JcbiA9IChvYmplY3QpIEBFbGVtZW50XG5cXCovXG5mdW5jdGlvbiBTbmFwKHcsIGgpIHtcbiAgICBpZiAodykge1xuICAgICAgICBpZiAody5ub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHcsIFwiYXJyYXlcIikgJiYgU25hcC5zZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLnNldC5hcHBseShTbmFwLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdyA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IoU3RyaW5nKHcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcCh3KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB3ID0gdyA9PSBudWxsID8gXCIxMDAlXCIgOiB3O1xuICAgIGggPSBoID09IG51bGwgPyBcIjEwMCVcIiA6IGg7XG4gICAgcmV0dXJuIG5ldyBQYXBlcih3LCBoKTtcbn1cblNuYXAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiU25hcCB2XCIgKyB0aGlzLnZlcnNpb247XG59O1xuU25hcC5fID0ge307XG52YXIgZ2xvYiA9IHtcbiAgICB3aW46IHJvb3Qud2luZG93LFxuICAgIGRvYzogcm9vdC53aW5kb3cuZG9jdW1lbnRcbn07XG5TbmFwLl8uZ2xvYiA9IGdsb2I7XG52YXIgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIFN0ciA9IFN0cmluZyxcbiAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICB0b0ludCA9IHBhcnNlSW50LFxuICAgIG1hdGggPSBNYXRoLFxuICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICBtbWluID0gbWF0aC5taW4sXG4gICAgYWJzID0gbWF0aC5hYnMsXG4gICAgcG93ID0gbWF0aC5wb3csXG4gICAgUEkgPSBtYXRoLlBJLFxuICAgIHJvdW5kID0gbWF0aC5yb3VuZCxcbiAgICBFID0gXCJcIixcbiAgICBTID0gXCIgXCIsXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIElTVVJMID0gL151cmxcXChbJ1wiXT8oW15cXCldKz8pWydcIl0/XFwpJC9pLFxuICAgIGNvbG91clJlZ0V4cCA9IC9eXFxzKigoI1thLWZcXGRdezZ9KXwoI1thLWZcXGRdezN9KXxyZ2JhP1xcKFxccyooW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/KD86XFxzKixcXHMqW1xcZFxcLl0rJT8pPylcXHMqXFwpfGhzYmE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/JT8pXFxzKlxcKXxoc2xhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyU/KVxccypcXCkpXFxzKiQvaSxcbiAgICBiZXppZXJyZyA9IC9eKD86Y3ViaWMtKT9iZXppZXJcXCgoW14sXSspLChbXixdKyksKFteLF0rKSwoW15cXCldKylcXCkvLFxuICAgIHNlcGFyYXRvciA9IFNuYXAuXy5zZXBhcmF0b3IgPSAvWyxcXHNdKy8sXG4gICAgd2hpdGVzcGFjZSA9IC9bXFxzXS9nLFxuICAgIGNvbW1hU3BhY2VzID0gL1tcXHNdKixbXFxzXSovLFxuICAgIGhzcmcgPSB7aHM6IDEsIHJnOiAxfSxcbiAgICBwYXRoQ29tbWFuZCA9IC8oW2Etel0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHRDb21tYW5kID0gLyhbcnN0bV0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pW1xcc10qLD9bXFxzXSovaWcsXG4gICAgaWRnZW4gPSAwLFxuICAgIGlkcHJlZml4ID0gXCJTXCIgKyAoK25ldyBEYXRlKS50b1N0cmluZygzNiksXG4gICAgSUQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIChlbCAmJiBlbC50eXBlID8gZWwudHlwZSA6IEUpICsgaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgeGxpbmsgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWxucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBodWIgPSB7fSxcbiAgICAvKlxcXG4gICAgICogU25hcC51cmxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFdyYXBzIHBhdGggaW50byBgXCJ1cmwoJzxwYXRoPicpXCJgLlxuICAgICAtIHZhbHVlIChzdHJpbmcpIHBhdGhcbiAgICAgPSAoc3RyaW5nKSB3cmFwcGVkIHBhdGhcbiAgICBcXCovXG4gICAgVVJMID0gU25hcC51cmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBcInVybCgnI1wiICsgdXJsICsgXCInKVwiO1xuICAgIH07XG5cbmZ1bmN0aW9uICQoZWwsIGF0dHIpIHtcbiAgICBpZiAoYXR0cikge1xuICAgICAgICBpZiAoZWwgPT0gXCIjdGV4dFwiKSB7XG4gICAgICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZVRleHROb2RlKGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09IFwiI2NvbW1lbnRcIikge1xuICAgICAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVDb21tZW50KGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbCA9ICQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCA2KSA9PSBcInhsaW5rOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGVOUyh4bGluaywgYXR0ci5zdWJzdHJpbmcoNikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZU5TKHhtbG5zLCBhdHRyLnN1YnN0cmluZyg0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHIpIGlmIChhdHRyW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBTdHIoYXR0cltrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDYpID09IFwieGxpbms6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBrZXkuc3Vic3RyaW5nKDYpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCBrZXkuc3Vic3RyaW5nKDQpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInRleHRcIiBpbiBhdHRyKSB7XG4gICAgICAgICAgICBlbC5ub2RlVmFsdWUgPSBhdHRyLnRleHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxucywgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5TbmFwLl8uJCA9ICQ7XG5TbmFwLl8uaWQgPSBJRDtcbmZ1bmN0aW9uIGdldEF0dHJzKGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3V0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZXNwYWNlVVJJID09IHhsaW5rKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJ4bGluazpcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgKz0gYXR0cnNbaV0ubmFtZTtcbiAgICAgICAgb3V0W25hbWVdID0gYXR0cnNbaV0udGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpcyhvLCB0eXBlKSB7XG4gICAgdHlwZSA9IFN0ci5wcm90b3R5cGUudG9Mb3dlckNhc2UuY2FsbCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShvKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiICYmXG4gICAgICAgIChvIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICB0eXBlID09IFwibnVsbFwiICYmIG8gPT09IG51bGwgfHxcbiAgICAgICAgICAgIHR5cGUgPT0gdHlwZW9mIG8gJiYgbyAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZSA9PSBcIm9iamVjdFwiICYmIG8gPT09IE9iamVjdChvKSB8fFxuICAgICAgICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xufVxuLypcXFxuICogU25hcC5mb3JtYXRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJlcGxhY2VzIGNvbnN0cnVjdGlvbiBvZiB0eXBlIGB7PG5hbWU+fWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnRcbiAqKlxuIC0gdG9rZW4gKHN0cmluZykgc3RyaW5nIHRvIGZvcm1hdFxuIC0ganNvbiAob2JqZWN0KSBvYmplY3Qgd2hpY2ggcHJvcGVydGllcyBhcmUgdXNlZCBhcyBhIHJlcGxhY2VtZW50XG4gPSAoc3RyaW5nKSBmb3JtYXR0ZWQgc3RyaW5nXG4gPiBVc2FnZVxuIHwgLy8gdGhpcyBkcmF3cyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gfCBwYXBlci5wYXRoKFNuYXAuZm9ybWF0KFwiTXt4fSx7eX1oe2RpbS53aWR0aH12e2RpbS5oZWlnaHR9aHtkaW1bJ25lZ2F0aXZlIHdpZHRoJ119elwiLCB7XG4gfCAgICAgeDogMTAsXG4gfCAgICAgeTogMjAsXG4gfCAgICAgZGltOiB7XG4gfCAgICAgICAgIHdpZHRoOiA0MCxcbiB8ICAgICAgICAgaGVpZ2h0OiA1MCxcbiB8ICAgICAgICAgXCJuZWdhdGl2ZSB3aWR0aFwiOiAtNDBcbiB8ICAgICB9XG4gfCB9KSk7XG5cXCovXG5TbmFwLmZvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFteXFx9XSspXFx9L2csXG4gICAgICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZywgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoYWxsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9iajtcbiAgICAgICAgICAgIGtleS5yZXBsYWNlKG9iak5vdGF0aW9uUmVnZXgsIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcyA9PSBcImZ1bmN0aW9uXCIgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMgPSAocmVzID09IG51bGwgfHwgcmVzID09IG9iaiA/IGFsbCA6IHJlcykgKyBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgb2JqKSB7XG4gICAgICAgIHJldHVybiBTdHIoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uIChhbGwsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09IFwiZnVuY3Rpb25cIiB8fCBPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChvYmpbaGFzXShrZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuU25hcC5fLmNsb25lID0gY2xvbmU7XG5mdW5jdGlvbiByZXB1c2goYXJyYXksIGl0ZW0pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWNoZXIoZiwgc2NvcGUsIHBvc3Rwcm9jZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBuZXdmKCkge1xuICAgICAgICB2YXIgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmcuam9pbihcIlxcdTI0MDBcIiksXG4gICAgICAgICAgICBjYWNoZSA9IG5ld2YuY2FjaGUgPSBuZXdmLmNhY2hlIHx8IHt9LFxuICAgICAgICAgICAgY291bnQgPSBuZXdmLmNvdW50ID0gbmV3Zi5jb3VudCB8fCBbXTtcbiAgICAgICAgaWYgKGNhY2hlW2hhc10oYXJncykpIHtcbiAgICAgICAgICAgIHJlcHVzaChjb3VudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcG9zdHByb2Nlc3NvciA/IHBvc3Rwcm9jZXNzb3IoY2FjaGVbYXJnc10pIDogY2FjaGVbYXJnc107XG4gICAgICAgIH1cbiAgICAgICAgY291bnQubGVuZ3RoID49IDFlMyAmJiBkZWxldGUgY2FjaGVbY291bnQuc2hpZnQoKV07XG4gICAgICAgIGNvdW50LnB1c2goYXJncyk7XG4gICAgICAgIGNhY2hlW2FyZ3NdID0gZi5hcHBseShzY29wZSwgYXJnKTtcbiAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Zjtcbn1cblNuYXAuXy5jYWNoZXIgPSBjYWNoZXI7XG5mdW5jdGlvbiBhbmdsZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgaWYgKHgzID09IG51bGwpIHtcbiAgICAgICAgdmFyIHggPSB4MSAtIHgyLFxuICAgICAgICAgICAgeSA9IHkxIC0geTI7XG4gICAgICAgIGlmICgheCAmJiAheSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgxODAgKyBtYXRoLmF0YW4yKC15LCAteCkgKiAxODAgLyBQSSArIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlKHgxLCB5MSwgeDMsIHkzKSAtIGFuZ2xlKHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByYWQoZGVnKSB7XG4gICAgcmV0dXJuIGRlZyAlIDM2MCAqIFBJIC8gMTgwO1xufVxuZnVuY3Rpb24gZGVnKHJhZCkge1xuICAgIHJldHVybiByYWQgKiAxODAgLyBQSSAlIDM2MDtcbn1cbmZ1bmN0aW9uIHhfeSgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgUyArIHRoaXMueTtcbn1cbmZ1bmN0aW9uIHhfeV93X2goKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnkgKyBTICsgdGhpcy53aWR0aCArIFwiIFxceGQ3IFwiICsgdGhpcy5oZWlnaHQ7XG59XG5cbi8qXFxcbiAqIFNuYXAucmFkXG4gWyBtZXRob2QgXVxuICoqXG4gKiBUcmFuc2Zvcm0gYW5nbGUgdG8gcmFkaWFuc1xuIC0gZGVnIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcblxcKi9cblNuYXAucmFkID0gcmFkO1xuLypcXFxuICogU25hcC5kZWdcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFRyYW5zZm9ybSBhbmdsZSB0byBkZWdyZWVzXG4gLSByYWQgKG51bWJlcikgYW5nbGUgaW4gcmFkaWFuc1xuID0gKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5kZWcgPSBkZWc7XG4vKlxcXG4gKiBTbmFwLnNpblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5zaW4oKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gYW5nbGUgKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuID0gKG51bWJlcikgc2luXG5cXCovXG5TbmFwLnNpbiA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIHJldHVybiBtYXRoLnNpbihTbmFwLnJhZChhbmdsZSkpO1xufTtcbi8qXFxcbiAqIFNuYXAudGFuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLnRhbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSB0YW5cblxcKi9cblNuYXAudGFuID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgcmV0dXJuIG1hdGgudGFuKFNuYXAucmFkKGFuZ2xlKSk7XG59O1xuLypcXFxuICogU25hcC5jb3NcbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguY29zKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIGFuZ2xlIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGNvc1xuXFwqL1xuU25hcC5jb3MgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICByZXR1cm4gbWF0aC5jb3MoU25hcC5yYWQoYW5nbGUpKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFzaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguYXNpbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBudW0gKG51bWJlcikgdmFsdWVcbiA9IChudW1iZXIpIGFzaW4gaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hc2luID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBTbmFwLmRlZyhtYXRoLmFzaW4obnVtKSk7XG59O1xuLypcXFxuICogU25hcC5hY29zXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmFjb3MoKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gbnVtIChudW1iZXIpIHZhbHVlXG4gPSAobnVtYmVyKSBhY29zIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYWNvcyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hY29zKG51bSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuYXRhblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5hdGFuKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbiBpbiBkZWdyZWVzXG5cXCovXG5TbmFwLmF0YW4gPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIFNuYXAuZGVnKG1hdGguYXRhbihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmF0YW4yXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmF0YW4yKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbjIgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hdGFuMiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hdGFuMihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFuZ2xlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gdHdvIG9yIHRocmVlIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB4MyAobnVtYmVyKSAjb3B0aW9uYWwgeCBjb29yZCBvZiB0aGlyZCBwb2ludFxuIC0geTMgKG51bWJlcikgI29wdGlvbmFsIHkgY29vcmQgb2YgdGhpcmQgcG9pbnRcbiA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYW5nbGUgPSBhbmdsZTtcbi8qXFxcbiAqIFNuYXAubGVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFNuYXAubGVuMih4MSwgeTEsIHgyLCB5MikpO1xufTtcbi8qXFxcbiAqIFNuYXAubGVuMlxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4yID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKTtcbn07XG4vKlxcXG4gKiBTbmFwLmNsb3Nlc3RQb2ludFxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBjbG9zZXN0IHBvaW50IHRvIGEgZ2l2ZW4gb25lIG9uIGEgZ2l2ZW4gcGF0aC5cbiAtIHBhdGggKEVsZW1lbnQpIHBhdGggZWxlbWVudFxuIC0geCAobnVtYmVyKSB4IGNvb3JkIG9mIGEgcG9pbnRcbiAtIHkgKG51bWJlcikgeSBjb29yZCBvZiBhIHBvaW50XG4gPSAob2JqZWN0KSBpbiBmb3JtYXRcbiB7XG4gICAgeCAobnVtYmVyKSB4IGNvb3JkIG9mIHRoZSBwb2ludCBvbiB0aGUgcGF0aFxuICAgIHkgKG51bWJlcikgeSBjb29yZCBvZiB0aGUgcG9pbnQgb24gdGhlIHBhdGhcbiAgICBsZW5ndGggKG51bWJlcikgbGVuZ3RoIG9mIHRoZSBwYXRoIHRvIHRoZSBwb2ludFxuICAgIGRpc3RhbmNlIChudW1iZXIpIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBwYXRoXG4gfVxuXFwqL1xuLy8gQ29waWVkIGZyb20gaHR0cDovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzgwMjc2MzdcblNuYXAuY2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gKHBhdGgsIHgsIHkpIHtcbiAgICBmdW5jdGlvbiBkaXN0YW5jZTIocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB5O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIHZhciBwYXRoTm9kZSA9IHBhdGgubm9kZSxcbiAgICAgICAgcGF0aExlbmd0aCA9IHBhdGhOb2RlLmdldFRvdGFsTGVuZ3RoKCksXG4gICAgICAgIHByZWNpc2lvbiA9IHBhdGhMZW5ndGggLyBwYXRoTm9kZS5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zICogLjEyNSxcbiAgICAgICAgYmVzdCxcbiAgICAgICAgYmVzdExlbmd0aCxcbiAgICAgICAgYmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAvLyBsaW5lYXIgc2NhbiBmb3IgY29hcnNlIGFwcHJveGltYXRpb25cbiAgICBmb3IgKHZhciBzY2FuLCBzY2FuTGVuZ3RoID0gMCwgc2NhbkRpc3RhbmNlOyBzY2FuTGVuZ3RoIDw9IHBhdGhMZW5ndGg7IHNjYW5MZW5ndGggKz0gcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmICgoc2NhbkRpc3RhbmNlID0gZGlzdGFuY2UyKHNjYW4gPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKHNjYW5MZW5ndGgpKSkgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGJlc3QgPSBzY2FuO1xuICAgICAgICAgICAgYmVzdExlbmd0aCA9IHNjYW5MZW5ndGg7XG4gICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBzY2FuRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiaW5hcnkgc2VhcmNoIGZvciBwcmVjaXNlIGVzdGltYXRlXG4gICAgcHJlY2lzaW9uICo9IC41O1xuICAgIHdoaWxlIChwcmVjaXNpb24gPiAuNSkge1xuICAgICAgICB2YXIgYmVmb3JlLFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICBiZWZvcmVMZW5ndGgsXG4gICAgICAgICAgICBhZnRlckxlbmd0aCxcbiAgICAgICAgICAgIGJlZm9yZURpc3RhbmNlLFxuICAgICAgICAgICAgYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgaWYgKChiZWZvcmVMZW5ndGggPSBiZXN0TGVuZ3RoIC0gcHJlY2lzaW9uKSA+PSAwICYmIChiZWZvcmVEaXN0YW5jZSA9IGRpc3RhbmNlMihiZWZvcmUgPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKGJlZm9yZUxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGJlZm9yZTtcbiAgICAgICAgICAgIGJlc3RMZW5ndGggPSBiZWZvcmVMZW5ndGg7XG4gICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBiZWZvcmVEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmICgoYWZ0ZXJMZW5ndGggPSBiZXN0TGVuZ3RoICsgcHJlY2lzaW9uKSA8PSBwYXRoTGVuZ3RoICYmIChhZnRlckRpc3RhbmNlID0gZGlzdGFuY2UyKGFmdGVyID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChhZnRlckxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGFmdGVyO1xuICAgICAgICAgICAgYmVzdExlbmd0aCA9IGFmdGVyTGVuZ3RoO1xuICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiAqPSAuNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlc3QgPSB7XG4gICAgICAgIHg6IGJlc3QueCxcbiAgICAgICAgeTogYmVzdC55LFxuICAgICAgICBsZW5ndGg6IGJlc3RMZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoYmVzdERpc3RhbmNlKVxuICAgIH07XG4gICAgcmV0dXJuIGJlc3Q7XG59XG4vKlxcXG4gKiBTbmFwLmlzXG4gWyBtZXRob2QgXVxuICoqXG4gKiBIYW5keSByZXBsYWNlbWVudCBmb3IgdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gLSBvICjigKYpIGFueSBvYmplY3Qgb3IgcHJpbWl0aXZlXG4gLSB0eXBlIChzdHJpbmcpIG5hbWUgb2YgdGhlIHR5cGUsIGUuZy4sIGBzdHJpbmdgLCBgZnVuY3Rpb25gLCBgbnVtYmVyYCwgZXRjLlxuID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBnaXZlbiB2YWx1ZSBpcyBvZiBnaXZlbiB0eXBlXG5cXCovXG5TbmFwLmlzID0gaXM7XG4vKlxcXG4gKiBTbmFwLnNuYXBUb1xuIFsgbWV0aG9kIF1cbiAqKlxuICogU25hcHMgZ2l2ZW4gdmFsdWUgdG8gZ2l2ZW4gZ3JpZFxuIC0gdmFsdWVzIChhcnJheXxudW1iZXIpIGdpdmVuIGFycmF5IG9mIHZhbHVlcyBvciBzdGVwIG9mIHRoZSBncmlkXG4gLSB2YWx1ZSAobnVtYmVyKSB2YWx1ZSB0byBhZGp1c3RcbiAtIHRvbGVyYW5jZSAobnVtYmVyKSAjb3B0aW9uYWwgbWF4aW11bSBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0IHZhbHVlIHRoYXQgd291bGQgdHJpZ2dlciB0aGUgc25hcC4gRGVmYXVsdCBpcyBgMTBgLlxuID0gKG51bWJlcikgYWRqdXN0ZWQgdmFsdWVcblxcKi9cblNuYXAuc25hcFRvID0gZnVuY3Rpb24gKHZhbHVlcywgdmFsdWUsIHRvbGVyYW5jZSkge1xuICAgIHRvbGVyYW5jZSA9IGlzKHRvbGVyYW5jZSwgXCJmaW5pdGVcIikgPyB0b2xlcmFuY2UgOiAxMDtcbiAgICBpZiAoaXModmFsdWVzLCBcImFycmF5XCIpKSB7XG4gICAgICAgIHZhciBpID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgaWYgKGFicyh2YWx1ZXNbaV0gLSB2YWx1ZSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzID0gK3ZhbHVlcztcbiAgICAgICAgdmFyIHJlbSA9IHZhbHVlICUgdmFsdWVzO1xuICAgICAgICBpZiAocmVtIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSByZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbSA+IHZhbHVlcyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtICsgdmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vLyBDb2xvdXJcbi8qXFxcbiAqIFNuYXAuZ2V0UkdCXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgY29sb3Igc3RyaW5nIGFzIFJHQiBvYmplY3RcbiAtIGNvbG9yIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICMgPHVsPlxuICMgICAgIDxsaT5Db2xvciBuYW1lICg8Y29kZT5yZWQ8L2NvZGU+LCA8Y29kZT5ncmVlbjwvY29kZT4sIDxjb2RlPmNvcm5mbG93ZXJibHVlPC9jb2RlPiwgZXRjKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKIg4oCUIHNob3J0ZW5lZCBIVE1MIGNvbG9yOiAoPGNvZGU+IzAwMDwvY29kZT4sIDxjb2RlPiNmYzA8L2NvZGU+LCBldGMuKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKLigKLigKLigKIg4oCUIGZ1bGwgbGVuZ3RoIEhUTUwgY29sb3I6ICg8Y29kZT4jMDAwMDAwPC9jb2RlPiwgPGNvZGU+I2JkMjMwMDwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzIHZhbHVlczogKDxjb2RlPnJnYigyMDAsJm5ic3A7MTAwLCZuYnNwOzApPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTogKDxjb2RlPnJnYigxMDAlLCZuYnNwOzE3NSUsJm5ic3A7MCUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBicmlnaHRuZXNzIHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDsxKTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+aHNiYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU8L2xpPlxuICMgICAgIDxsaT5oc2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzbCjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBsdW1pbm9zaXR5IHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDswLjUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5oc2xhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNsKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gIyAgICAgPGxpPmhzbGEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjIDwvdWw+XG4gKiBOb3RlIHRoYXQgYCVgIGNhbiBiZSB1c2VkIGFueSB0aW1lOiBgcmdiKDIwJSwgMjU1LCA1MCUpYC5cbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiBvICAgICBlcnJvciAoYm9vbGVhbikgdHJ1ZSBpZiBzdHJpbmcgY2FuJ3QgYmUgcGFyc2VkXG4gbyB9XG5cXCovXG5TbmFwLmdldFJHQiA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3VyKSB7XG4gICAgaWYgKCFjb2xvdXIgfHwgISEoKGNvbG91ciA9IFN0cihjb2xvdXIpKS5pbmRleE9mKFwiLVwiKSArIDEpKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIGlmIChjb2xvdXIgPT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgIH1cbiAgICAhKGhzcmdbaGFzXShjb2xvdXIudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMCwgMikpIHx8IGNvbG91ci5jaGFyQXQoKSA9PSBcIiNcIikgJiYgKGNvbG91ciA9IHRvSGV4KGNvbG91cikpO1xuICAgIGlmICghY29sb3VyKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIHZhciByZXMsXG4gICAgICAgIHJlZCxcbiAgICAgICAgZ3JlZW4sXG4gICAgICAgIGJsdWUsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHQsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgcmdiID0gY29sb3VyLm1hdGNoKGNvbG91clJlZ0V4cCk7XG4gICAgaWYgKHJnYikge1xuICAgICAgICBpZiAocmdiWzJdKSB7XG4gICAgICAgICAgICBibHVlID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZyg1KSwgMTYpO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDEsIDMpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYlszXSkge1xuICAgICAgICAgICAgYmx1ZSA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgzKSkgKyB0LCAxNik7XG4gICAgICAgICAgICBncmVlbiA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgyKSkgKyB0LCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMSkpICsgdCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNF0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls0XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgKj0gMi41NSk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcInJnYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNV0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls1XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgLz0gMTAwKTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gLz0gMTAwKTtcbiAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlIC89IDEwMCk7XG4gICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuaHNiMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzZdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNl0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gdG9GbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkIC89IDEwMCk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuIC89IDEwMCk7XG4gICAgICAgICAgICBibHVlID0gdG9GbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAvPSAxMDApO1xuICAgICAgICAgICAgKHZhbHVlc1swXS5zbGljZSgtMykgPT0gXCJkZWdcIiB8fCB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiXFx4YjBcIikgJiYgKHJlZCAvPSAzNjApO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2xhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLmhzbDJyZ2IocmVkLCBncmVlbiwgYmx1ZSwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkID0gbW1pbihtYXRoLnJvdW5kKHJlZCksIDI1NSk7XG4gICAgICAgIGdyZWVuID0gbW1pbihtYXRoLnJvdW5kKGdyZWVuKSwgMjU1KTtcbiAgICAgICAgYmx1ZSA9IG1taW4obWF0aC5yb3VuZChibHVlKSwgMjU1KTtcbiAgICAgICAgb3BhY2l0eSA9IG1taW4obW1heChvcGFjaXR5LCAwKSwgMSk7XG4gICAgICAgIHJnYiA9IHtyOiByZWQsIGc6IGdyZWVuLCBiOiBibHVlLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgICAgICByZ2IuaGV4ID0gXCIjXCIgKyAoMTY3NzcyMTYgfCBibHVlIHwgZ3JlZW4gPDwgOCB8IHJlZCA8PCAxNikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICByZ2Iub3BhY2l0eSA9IGlzKG9wYWNpdHksIFwiZmluaXRlXCIpID8gb3BhY2l0eSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG59LCBTbmFwKTtcbi8qXFxcbiAqIFNuYXAuaHNiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0IgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gYiAobnVtYmVyKSB2YWx1ZSBvciBicmlnaHRuZXNzXG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLmhzYiA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgYikge1xuICAgIHJldHVybiBTbmFwLmhzYjJyZ2IoaCwgcywgYikuaGV4O1xufSk7XG4vKlxcXG4gKiBTbmFwLmhzbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNMIHZhbHVlcyB0byBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuXFwqL1xuU25hcC5oc2wgPSBjYWNoZXIoZnVuY3Rpb24gKGgsIHMsIGwpIHtcbiAgICByZXR1cm4gU25hcC5oc2wycmdiKGgsIHMsIGwpLmhleDtcbn0pO1xuLypcXFxuICogU25hcC5yZ2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG4gLSByIChudW1iZXIpIHJlZFxuIC0gZyAobnVtYmVyKSBncmVlblxuIC0gYiAobnVtYmVyKSBibHVlXG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLnJnYiA9IGNhY2hlcihmdW5jdGlvbiAociwgZywgYiwgbykge1xuICAgIGlmIChpcyhvLCBcImZpbml0ZVwiKSkge1xuICAgICAgICB2YXIgcm91bmQgPSBtYXRoLnJvdW5kO1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgW3JvdW5kKHIpLCByb3VuZChnKSwgcm91bmQoYiksICtvLnRvRml4ZWQoMildICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBcIiNcIiArICgxNjc3NzIxNiB8IGIgfCBnIDw8IDggfCByIDw8IDE2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59KTtcbnZhciB0b0hleCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBpID0gZ2xvYi5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGdsb2IuZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLFxuICAgICAgICByZWQgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvci50b0xvd2VyQ2FzZSgpID09IFwicmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IHJlZDtcbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB2YXIgb3V0ID0gZ2xvYi5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShpLCBFKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIik7XG4gICAgICAgIHJldHVybiBvdXQgPT0gcmVkID8gbnVsbCA6IG91dDtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9IZXgoY29sb3IpO1xufSxcbmhzYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzYihcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5iXSArIFwiKVwiO1xufSxcbmhzbHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzbChcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5sXSArIFwiKVwiO1xufSxcbnJnYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT0gMSB8fCB0aGlzLm9wYWNpdHkgPT0gbnVsbCA/XG4gICAgICAgICAgICB0aGlzLmhleCA6XG4gICAgICAgICAgICBcInJnYmEoXCIgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5vcGFjaXR5XSArIFwiKVwiO1xufSxcbnByZXBhcmVSR0IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGlmIChnID09IG51bGwgJiYgaXMociwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gciAmJiBcImdcIiBpbiByICYmIFwiYlwiIGluIHIpIHtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICB9XG4gICAgaWYgKGcgPT0gbnVsbCAmJiBpcyhyLCBzdHJpbmcpKSB7XG4gICAgICAgIHZhciBjbHIgPSBTbmFwLmdldFJHQihyKTtcbiAgICAgICAgciA9IGNsci5yO1xuICAgICAgICBnID0gY2xyLmc7XG4gICAgICAgIGIgPSBjbHIuYjtcbiAgICB9XG4gICAgaWYgKHIgPiAxIHx8IGcgPiAxIHx8IGIgPiAxKSB7XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn0sXG5wYWNrYWdlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICByID0gbWF0aC5yb3VuZChyICogMjU1KTtcbiAgICBnID0gbWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBiID0gbWF0aC5yb3VuZChiICogMjU1KTtcbiAgICB2YXIgcmdiID0ge1xuICAgICAgICByOiByLFxuICAgICAgICBnOiBnLFxuICAgICAgICBiOiBiLFxuICAgICAgICBvcGFjaXR5OiBpcyhvLCBcImZpbml0ZVwiKSA/IG8gOiAxLFxuICAgICAgICBoZXg6IFNuYXAucmdiKHIsIGcsIGIpLFxuICAgICAgICB0b1N0cmluZzogcmdidG9TdHJpbmdcbiAgICB9O1xuICAgIGlzKG8sIFwiZmluaXRlXCIpICYmIChyZ2Iub3BhY2l0eSA9IG8pO1xuICAgIHJldHVybiByZ2I7XG59O1xuLypcXFxuICogU25hcC5jb2xvclxuIFsgbWV0aG9kIF1cbiAqKlxuICogUGFyc2VzIHRoZSBjb2xvciBzdHJpbmcgYW5kIHJldHVybnMgYW4gb2JqZWN0IGZlYXR1cmluZyB0aGUgY29sb3IncyBjb21wb25lbnQgdmFsdWVzXG4gLSBjbHIgKHN0cmluZykgY29sb3Igc3RyaW5nIGluIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZvcm1hdHMgKHNlZSBAU25hcC5nZXRSR0IpXG4gPSAob2JqZWN0KSBDb21iaW5lZCBSR0IvSFNCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiLFxuIG8gICAgIGVycm9yIChib29sZWFuKSBgdHJ1ZWAgaWYgc3RyaW5nIGNhbid0IGJlIHBhcnNlZCxcbiBvICAgICBoIChudW1iZXIpIGh1ZSxcbiBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gbyAgICAgdiAobnVtYmVyKSB2YWx1ZSAoYnJpZ2h0bmVzcyksXG4gbyAgICAgbCAobnVtYmVyKSBsaWdodG5lc3NcbiBvIH1cblxcKi9cblNuYXAuY29sb3IgPSBmdW5jdGlvbiAoY2xyKSB7XG4gICAgdmFyIHJnYjtcbiAgICBpZiAoaXMoY2xyLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBjbHIgJiYgXCJzXCIgaW4gY2xyICYmIFwiYlwiIGluIGNscikge1xuICAgICAgICByZ2IgPSBTbmFwLmhzYjJyZ2IoY2xyKTtcbiAgICAgICAgY2xyLnIgPSByZ2IucjtcbiAgICAgICAgY2xyLmcgPSByZ2IuZztcbiAgICAgICAgY2xyLmIgPSByZ2IuYjtcbiAgICAgICAgY2xyLm9wYWNpdHkgPSAxO1xuICAgICAgICBjbHIuaGV4ID0gcmdiLmhleDtcbiAgICB9IGVsc2UgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImxcIiBpbiBjbHIpIHtcbiAgICAgICAgcmdiID0gU25hcC5oc2wycmdiKGNscik7XG4gICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgIGNsci5vcGFjaXR5ID0gMTtcbiAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzKGNsciwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNsciA9IFNuYXAuZ2V0UkdCKGNscik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gY2xyICYmIFwiZ1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIgJiYgIShcImVycm9yXCIgaW4gY2xyKSkge1xuICAgICAgICAgICAgcmdiID0gU25hcC5yZ2IyaHNsKGNscik7XG4gICAgICAgICAgICBjbHIuaCA9IHJnYi5oO1xuICAgICAgICAgICAgY2xyLnMgPSByZ2IucztcbiAgICAgICAgICAgIGNsci5sID0gcmdiLmw7XG4gICAgICAgICAgICByZ2IgPSBTbmFwLnJnYjJoc2IoY2xyKTtcbiAgICAgICAgICAgIGNsci52ID0gcmdiLmI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHIgPSB7aGV4OiBcIm5vbmVcIn07XG4gICAgICAgICAgICBjbHIuciA9IGNsci5nID0gY2xyLmIgPSBjbHIuaCA9IGNsci5zID0gY2xyLnYgPSBjbHIubCA9IC0xO1xuICAgICAgICAgICAgY2xyLmVycm9yID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbHIudG9TdHJpbmcgPSByZ2J0b1N0cmluZztcbiAgICByZXR1cm4gY2xyO1xufTtcbi8qXFxcbiAqIFNuYXAuaHNiMnJnYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNCIHZhbHVlcyB0byBhbiBSR0Igb2JqZWN0XG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSB2IChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAolxuIG8gfVxuXFwqL1xuU25hcC5oc2IycmdiID0gZnVuY3Rpb24gKGgsIHMsIHYsIG8pIHtcbiAgICBpZiAoaXMoaCwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gaCAmJiBcInNcIiBpbiBoICYmIFwiYlwiIGluIGgpIHtcbiAgICAgICAgdiA9IGguYjtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgbyA9IGgubztcbiAgICAgICAgaCA9IGguaDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gdiAqIHM7XG4gICAgWCA9IEMgKiAoMSAtIGFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5oc2wycmdiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGFuIFJHQiBvYmplY3RcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiXG4gbyB9XG5cXCovXG5TbmFwLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCwgbykge1xuICAgIGlmIChpcyhoLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJsXCIgaW4gaCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIHMgLz0gMTAwO1xuICAgICAgICBsIC89IDEwMDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gMiAqIHMgKiAobCA8IC41ID8gbCA6IDEgLSBsKTtcbiAgICBYID0gQyAqICgxIC0gYWJzKGggJSAyIC0gMSkpO1xuICAgIFIgPSBHID0gQiA9IGwgLSBDIC8gMjtcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTQiBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGIgKG51bWJlcikgYnJpZ2h0bmVzc1xuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNiID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBWLCBDO1xuICAgIFYgPSBtbWF4KHIsIGcsIGIpO1xuICAgIEMgPSBWIC0gbW1pbihyLCBnLCBiKTtcbiAgICBIID0gQyA9PSAwID8gbnVsbCA6XG4gICAgICAgIFYgPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgViA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0O1xuICAgIEggPSAoSCArIDM2MCkgJSA2ICogNjAgLyAzNjA7XG4gICAgUyA9IEMgPT0gMCA/IDAgOiBDIC8gVjtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGI6IFYsIHRvU3RyaW5nOiBoc2J0b1N0cmluZ307XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTTCBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTTCBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNsID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBMLCBNLCBtLCBDO1xuICAgIE0gPSBtbWF4KHIsIGcsIGIpO1xuICAgIG0gPSBtbWluKHIsIGcsIGIpO1xuICAgIEMgPSBNIC0gbTtcbiAgICBIID0gQyA9PSAwID8gbnVsbCA6XG4gICAgICAgIE0gPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgTSA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0O1xuICAgIEggPSAoSCArIDM2MCkgJSA2ICogNjAgLyAzNjA7XG4gICAgTCA9IChNICsgbSkgLyAyO1xuICAgIFMgPSBDID09IDAgPyAwIDpcbiAgICAgICAgIEwgPCAuNSA/IEMgLyAoMiAqIEwpIDpcbiAgICAgICAgICAgICAgICAgIEMgLyAoMiAtIDIgKiBMKTtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGw6IEwsIHRvU3RyaW5nOiBoc2x0b1N0cmluZ307XG59O1xuXG4vLyBUcmFuc2Zvcm1hdGlvbnNcbi8qXFxcbiAqIFNuYXAucGFyc2VQYXRoU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgcGF0aCBzZWdtZW50c1xuIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50cyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuXFwqL1xuU25hcC5wYXJzZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgIGlmICghcGF0aFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHB0aCA9IFNuYXAucGF0aChwYXRoU3RyaW5nKTtcbiAgICBpZiAocHRoLmFycikge1xuICAgICAgICByZXR1cm4gU25hcC5wYXRoLmNsb25lKHB0aC5hcnIpO1xuICAgIH1cblxuICAgIHZhciBwYXJhbUNvdW50cyA9IHthOiA3LCBjOiA2LCBvOiAyLCBoOiAxLCBsOiAyLCBtOiAyLCByOiA0LCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB1OiAzLCB6OiAwfSxcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgIGlmIChpcyhwYXRoU3RyaW5nLCBcImFycmF5XCIpICYmIGlzKHBhdGhTdHJpbmdbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICBkYXRhID0gU25hcC5wYXRoLmNsb25lKHBhdGhTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIFN0cihwYXRoU3RyaW5nKS5yZXBsYWNlKHBhdGhDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJtXCIgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwibFwiO1xuICAgICAgICAgICAgICAgIGIgPSBiID09IFwibVwiID8gXCJsXCIgOiBcIkxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09IFwib1wiICYmIHBhcmFtcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYiwgcGFyYW1zWzBdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInJcIikge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICAgICAgfSBlbHNlIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCBwYXJhbUNvdW50c1tuYW1lXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudG9TdHJpbmcgPSBTbmFwLnBhdGgudG9TdHJpbmc7XG4gICAgcHRoLmFyciA9IFNuYXAucGF0aC5jbG9uZShkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG4vKlxcXG4gKiBTbmFwLnBhcnNlVHJhbnNmb3JtU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gdHJhbnNmb3JtIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuIC0gVFN0cmluZyAoc3RyaW5nfGFycmF5KSB0cmFuc2Zvcm0gc3RyaW5nIG9yIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9ucyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcblxcKi9cbnZhciBwYXJzZVRyYW5zZm9ybVN0cmluZyA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiAoVFN0cmluZykge1xuICAgIGlmICghVFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHBhcmFtQ291bnRzID0ge3I6IDMsIHM6IDQsIHQ6IDIsIG06IDZ9LFxuICAgICAgICBkYXRhID0gW107XG4gICAgaWYgKGlzKFRTdHJpbmcsIFwiYXJyYXlcIikgJiYgaXMoVFN0cmluZ1swXSwgXCJhcnJheVwiKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgIGRhdGEgPSBTbmFwLnBhdGguY2xvbmUoVFN0cmluZyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgU3RyKFRTdHJpbmcpLnJlcGxhY2UodENvbW1hbmQsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudG9TdHJpbmcgPSBTbmFwLnBhdGgudG9TdHJpbmc7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuZnVuY3Rpb24gc3ZnVHJhbnNmb3JtMnN0cmluZyh0c3RyKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHRzdHIgPSB0c3RyLnJlcGxhY2UoLyg/Ol58XFxzKShcXHcrKVxcKChbXildKylcXCkvZywgZnVuY3Rpb24gKGFsbCwgbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJyb3RhdGVcIiAmJiBwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbXNbMF0sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2tld1hcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCAwLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwic2tld1lcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDAsIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtuYW1lLmNoYXJBdCgwKV0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cblNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nID0gc3ZnVHJhbnNmb3JtMnN0cmluZztcblNuYXAuXy5yZ1RyYW5zZm9ybSA9IC9eW2Etel1bXFxzXSotP1xcLj9cXGQvaTtcbmZ1bmN0aW9uIHRyYW5zZm9ybTJtYXRyaXgodHN0ciwgYmJveCkge1xuICAgIHZhciB0ZGF0YSA9IHBhcnNlVHJhbnNmb3JtU3RyaW5nKHRzdHIpLFxuICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4O1xuICAgIGlmICh0ZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRkYXRhW2ldLFxuICAgICAgICAgICAgICAgIHRsZW4gPSB0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjb21tYW5kID0gU3RyKHRbMF0pLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgYWJzb2x1dGUgPSB0WzBdICE9IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgaW52ZXIgPSBhYnNvbHV0ZSA/IG0uaW52ZXJ0KCkgOiAwLFxuICAgICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgICAgIGJiO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gXCJ0XCIgJiYgdGxlbiA9PSAyKXtcbiAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcInRcIiAmJiB0bGVuID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBpbnZlci54KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGludmVyLnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJiID0gYmIgfHwgYmJveDtcbiAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgYmIueCArIGJiLndpZHRoIC8gMiwgYmIueSArIGJiLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwic1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRsZW4gPT0gMiB8fCB0bGVuID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBiYm94O1xuICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbdGxlbiAtIDFdLCBiYi54ICsgYmIud2lkdGggLyAyLCBiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMV0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwibVwiICYmIHRsZW4gPT0gNykge1xuICAgICAgICAgICAgICAgIG0uYWRkKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0sIHRbNl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xufVxuU25hcC5fLnRyYW5zZm9ybTJtYXRyaXggPSB0cmFuc2Zvcm0ybWF0cml4O1xuU25hcC5fdW5pdDJweCA9IHVuaXQycHg7XG52YXIgY29udGFpbnMgPSBnbG9iLmRvYy5jb250YWlucyB8fCBnbG9iLmRvYy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gYSA9PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PSAxICYmIChcbiAgICAgICAgICAgICAgICBhZG93bi5jb250YWlucyA/XG4gICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKGJ1cCkgOlxuICAgICAgICAgICAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2XG4gICAgICAgICAgICApKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgd2hpbGUgKGIpIHtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChiID09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuZnVuY3Rpb24gZ2V0U29tZURlZnMoZWwpIHtcbiAgICB2YXIgcCA9IGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8XG4gICAgICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUgJiYgd3JhcChlbC5ub2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICBTbmFwLnNlbGVjdChcInN2Z1wiKSB8fFxuICAgICAgICAgICAgU25hcCgwLCAwKSxcbiAgICAgICAgcGRlZnMgPSBwLnNlbGVjdChcImRlZnNcIiksXG4gICAgICAgIGRlZnMgID0gcGRlZnMgPT0gbnVsbCA/IGZhbHNlIDogcGRlZnMubm9kZTtcbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgZGVmcyA9IG1ha2UoXCJkZWZzXCIsIHAubm9kZSkubm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZnM7XG59XG5mdW5jdGlvbiBnZXRTb21lU1ZHKGVsKSB7XG4gICAgcmV0dXJuIGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8IFNuYXAuc2VsZWN0KFwic3ZnXCIpO1xufVxuU25hcC5fLmdldFNvbWVEZWZzID0gZ2V0U29tZURlZnM7XG5TbmFwLl8uZ2V0U29tZVNWRyA9IGdldFNvbWVTVkc7XG5mdW5jdGlvbiB1bml0MnB4KGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBzdmcgPSBnZXRTb21lU1ZHKGVsKS5ub2RlLFxuICAgICAgICBvdXQgPSB7fSxcbiAgICAgICAgbWdyID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoXCIuc3ZnLS0tbWdyXCIpO1xuICAgIGlmICghbWdyKSB7XG4gICAgICAgIG1nciA9ICQoXCJyZWN0XCIpO1xuICAgICAgICAkKG1nciwge3g6IC05ZTksIHk6IC05ZTksIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMCwgXCJjbGFzc1wiOiBcInN2Zy0tLW1nclwiLCBmaWxsOiBcIm5vbmVcIn0pO1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQobWdyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vyh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHt3aWR0aDogdmFsfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbWdyLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHtoZWlnaHQ6IHZhbH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1nci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQobmFtLCBmKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dFtuYW1dID0gZihlbC5hdHRyKG5hbSkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtID09IG5hbWUpIHtcbiAgICAgICAgICAgIG91dCA9IGYodmFsdWUgPT0gbnVsbCA/IGVsLmF0dHIobmFtKSB8fCAwIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgc2V0KFwicnhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyeVwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICBzZXQoXCJ3aWR0aFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImhlaWdodFwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHNldChcInhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJcIiwgZ2V0Vyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJ4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwicnlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgc2V0KFwieDFcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ4MlwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInkxXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwieTJcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFya2VyXCI6XG4gICAgICAgICAgICBzZXQoXCJyZWZYXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VyV2lkdGhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyZWZZXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VySGVpZ2h0XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJhZGlhbEdyYWRpZW50XCI6XG4gICAgICAgICAgICBzZXQoXCJmeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImZ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRzcGFuXCI6XG4gICAgICAgICAgICBzZXQoXCJkeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImR5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldChuYW1lLCBnZXRXKTtcbiAgICB9XG4gICAgc3ZnLnJlbW92ZUNoaWxkKG1ncik7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qXFxcbiAqIFNuYXAuc2VsZWN0XG4gWyBtZXRob2QgXVxuICoqXG4gKiBXcmFwcyBhIERPTSBlbGVtZW50IHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgQEVsZW1lbnRcbiAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvciBvZiB0aGUgZWxlbWVudFxuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcblxcKi9cblNuYXAuc2VsZWN0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBTdHIocXVlcnkpLnJlcGxhY2UoLyhbXlxcXFxdKTovZywgXCIkMVxcXFw6XCIpO1xuICAgIHJldHVybiB3cmFwKGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbn07XG4vKlxcXG4gKiBTbmFwLnNlbGVjdEFsbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogV3JhcHMgRE9NIGVsZW1lbnRzIHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgc2V0IG9yIGFycmF5IG9mIEBFbGVtZW50XG4gLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnRcbiA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG5cXCovXG5TbmFwLnNlbGVjdEFsbCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBub2RlbGlzdCA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICBzZXQgPSAoU25hcC5zZXQgfHwgQXJyYXkpKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59O1xuXG5mdW5jdGlvbiBhZGQyZ3JvdXAobGlzdCkge1xuICAgIGlmICghaXMobGlzdCwgXCJhcnJheVwiKSkge1xuICAgICAgICBsaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZTtcbiAgICB3aGlsZSAodGhpc1tpXSkgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIGxpc3RbaV0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGVsLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2orK10gPSB3cmFwKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vLyBIdWIgZ2FyYmFnZSBjb2xsZWN0b3IgZXZlcnkgMTBzXG5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGh1YikgaWYgKGh1YltoYXNdKGtleSkpIHtcbiAgICAgICAgdmFyIGVsID0gaHViW2tleV0sXG4gICAgICAgICAgICBub2RlID0gZWwubm9kZTtcbiAgICAgICAgaWYgKGVsLnR5cGUgIT0gXCJzdmdcIiAmJiAhbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgZWwudHlwZSA9PSBcInN2Z1wiICYmICghbm9kZS5wYXJlbnROb2RlIHx8IFwib3duZXJTVkdFbGVtZW50XCIgaW4gbm9kZS5wYXJlbnROb2RlICYmICFub2RlLm93bmVyU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBodWJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn0sIDFlNCk7XG5mdW5jdGlvbiBFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnNuYXAgaW4gaHViKSB7XG4gICAgICAgIHJldHVybiBodWJbZWwuc25hcF07XG4gICAgfVxuICAgIHZhciBzdmc7XG4gICAgdHJ5IHtcbiAgICAgICAgc3ZnID0gZWwub3duZXJTVkdFbGVtZW50O1xuICAgIH0gY2F0Y2goZSkge31cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5ub2RlXG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIEdpdmVzIHlvdSBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIG9iamVjdCwgc28geW91IGNhbiBhc3NpZ24gZXZlbnQgaGFuZGxlcnMgb3IganVzdCBtZXNzIGFyb3VuZC5cbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGRyYXcgYSBjaXJjbGUgYXQgY29vcmRpbmF0ZSAxMCwxMCB3aXRoIHJhZGl1cyBvZiAxMFxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApO1xuICAgICB8IGMubm9kZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICBjLmF0dHIoXCJmaWxsXCIsIFwicmVkXCIpO1xuICAgICB8IH07XG4gICAgXFwqL1xuICAgIHRoaXMubm9kZSA9IGVsO1xuICAgIGlmIChzdmcpIHtcbiAgICAgICAgdGhpcy5wYXBlciA9IG5ldyBQYXBlcihzdmcpO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50eXBlXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIFNWRyB0YWcgbmFtZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICBcXCovXG4gICAgdGhpcy50eXBlID0gZWwudGFnTmFtZSB8fCBlbC5ub2RlTmFtZTtcbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gSUQodGhpcyk7XG4gICAgdGhpcy5hbmltcyA9IHt9O1xuICAgIHRoaXMuXyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgIH07XG4gICAgZWwuc25hcCA9IGlkO1xuICAgIGh1YltpZF0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJnXCIpIHtcbiAgICAgICAgdGhpcy5hZGQgPSBhZGQyZ3JvdXA7XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgaW4ge2c6IDEsIG1hc2s6IDEsIHBhdHRlcm46IDEsIHN5bWJvbDogMX0pIHtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIFBhcGVyLnByb3RvdHlwZSkgaWYgKFBhcGVyLnByb3RvdHlwZVtoYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IFBhcGVyLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxufVxuICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXR0clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2V0cyBvciBzZXRzIGdpdmVuIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXG4gICAgICoqXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHNldFxuICAgICAqIG9yXG4gICAgIC0gcGFyYW0gKHN0cmluZykgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChzdHJpbmcpIHZhbHVlIG9mIGF0dHJpYnV0ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IFwiI2ZjMFwiLFxuICAgICB8ICAgICBzdHJva2U6IFwiIzAwMFwiLFxuICAgICB8ICAgICBzdHJva2VXaWR0aDogMiwgLy8gQ2FtZWxDYXNlLi4uXG4gICAgIHwgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAuNSwgLy8gb3IgZGFzaC1zZXBhcmF0ZWQgbmFtZXNcbiAgICAgfCAgICAgd2lkdGg6IFwiKj0yXCIgLy8gcHJlZml4ZWQgdmFsdWVzXG4gICAgIHwgfSk7XG4gICAgIHwgY29uc29sZS5sb2coZWwuYXR0cihcImZpbGxcIikpOyAvLyAjZmMwXG4gICAgICogUHJlZml4ZWQgdmFsdWVzIGluIGZvcm1hdCBgXCIrPTEwXCJgIHN1cHBvcnRlZC4gQWxsIGZvdXIgb3BlcmF0aW9uc1xuICAgICAqIChgK2AsIGAtYCwgYCpgIGFuZCBgL2ApIGNvdWxkIGJlIHVzZWQuIE9wdGlvbmFsbHkgeW91IGNhbiB1c2UgdW5pdHMgZm9yIGArYFxuICAgICAqIGFuZCBgLWA6IGBcIis9MmVtXCJgLlxuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBlbC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5vZGUubm9kZVZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXR0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2F0dHJbaV0ubm9kZU5hbWVdID0gYXR0cltpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhwYXJhbXMsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGpzb25bcGFyYW1zXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGpzb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5cIiArIHBhcmFtcywgZWwpLmZpcnN0RGVmaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGF0dCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgZXZlKFwic25hcC51dGlsLmF0dHIuXCIgKyBhdHQsIGVsLCBwYXJhbXNbYXR0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4vKlxcXG4gKiBTbmFwLnBhcnNlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgU1ZHIGZyYWdtZW50IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgQEZyYWdtZW50XG4gKipcbiAtIHN2ZyAoc3RyaW5nKSBTVkcgc3RyaW5nXG4gPSAoRnJhZ21lbnQpIHRoZSBARnJhZ21lbnRcblxcKi9cblNuYXAucGFyc2UgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGZ1bGwgPSB0cnVlLFxuICAgICAgICBkaXYgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN2ZyA9IFN0cihzdmcpO1xuICAgIGlmICghc3ZnLm1hdGNoKC9eXFxzKjxcXHMqc3ZnKD86XFxzfD4pLykpIHtcbiAgICAgICAgc3ZnID0gXCI8c3ZnPlwiICsgc3ZnICsgXCI8L3N2Zz5cIjtcbiAgICAgICAgZnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXYuaW5uZXJIVE1MID0gc3ZnO1xuICAgIHN2ZyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICBpZiAoc3ZnKSB7XG4gICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICBmID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChmKTtcbn07XG5mdW5jdGlvbiBGcmFnbWVudChmcmFnKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZztcbn1cbi8qXFxcbiAqIFNuYXAuZnJhZ21lbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBET00gZnJhZ21lbnQgZnJvbSBhIGdpdmVuIGxpc3Qgb2YgZWxlbWVudHMgb3Igc3RyaW5nc1xuICoqXG4gLSB2YXJhcmdzICjigKYpIFNWRyBzdHJpbmdcbiA9IChGcmFnbWVudCkgdGhlIEBGcmFnbWVudFxuXFwqL1xuU25hcC5mcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0ubm9kZSAmJiBpdGVtLm5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoaXRlbS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChTbmFwLnBhcnNlKGl0ZW0pLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoZik7XG59O1xuXG5mdW5jdGlvbiBtYWtlKG5hbWUsIHBhcmVudCkge1xuICAgIHZhciByZXMgPSAkKG5hbWUpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZXMpO1xuICAgIHZhciBlbCA9IHdyYXAocmVzKTtcbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBQYXBlcih3LCBoKSB7XG4gICAgdmFyIHJlcyxcbiAgICAgICAgZGVzYyxcbiAgICAgICAgZGVmcyxcbiAgICAgICAgcHJvdG8gPSBQYXBlci5wcm90b3R5cGU7XG4gICAgaWYgKHcgJiYgdy50YWdOYW1lICYmIHcudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgaWYgKHcuc25hcCBpbiBodWIpIHtcbiAgICAgICAgICAgIHJldHVybiBodWJbdy5zbmFwXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gdy5vd25lckRvY3VtZW50O1xuICAgICAgICByZXMgPSBuZXcgRWxlbWVudCh3KTtcbiAgICAgICAgZGVzYyA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkZXNjXCIpWzBdO1xuICAgICAgICBkZWZzID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlZnNcIilbMF07XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgZGVzYyA9ICQoXCJkZXNjXCIpO1xuICAgICAgICAgICAgZGVzYy5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggU25hcFwiKSk7XG4gICAgICAgICAgICByZXMubm9kZS5hcHBlbmRDaGlsZChkZXNjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgICAgIGRlZnMgPSAkKFwiZGVmc1wiKTtcbiAgICAgICAgICAgIHJlcy5ub2RlLmFwcGVuZENoaWxkKGRlZnMpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5kZWZzID0gZGVmcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3RvKSBpZiAocHJvdG9baGFzXShrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnBhcGVyID0gcmVzLnJvb3QgPSByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gbWFrZShcInN2Z1wiLCBnbG9iLmRvYy5ib2R5KTtcbiAgICAgICAgJChyZXMubm9kZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgdmVyc2lvbjogMS4xLFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICB4bWxuczogeG1sbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwKGRvbSkge1xuICAgIGlmICghZG9tKSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGRvbSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20udGFnTmFtZSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXBlcihkb20pO1xuICAgIH1cbiAgICBpZiAoZG9tLnRhZ05hbWUgJiYgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm9iamVjdFwiICYmIGRvbS50eXBlID09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFwZXIoZG9tLmNvbnRlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudChkb20pO1xufVxuXG5TbmFwLl8ubWFrZSA9IG1ha2U7XG5TbmFwLl8ud3JhcCA9IHdyYXA7XG4vKlxcXG4gKiBQYXBlci5lbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IG9uIHBhcGVyIHdpdGggYSBnaXZlbiBuYW1lIGFuZCBubyBhdHRyaWJ1dGVzXG4gKipcbiAtIG5hbWUgKHN0cmluZykgdGFnIG5hbWVcbiAtIGF0dHIgKG9iamVjdCkgYXR0cmlidXRlc1xuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiA+IFVzYWdlXG4gfCB2YXIgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKTsgLy8gaXMgdGhlIHNhbWUgYXMuLi5cbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIikuYXR0cih7XG4gfCAgICAgY3g6IDEwLFxuIHwgICAgIGN5OiAxMCxcbiB8ICAgICByOiAxMFxuIHwgfSk7XG4gfCAvLyBhbmQgdGhlIHNhbWUgYXNcbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIiwge1xuIHwgICAgIGN4OiAxMCxcbiB8ICAgICBjeTogMTAsXG4gfCAgICAgcjogMTBcbiB8IH0pO1xuXFwqL1xuUGFwZXIucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gKG5hbWUsIGF0dHIpIHtcbiAgICB2YXIgZWwgPSBtYWtlKG5hbWUsIHRoaXMubm9kZSk7XG4gICAgYXR0ciAmJiBlbC5hdHRyKGF0dHIpO1xuICAgIHJldHVybiBlbDtcbn07XG4vKlxcXG4gKiBFbGVtZW50LmNoaWxkcmVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gPSAoYXJyYXkpIGFycmF5IG9mIEVsZW1lbnRzXG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGNoID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBTbmFwKGNoW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5mdW5jdGlvbiBqc29uRmlsbGVyKHJvb3QsIG8pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb290Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcm9vdFtpXS50eXBlLFxuICAgICAgICAgICAgICAgIGF0dHI6IHJvb3RbaV0uYXR0cigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW4gPSByb290W2ldLmNoaWxkcmVuKCk7XG4gICAgICAgIG8ucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAganNvbkZpbGxlcihjaGlsZHJlbiwgaXRlbS5jaGlsZE5vZGVzID0gW10pO1xuICAgICAgICB9XG4gICAgfVxufVxuLypcXFxuICogRWxlbWVudC50b0pTT05cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLlxuID0gKG9iamVjdCkgaW4gZm9ybWF0XG4gbyB7XG4gbyAgICAgdHlwZSAoc3RyaW5nKSB0aGlzLnR5cGUsXG4gbyAgICAgYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzIG1hcCxcbiBvICAgICBjaGlsZE5vZGVzIChhcnJheSkgb3B0aW9uYWwgYXJyYXkgb2YgY2hpbGRyZW4gaW4gdGhlIHNhbWUgZm9ybWF0XG4gbyB9XG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGpzb25GaWxsZXIoW3RoaXNdLCBvdXQpO1xuICAgIHJldHVybiBvdXRbMF07XG59O1xuLy8gZGVmYXVsdFxuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKTtcbiAgICBhdHQgPSBhdHQuc3Vic3RyaW5nKGF0dC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICB2YXIgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgaWYgKGNzc0F0dHJbaGFzXShjc3MpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShjc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMubm9kZSwgYXR0KTtcbiAgICB9XG59KTtcbnZhciBjc3NBdHRyID0ge1xuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiOiAwLFxuICAgIFwiY2xpcFwiOiAwLFxuICAgIFwiY2xpcC1wYXRoXCI6IDAsXG4gICAgXCJjbGlwLXJ1bGVcIjogMCxcbiAgICBcImNvbG9yXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogMCxcbiAgICBcImNvbG9yLXByb2ZpbGVcIjogMCxcbiAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwiY3Vyc29yXCI6IDAsXG4gICAgXCJkaXJlY3Rpb25cIjogMCxcbiAgICBcImRpc3BsYXlcIjogMCxcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiAwLFxuICAgIFwiZmlsbFwiOiAwLFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAsXG4gICAgXCJmaWxsLXJ1bGVcIjogMCxcbiAgICBcImZpbHRlclwiOiAwLFxuICAgIFwiZmxvb2QtY29sb3JcIjogMCxcbiAgICBcImZsb29kLW9wYWNpdHlcIjogMCxcbiAgICBcImZvbnRcIjogMCxcbiAgICBcImZvbnQtZmFtaWx5XCI6IDAsXG4gICAgXCJmb250LXNpemVcIjogMCxcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogMCxcbiAgICBcImZvbnQtc3RyZXRjaFwiOiAwLFxuICAgIFwiZm9udC1zdHlsZVwiOiAwLFxuICAgIFwiZm9udC12YXJpYW50XCI6IDAsXG4gICAgXCJmb250LXdlaWdodFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogMCxcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwia2VybmluZ1wiOiAwLFxuICAgIFwibGV0dGVyLXNwYWNpbmdcIjogMCxcbiAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IDAsXG4gICAgXCJtYXJrZXJcIjogMCxcbiAgICBcIm1hcmtlci1lbmRcIjogMCxcbiAgICBcIm1hcmtlci1taWRcIjogMCxcbiAgICBcIm1hcmtlci1zdGFydFwiOiAwLFxuICAgIFwibWFza1wiOiAwLFxuICAgIFwib3BhY2l0eVwiOiAwLFxuICAgIFwib3ZlcmZsb3dcIjogMCxcbiAgICBcInBvaW50ZXItZXZlbnRzXCI6IDAsXG4gICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogMCxcbiAgICBcInN0b3AtY29sb3JcIjogMCxcbiAgICBcInN0b3Atb3BhY2l0eVwiOiAwLFxuICAgIFwic3Ryb2tlXCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiAwLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogMCxcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiAwLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMCxcbiAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDAsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogMCxcbiAgICBcInRleHQtYW5jaG9yXCI6IDAsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogMCxcbiAgICBcInRleHQtcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJ1bmljb2RlLWJpZGlcIjogMCxcbiAgICBcInZpc2liaWxpdHlcIjogMCxcbiAgICBcIndvcmQtc3BhY2luZ1wiOiAwLFxuICAgIFwid3JpdGluZy1tb2RlXCI6IDBcbn07XG5cbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKSxcbiAgICAgICAgYXR0ciA9IHt9O1xuICAgIGF0dCA9IGF0dC5zdWJzdHJpbmcoYXR0Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGF0dHJbYXR0XSA9IHZhbHVlO1xuICAgIHZhciBzdHlsZSA9IGF0dC5yZXBsYWNlKC8tKFxcdykvZ2ksIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICBpZiAoY3NzQXR0cltoYXNdKGNzcykpIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3N0eWxlXSA9IHZhbHVlID09IG51bGwgPyBFIDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzLm5vZGUsIGF0dHIpO1xuICAgIH1cbn0pO1xuKGZ1bmN0aW9uIChwcm90bykge30oUGFwZXIucHJvdG90eXBlKSk7XG5cbi8vIHNpbXBsZSBhamF4XG4vKlxcXG4gKiBTbmFwLmFqYXhcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBBamF4XG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIHBvc3REYXRhIChvYmplY3R8c3RyaW5nKSBkYXRhIGZvciBwb3N0IHJlcXVlc3RcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuICogb3JcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuID0gKFhNTEh0dHBSZXF1ZXN0KSB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LCBqdXN0IGluIGNhc2VcblxcKi9cblNuYXAuYWpheCA9IGZ1bmN0aW9uICh1cmwsIHBvc3REYXRhLCBjYWxsYmFjaywgc2NvcGUpe1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QsXG4gICAgICAgIGlkID0gSUQoKTtcbiAgICBpZiAocmVxKSB7XG4gICAgICAgIGlmIChpcyhwb3N0RGF0YSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgc2NvcGUgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcG9zdERhdGE7XG4gICAgICAgICAgICBwb3N0RGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMocG9zdERhdGEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgcGQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwb3N0RGF0YSkgaWYgKHBvc3REYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocG9zdERhdGFba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdERhdGEgPSBwZC5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub3Blbihwb3N0RGF0YSA/IFwiUE9TVFwiIDogXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKHBvc3REYXRhKSB7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjBcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjIwMFwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBldmUub25jZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuMzA0XCIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xuICAgICAgICAgICAgZXZlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi5cIiArIHJlcS5zdGF0dXMsIHNjb3BlLCByZXEpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZChwb3N0RGF0YSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxufTtcbi8qXFxcbiAqIFNuYXAubG9hZFxuIFsgbWV0aG9kIF1cbiAqKlxuICogTG9hZHMgZXh0ZXJuYWwgU1ZHIGZpbGUgYXMgYSBARnJhZ21lbnQgKHNlZSBAU25hcC5hamF4IGZvciBtb3JlIGFkdmFuY2VkIEFKQVgpXG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuXFwqL1xuU25hcC5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgU25hcC5hamF4KHVybCwgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgZiA9IFNuYXAucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNjb3BlID8gY2FsbGJhY2suY2FsbChzY29wZSwgZikgOiBjYWxsYmFjayhmKTtcbiAgICB9KTtcbn07XG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLCBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLFxuICAgICAgICB0b3AgID0gYm94LnRvcCAgKyAoZy53aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3AgKSAtIGNsaWVudFRvcCxcbiAgICAgICAgbGVmdCA9IGJveC5sZWZ0ICsgKGcud2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gY2xpZW50TGVmdDtcbiAgICByZXR1cm4ge1xuICAgICAgICB5OiB0b3AsXG4gICAgICAgIHg6IGxlZnRcbiAgICB9O1xufTtcbi8qXFxcbiAqIFNuYXAuZ2V0RWxlbWVudEJ5UG9pbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgeW91IHRvcG1vc3QgZWxlbWVudCB1bmRlciBnaXZlbiBwb2ludC5cbiAqKlxuID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdFxuIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3dcbiAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gPiBVc2FnZVxuIHwgU25hcC5nZXRFbGVtZW50QnlQb2ludChtb3VzZVgsIG1vdXNlWSkuYXR0cih7c3Ryb2tlOiBcIiNmMDBcIn0pO1xuXFwqL1xuU25hcC5nZXRFbGVtZW50QnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHBhcGVyID0gdGhpcyxcbiAgICAgICAgc3ZnID0gcGFwZXIuY2FudmFzLFxuICAgICAgICB0YXJnZXQgPSBnbG9iLmRvYy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChnbG9iLndpbi5vcGVyYSAmJiB0YXJnZXQudGFnTmFtZSA9PSBcInN2Z1wiKSB7XG4gICAgICAgIHZhciBzbyA9IGdldE9mZnNldCh0YXJnZXQpLFxuICAgICAgICAgICAgc3IgPSB0YXJnZXQuY3JlYXRlU1ZHUmVjdCgpO1xuICAgICAgICBzci54ID0geCAtIHNvLng7XG4gICAgICAgIHNyLnkgPSB5IC0gc28ueTtcbiAgICAgICAgc3Iud2lkdGggPSBzci5oZWlnaHQgPSAxO1xuICAgICAgICB2YXIgaGl0cyA9IHRhcmdldC5nZXRJbnRlcnNlY3Rpb25MaXN0KHNyLCBudWxsKTtcbiAgICAgICAgaWYgKGhpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBoaXRzW2hpdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHRhcmdldCk7XG59O1xuLypcXFxuICogU25hcC5wbHVnaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIExldCB5b3Ugd3JpdGUgcGx1Z2lucy4gWW91IHBhc3MgaW4gYSBmdW5jdGlvbiB3aXRoIGZpdmUgYXJndW1lbnRzLCBsaWtlIHRoaXM6XG4gfCBTbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2JhbCwgRnJhZ21lbnQpIHtcbiB8ICAgICBTbmFwLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgICAgIEVsZW1lbnQucHJvdG90eXBlLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgICAgIFBhcGVyLnByb3RvdHlwZS5uZXdtZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcbiB8IH0pO1xuICogSW5zaWRlIHRoZSBmdW5jdGlvbiB5b3UgaGF2ZSBhY2Nlc3MgdG8gYWxsIG1haW4gb2JqZWN0cyAoYW5kIHRoZWlyXG4gKiBwcm90b3R5cGVzKS4gVGhpcyBhbGxvdyB5b3UgdG8gZXh0ZW5kIGFueXRoaW5nIHlvdSB3YW50LlxuICoqXG4gLSBmIChmdW5jdGlvbikgeW91ciBwbHVnaW4gYm9keVxuXFwqL1xuU25hcC5wbHVnaW4gPSBmdW5jdGlvbiAoZikge1xuICAgIGYoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KTtcbn07XG5nbG9iLndpbi5TbmFwID0gU25hcDtcbnJldHVybiBTbmFwO1xufSh3aW5kb3cgfHwgdGhpcykpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHVuaXQycHggPSBTbmFwLl91bml0MnB4LFxuICAgICAgICAkID0gU25hcC5fLiQsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgZ2V0U29tZURlZnMgPSBTbmFwLl8uZ2V0U29tZURlZnMsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBkZXNjcmlwdG9yIGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveCBkZXNjcmlwdG9yOlxuICAgICBvIHtcbiAgICAgbyAgICAgY3g6IChudW1iZXIpIHggb2YgdGhlIGNlbnRlcixcbiAgICAgbyAgICAgY3k6IChudW1iZXIpIHggb2YgdGhlIGNlbnRlcixcbiAgICAgbyAgICAgaDogKG51bWJlcikgaGVpZ2h0LFxuICAgICBvICAgICBoZWlnaHQ6IChudW1iZXIpIGhlaWdodCxcbiAgICAgbyAgICAgcGF0aDogKHN0cmluZykgcGF0aCBjb21tYW5kIGZvciB0aGUgYm94LFxuICAgICBvICAgICByMDogKG51bWJlcikgcmFkaXVzIG9mIGEgY2lyY2xlIHRoYXQgZnVsbHkgZW5jbG9zZXMgdGhlIGJveCxcbiAgICAgbyAgICAgcjE6IChudW1iZXIpIHJhZGl1cyBvZiB0aGUgc21hbGxlc3QgY2lyY2xlIHRoYXQgY2FuIGJlIGVuY2xvc2VkLFxuICAgICBvICAgICByMjogKG51bWJlcikgcmFkaXVzIG9mIHRoZSBsYXJnZXN0IGNpcmNsZSB0aGF0IGNhbiBiZSBlbmNsb3NlZCxcbiAgICAgbyAgICAgdmI6IChzdHJpbmcpIGJveCBhcyBhIHZpZXdib3ggY29tbWFuZCxcbiAgICAgbyAgICAgdzogKG51bWJlcikgd2lkdGgsXG4gICAgIG8gICAgIHdpZHRoOiAobnVtYmVyKSB3aWR0aCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggb2YgdGhlIHJpZ2h0IHNpZGUsXG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggb2YgdGhlIGxlZnQgc2lkZSxcbiAgICAgbyAgICAgeTI6IChudW1iZXIpIHkgb2YgdGhlIGJvdHRvbSBlZGdlLFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IG9mIHRoZSB0b3AgZWRnZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKGlzV2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3godGhpcy5ub2RlLmdldENsaWVudFJlY3RzKCkuaXRlbSgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFTbmFwLk1hdHJpeCB8fCAhU25hcC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgbSA9IG5ldyBTbmFwLk1hdHJpeDtcbiAgICAgICAgaWYgKGVsLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVsLnR5cGUgPT0gXCJ1c2VcIikge1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtID0gbS5hZGQoZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXgudHJhbnNsYXRlKGVsLmF0dHIoXCJ4XCIpIHx8IDAsIGVsLmF0dHIoXCJ5XCIpIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIGVsID0gZWwub3JpZ2luYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gZWwuYXR0cihcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5vcmlnaW5hbCA9IGVsLm5vZGUub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChocmVmLnN1YnN0cmluZyhocmVmLmluZGV4T2YoXCIjXCIpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfID0gZWwuXyxcbiAgICAgICAgICAgIHBhdGhmaW5kZXIgPSBTbmFwLnBhdGguZ2V0W2VsLnR5cGVdIHx8IFNuYXAucGF0aC5nZXQuZGVmbHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgXy5iYm94d3QgPSBwYXRoZmluZGVyID8gU25hcC5wYXRoLmdldEJCb3goZWwucmVhbFBhdGggPSBwYXRoZmluZGVyKGVsKSkgOiBTbmFwLl8uYm94KGVsLm5vZGUuZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChfLmJib3h3dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlYWxQYXRoID0gcGF0aGZpbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgZWwubWF0cml4ID0gZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXg7XG4gICAgICAgICAgICAgICAgXy5iYm94ID0gU25hcC5wYXRoLmdldEJCb3goU25hcC5wYXRoLm1hcChlbC5yZWFsUGF0aCwgbS5hZGQoZWwubWF0cml4KSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KF8uYmJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc27igJl0IGdpdmUgeW91IGJib3ggb2YgaGlkZGVuIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9wU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBleHRyYWN0VHJhbnNmb3JtKGVsLCB0c3RyKSB7XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkb1JldHVybiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgZWwudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJncmFkaWVudFRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInBhdHRlcm5UcmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0c3RyID0gU25hcC5fLnN2Z1RyYW5zZm9ybTJzdHJpbmcodHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIVNuYXAuXy5yZ1RyYW5zZm9ybS50ZXN0KHRzdHIpKSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IFNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nKHRzdHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU3RyKHRzdHIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGVsLl8udHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzKHRzdHIsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU25hcC5wYXRoID8gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodHN0cikgOiBTdHIodHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fLnRyYW5zZm9ybSA9IHRzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0c3RyLCBlbC5nZXRCQm94KDEpKTtcbiAgICAgICAgaWYgKGRvUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLm1hdHJpeCA9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudHJhbnNmb3JtXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSB0c3RyIChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmcgaW4gU25hcCBvciBTVkcgZm9ybWF0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChvYmplY3QpIHRyYW5zZm9ybWF0aW9uIGRlc2NyaXB0b3I6XG4gICAgIG8ge1xuICAgICBvICAgICBzdHJpbmcgKHN0cmluZykgdHJhbnNmb3JtIHN0cmluZyxcbiAgICAgbyAgICAgZ2xvYmFsTWF0cml4IChNYXRyaXgpIG1hdHJpeCBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgdG8gZWxlbWVudCBvciBpdHMgcGFyZW50cyxcbiAgICAgbyAgICAgbG9jYWxNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIG9ubHkgdG8gdGhlIGVsZW1lbnQsXG4gICAgIG8gICAgIGRpZmZNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIGRpZmZlcmVuY2UgYmV0d2VlbiBnbG9iYWwgYW5kIGxvY2FsIHRyYW5zZm9ybWF0aW9ucyxcbiAgICAgbyAgICAgZ2xvYmFsIChzdHJpbmcpIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBhcyBzdHJpbmcsXG4gICAgIG8gICAgIGxvY2FsIChzdHJpbmcpIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGFzIHN0cmluZyxcbiAgICAgbyAgICAgdG9TdHJpbmcgKGZ1bmN0aW9uKSByZXR1cm5zIGBzdHJpbmdgIHByb3BlcnR5XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0c3RyKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAodHN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFwYSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gbmV3IFNuYXAuTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSksXG4gICAgICAgICAgICAgICAgbG9jYWwgPSBleHRyYWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgICAgICAgIG1zID0gW2xvY2FsXSxcbiAgICAgICAgICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbG9jYWxTdHJpbmcgPSBsb2NhbC50b1RyYW5zZm9ybVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IFN0cihsb2NhbCkgPT0gU3RyKHRoaXMubWF0cml4KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyKF8udHJhbnNmb3JtKSA6IGxvY2FsU3RyaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHBhcGEudHlwZSAhPSBcInN2Z1wiICYmIChwYXBhID0gcGFwYS5wYXJlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICBtcy5wdXNoKGV4dHJhY3RUcmFuc2Zvcm0ocGFwYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IG1zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZChtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbE1hdHJpeDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgIHRvdGFsTWF0cml4OiBtLFxuICAgICAgICAgICAgICAgIGxvY2FsTWF0cml4OiBsb2NhbCxcbiAgICAgICAgICAgICAgICBkaWZmTWF0cml4OiBnbG9iYWwuY2xvbmUoKS5hZGQobG9jYWwuaW52ZXJ0KCkpLFxuICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLnRvVHJhbnNmb3JtU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdG90YWw6IG0udG9UcmFuc2Zvcm1TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWxTdHJpbmcsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHByb3BTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzdHIgaW5zdGFuY2VvZiBTbmFwLk1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0c3RyO1xuICAgICAgICAgICAgdGhpcy5fLnRyYW5zZm9ybSA9IHRzdHIudG9UcmFuc2Zvcm1TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2Zvcm0odGhpcywgdHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtncmFkaWVudFRyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLm1hdHJpeH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMubm9kZSwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucGFyZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50J3MgcGFyZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXBwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBlbGVtZW50IHRvIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnR8U2V0KSBlbGVtZW50IHRvIGFwcGVuZFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWRkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuYXBwZW5kXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXBwZW5kID0gZWxwcm90by5hZGQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBlbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hZGQoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFwcGVuZFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBhcHBlbmQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICBlbC5hcHBlbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBwcmVwZW5kXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3Q7XG4gICAgICAgICAgICAgICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdC5hZnRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5wcmVwZW5kKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgdGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGQgJiYgdGhpcy5hZGQoKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kVG9cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFByZXBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBwcmVwZW5kIHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjaGlsZCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucHJlcGVuZFRvID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIGVsLnByZXBlbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYmVmb3JlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSBjdXJyZW50IG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IHRvIGluc2VydFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5iZWZvcmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgIGVsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGl0Lm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgaXQubm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgdG8gaW5zZXJ0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbnNlcnRCZWZvcmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgZWwubm9kZSk7XG4gICAgICAgIHRoaXMucGFwZXIgPSBlbC5wYXBlcjtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFyZW50KCkgJiYgZWwucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5zZXJ0QWZ0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIGVsLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCBlbC5ub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgdGhpcy5wYXBlciA9IGVsLnBhcGVyO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXJlbnQoKSAmJiBlbC5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICAgPSAoRWxlbWVudCkgdGhlIGRldGFjaGVkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXBlcjtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zZWxlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdhdGhlcnMgdGhlIG5lc3RlZCBARWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2V0IG9mIENTUyBzZWxlY3RvcnNcbiAgICAgKipcbiAgICAgLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3JcbiAgICAgPSAoRWxlbWVudCkgcmVzdWx0IG9mIHF1ZXJ5IHNlbGVjdGlvblxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihxdWVyeSkpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHYXRoZXJzIG5lc3RlZCBARWxlbWVudCBvYmplY3RzIG1hdGNoaW5nIHRoZSBnaXZlbiBzZXQgb2YgQ1NTIHNlbGVjdG9yc1xuICAgICAqKlxuICAgICAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvclxuICAgICA9IChTZXR8YXJyYXkpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5zZWxlY3RBbGwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIG5vZGVsaXN0ID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICAgICAgc2V0ID0gKFNuYXAuc2V0IHx8IEFycmF5KSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFzUFhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50IGFzIGEgYHB4YCB2YWx1ZSAobm90ICUsIGVtLCBldGMuKVxuICAgICAqKlxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSAjb3B0aW9uYWwgYXR0cmlidXRlIHZhbHVlXG4gICAgID0gKEVsZW1lbnQpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5hc1BYID0gZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cihhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gK3VuaXQycHgodGhpcywgYXR0ciwgdmFsdWUpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQudXNlKCk6IEkgc3VnZ2VzdCBhZGRpbmcgYSBub3RlIGFib3V0IGhvdyB0byBhY2Nlc3MgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhlIHJldHVybmVkIDx1c2U+IGluc3RhbnRpYXRlcy4gSXQncyBhIHBhcnQgb2YgU1ZHIHdpdGggd2hpY2ggb3JkaW5hcnkgd2ViIGRldmVsb3BlcnMgbWF5IGJlIGxlYXN0IGZhbWlsaWFyLlxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8dXNlPmAgZWxlbWVudCBsaW5rZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgYDx1c2U+YCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXNlLFxuICAgICAgICAgICAgaWQgPSB0aGlzLm5vZGUuaWQ7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICB0aGlzLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgIHVzZSA9IG1ha2UodGhpcy50eXBlLCB0aGlzLm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2UgPSBtYWtlKFwidXNlXCIsIHRoaXMubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAkKHVzZS5ub2RlLCB7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogXCIjXCIgKyBpZFxuICAgICAgICB9KTtcbiAgICAgICAgdXNlLm9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHVzZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpeGlkcyhlbCkge1xuICAgICAgICB2YXIgZWxzID0gZWwuc2VsZWN0QWxsKFwiKlwiKSxcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgdXJsID0gL15cXHMqdXJsXFwoKFwifCd8KSguKilcXDFcXClcXHMqJC8sXG4gICAgICAgICAgICBpZHMgPSBbXSxcbiAgICAgICAgICAgIHVzZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gdXJsdGVzdChpdCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICQoaXQubm9kZSwgbmFtZSk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsLm1hdGNoKHVybCk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsWzJdO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuY2hhckF0KCkgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdXNlc1t2YWxdID0gKHVzZXNbdmFsXSB8fCBbXSkuY29uY2F0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBhdHRyW25hbWVdID0gU25hcC51cmwoaWQpO1xuICAgICAgICAgICAgICAgICAgICAkKGl0Lm5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpbmt0ZXN0KGl0KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gJChpdC5ub2RlLCBcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB1c2VzW3ZhbF0gPSAodXNlc1t2YWxdIHx8IFtdKS5jb25jYXQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LmF0dHIoXCJ4bGluazpocmVmXCIsIFwiI1wiICsgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVscy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpdCA9IGVsc1tpXTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwiZmlsbFwiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJmaWx0ZXJcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcIm1hc2tcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcImNsaXAtcGF0aFwiKTtcbiAgICAgICAgICAgIGxpbmt0ZXN0KGl0KTtcbiAgICAgICAgICAgIHZhciBvbGRpZCA9ICQoaXQubm9kZSwgXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChvbGRpZCkge1xuICAgICAgICAgICAgICAgICQoaXQubm9kZSwge2lkOiBpdC5pZH0pO1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2xkOiBvbGRpZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZzID0gdXNlc1tpZHNbaV0ub2xkXTtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGZzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZnNbal0oaWRzW2ldLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xvbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZWxlbWVudCBhbmQgaW5zZXJ0cyBpdCBhZnRlciB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgY2xvbmVcbiAgICBcXCovXG4gICAgZWxwcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgaWYgKCQoY2xvbmUubm9kZSwgXCJpZFwiKSkge1xuICAgICAgICAgICAgJChjbG9uZS5ub2RlLCB7aWQ6IGNsb25lLmlkfSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4aWRzKGNsb25lKTtcbiAgICAgICAgY2xvbmUuaW5zZXJ0QWZ0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvRGVmc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTW92ZXMgZWxlbWVudCB0byB0aGUgc2hhcmVkIGA8ZGVmcz5gIGFyZWFcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50b0RlZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZzID0gZ2V0U29tZURlZnModGhpcyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b1BhdHRlcm5cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPHBhdHRlcm4+YCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICAqIFRvIGNyZWF0ZSBhIHBhdHRlcm4geW91IGhhdmUgdG8gc3BlY2lmeSB0aGUgcGF0dGVybiByZWN0OlxuICAgICAtIHggKHN0cmluZ3xudW1iZXIpXG4gICAgIC0geSAoc3RyaW5nfG51bWJlcilcbiAgICAgLSB3aWR0aCAoc3RyaW5nfG51bWJlcilcbiAgICAgLSBoZWlnaHQgKHN0cmluZ3xudW1iZXIpXG4gICAgID0gKEVsZW1lbnQpIHRoZSBgPHBhdHRlcm4+YCBlbGVtZW50XG4gICAgICogWW91IGNhbiB1c2UgcGF0dGVybiBsYXRlciBvbiBhcyBhbiBhcmd1bWVudCBmb3IgYGZpbGxgIGF0dHJpYnV0ZTpcbiAgICAgfCB2YXIgcCA9IHBhcGVyLnBhdGgoXCJNMTAtNS0xMCwxNU0xNSwwLDAsMTVNMC01LTIwLDE1XCIpLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgIHwgICAgICAgICBzdHJva2U6IFwiI2JhZGE1NVwiLFxuICAgICB8ICAgICAgICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgfCAgICAgfSkucGF0dGVybigwLCAwLCAxMCwgMTApLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDIwMCwgMjAwLCAxMDApO1xuICAgICB8IGMuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IHBcbiAgICAgfCB9KTtcbiAgICBcXCovXG4gICAgZWxwcm90by5wYXR0ZXJuID0gZWxwcm90by50b1BhdHRlcm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IG1ha2UoXCJwYXR0ZXJuXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiBcInhcIiBpbiB4KSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgd2lkdGggPSB4LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0geC5oZWlnaHQ7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG4gICAgICAgICQocC5ub2RlLCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgICAgIHZpZXdCb3g6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKFwiIFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4vLyBTSUVSUkEgRWxlbWVudC5tYXJrZXIoKTogY2xhcmlmeSB3aGF0IGEgcmVmZXJlbmNlIHBvaW50IGlzLiBFLmcuLCBoZWxwcyB5b3Ugb2Zmc2V0IHRoZSBvYmplY3QgZnJvbSBpdHMgZWRnZSBzdWNoIGFzIHdoZW4gY2VudGVyaW5nIGl0IG92ZXIgYSBwYXRoLlxuLy8gU0lFUlJBIEVsZW1lbnQubWFya2VyKCk6IEkgc3VnZ2VzdCB0aGUgbWV0aG9kIHNob3VsZCBhY2NlcHQgZGVmYXVsdCByZWZlcmVuY2UgcG9pbnQgdmFsdWVzLiAgUGVyaGFwcyBjZW50ZXJlZCB3aXRoIChyZWZYID0gd2lkdGgvMikgYW5kIChyZWZZID0gaGVpZ2h0LzIpPyBBbHNvLCBjb3VsZG4ndCBpdCBhc3N1bWUgdGhlIGVsZW1lbnQncyBjdXJyZW50IF93aWR0aF8gYW5kIF9oZWlnaHRfPyBBbmQgcGxlYXNlIHNwZWNpZnkgd2hhdCBfeF8gYW5kIF95XyBtZWFuOiBvZmZzZXRzPyBJZiBzbywgZnJvbSB3aGVyZT8gIENvdWxkbid0IHRoZXkgYWxzbyBiZSBhc3NpZ25lZCBkZWZhdWx0IHZhbHVlcz9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tYXJrZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPG1hcmtlcj5gIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgICogVG8gY3JlYXRlIGEgbWFya2VyIHlvdSBoYXZlIHRvIHNwZWNpZnkgdGhlIGJvdW5kaW5nIHJlY3QgYW5kIHJlZmVyZW5jZSBwb2ludDpcbiAgICAgLSB4IChudW1iZXIpXG4gICAgIC0geSAobnVtYmVyKVxuICAgICAtIHdpZHRoIChudW1iZXIpXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpXG4gICAgIC0gcmVmWCAobnVtYmVyKVxuICAgICAtIHJlZlkgKG51bWJlcilcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8bWFya2VyPmAgZWxlbWVudFxuICAgICAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgbWFya2VyIGxhdGVyIGFzIGFuIGFyZ3VtZW50IGZvciBgbWFya2VyLXN0YXJ0YCwgYG1hcmtlci1lbmRgLCBgbWFya2VyLW1pZGAsIGFuZCBgbWFya2VyYCBhdHRyaWJ1dGVzLiBUaGUgYG1hcmtlcmAgYXR0cmlidXRlIHBsYWNlcyB0aGUgbWFya2VyIGF0IGV2ZXJ5IHBvaW50IGFsb25nIHRoZSBwYXRoLCBhbmQgYG1hcmtlci1taWRgIHBsYWNlcyB0aGVtIGF0IGV2ZXJ5IHBvaW50IGV4Y2VwdCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAgICBcXCovXG4gICAgLy8gVE9ETyBhZGQgdXNhZ2UgZm9yIG1hcmtlcnNcbiAgICBlbHByb3RvLm1hcmtlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZWZYLCByZWZZKSB7XG4gICAgICAgIHZhciBwID0gbWFrZShcIm1hcmtlclwiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4geCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgcmVmWCA9IHgucmVmWCB8fCB4LmN4O1xuICAgICAgICAgICAgcmVmWSA9IHgucmVmWSB8fCB4LmN5O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICAkKHAubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgbWFya2VyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgbWFya2VySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBvcmllbnQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgcmVmWDogcmVmWCB8fCAwLFxuICAgICAgICAgICAgcmVmWTogcmVmWSB8fCAwLFxuICAgICAgICAgICAgaWQ6IHAuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHAubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIHZhciBlbGRhdGEgPSB7fTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIG9yIHJldHJpZXZlcyBnaXZlbiB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggZ2l2ZW4ga2V5LiAoRG9u4oCZdCBjb25mdXNlXG4gICAgICogd2l0aCBgZGF0YS1gIGF0dHJpYnV0ZXMpXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbyBARWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIC0ga2V5IChzdHJpbmcpIGtleSB0byBzdG9yZSBkYXRhXG4gICAgIC0gdmFsdWUgKGFueSkgI29wdGlvbmFsIHZhbHVlIHRvIHN0b3JlXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICAgKiBvciwgaWYgdmFsdWUgaXMgbm90IHNwZWNpZmllZDpcbiAgICAgPSAoYW55KSB2YWx1ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZm9yICh2YXIgaSA9IDAsIGkgPCA1LCBpKyspIHtcbiAgICAgfCAgICAgcGFwZXIuY2lyY2xlKDEwICsgMTUgKiBpLCAxMCwgMTApXG4gICAgIHwgICAgICAgICAgLmF0dHIoe2ZpbGw6IFwiIzAwMFwifSlcbiAgICAgfCAgICAgICAgICAuZGF0YShcImlcIiwgaSlcbiAgICAgfCAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICAgICAgICAgIGFsZXJ0KHRoaXMuZGF0YShcImlcIikpO1xuICAgICB8ICAgICAgICAgIH0pO1xuICAgICB8IH1cbiAgICBcXCovXG4gICAgZWxwcm90by5kYXRhID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlbGRhdGFbdGhpcy5pZF0gPSBlbGRhdGFbdGhpcy5pZF0gfHwge307XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgZXZlKFwic25hcC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGEsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKFNuYXAuaXMoa2V5LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4ga2V5KSBpZiAoa2V5W2hhc10oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhKGksIGtleVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlKFwic25hcC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGFba2V5XSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgIGV2ZShcInNuYXAuZGF0YS5zZXQuXCIgKyB0aGlzLmlkLCB0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhbiBlbGVtZW50IGJ5IGdpdmVuIGtleS5cbiAgICAgKiBJZiBrZXkgaXMgbm90IHByb3ZpZGVkLCByZW1vdmVzIGFsbCB0aGUgZGF0YSBvZiB0aGUgZWxlbWVudC5cbiAgICAgLSBrZXkgKHN0cmluZykgI29wdGlvbmFsIGtleVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGRhdGFbdGhpcy5pZF0gPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZGF0YVt0aGlzLmlkXSAmJiBkZWxldGUgZWxkYXRhW3RoaXMuaWRdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5vdXRlclNWR1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnQsIGVxdWl2YWxlbnQgdG8gSFRNTCdzIGBvdXRlckhUTUxgLlxuICAgICAqXG4gICAgICogU2VlIGFsc28gQEVsZW1lbnQuaW5uZXJTVkdcbiAgICAgPSAoc3RyaW5nKSBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9TdHJpbmdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBARWxlbWVudC5vdXRlclNWR1xuICAgIFxcKi9cbiAgICBlbHByb3RvLm91dGVyU1ZHID0gZWxwcm90by50b1N0cmluZyA9IHRvU3RyaW5nKDEpO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmlubmVyU1ZHXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudCdzIGNvbnRlbnRzLCBlcXVpdmFsZW50IHRvIEhUTUwncyBgaW5uZXJIVE1MYFxuICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmlubmVyU1ZHID0gdG9TdHJpbmcoKTtcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdHlwZSA/IFwiPFwiICsgdGhpcy50eXBlIDogXCJcIixcbiAgICAgICAgICAgICAgICBhdHRyID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgY2hsZCA9IHRoaXMubm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIFwiICsgYXR0cltpXS5uYW1lICsgJz1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJbaV0udmFsdWUucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCI+XCIpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gY2hsZC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGxkW2ldLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBjaGxkW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGxkW2ldLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSB3cmFwKGNobGRbaV0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiLz5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuYnRvYSkge1xuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCQm94KCksXG4gICAgICAgICAgICAgICAgc3ZnID0gU25hcC5mb3JtYXQoJzxzdmcgdmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB3aWR0aD1cInt3aWR0aH1cIiBoZWlnaHQ9XCJ7aGVpZ2h0fVwiIHZpZXdCb3g9XCJ7eH0ge3l9IHt3aWR0aH0ge2hlaWdodH1cIj57Y29udGVudHN9PC9zdmc+Jywge1xuICAgICAgICAgICAgICAgIHg6ICtiYi54LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgeTogK2JiLnkudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogK2JiLndpZHRoLnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiArYmIuaGVpZ2h0LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgY29udGVudHM6IHRoaXMub3V0ZXJTVkcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3ZnKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRnJhZ21lbnQuc2VsZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuc2VsZWN0XG4gICAgXFwqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5zZWxlY3QgPSBlbHByb3RvLnNlbGVjdDtcbiAgICAvKlxcXG4gICAgICogRnJhZ21lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgXFwqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5zZWxlY3RBbGwgPSBlbHByb3RvLnNlbGVjdEFsbDtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgRSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgaWYgKGIgPT0gbnVsbCAmJiBvYmplY3RUb1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBTVkdNYXRyaXhdXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYSA9IGEuYTtcbiAgICAgICAgICAgIHRoaXMuYiA9IGEuYjtcbiAgICAgICAgICAgIHRoaXMuYyA9IGEuYztcbiAgICAgICAgICAgIHRoaXMuZCA9IGEuZDtcbiAgICAgICAgICAgIHRoaXMuZSA9IGEuZTtcbiAgICAgICAgICAgIHRoaXMuZiA9IGEuZjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmEgPSArYTtcbiAgICAgICAgICAgIHRoaXMuYiA9ICtiO1xuICAgICAgICAgICAgdGhpcy5jID0gK2M7XG4gICAgICAgICAgICB0aGlzLmQgPSArZDtcbiAgICAgICAgICAgIHRoaXMuZSA9ICtlO1xuICAgICAgICAgICAgdGhpcy5mID0gK2Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmEgPSAxO1xuICAgICAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgICAgIHRoaXMuYyA9IDA7XG4gICAgICAgICAgICB0aGlzLmQgPSAxO1xuICAgICAgICAgICAgdGhpcy5lID0gMDtcbiAgICAgICAgICAgIHRoaXMuZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKGZ1bmN0aW9uIChtYXRyaXhwcm90bykge1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5hZGRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIEFkZHMgdGhlIGdpdmVuIG1hdHJpeCB0byBleGlzdGluZyBvbmVcbiAgICAgICAgIC0gYSAobnVtYmVyKVxuICAgICAgICAgLSBiIChudW1iZXIpXG4gICAgICAgICAtIGMgKG51bWJlcilcbiAgICAgICAgIC0gZCAobnVtYmVyKVxuICAgICAgICAgLSBlIChudW1iZXIpXG4gICAgICAgICAtIGYgKG51bWJlcilcbiAgICAgICAgICogb3JcbiAgICAgICAgIC0gbWF0cml4IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5hZGQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICAgICAgaWYgKGEgJiYgYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChhLmEsIGEuYiwgYS5jLCBhLmQsIGEuZSwgYS5mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhTmV3ID0gYSAqIHRoaXMuYSArIGIgKiB0aGlzLmMsXG4gICAgICAgICAgICAgICAgYk5ldyA9IGEgKiB0aGlzLmIgKyBiICogdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5lICs9IGUgKiB0aGlzLmEgKyBmICogdGhpcy5jO1xuICAgICAgICAgICAgdGhpcy5mICs9IGUgKiB0aGlzLmIgKyBmICogdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5jID0gYyAqIHRoaXMuYSArIGQgKiB0aGlzLmM7XG4gICAgICAgICAgICB0aGlzLmQgPSBjICogdGhpcy5iICsgZCAqIHRoaXMuZDtcblxuICAgICAgICAgICAgdGhpcy5hID0gYU5ldztcbiAgICAgICAgICAgIHRoaXMuYiA9IGJOZXc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgubXVsdExlZnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE11bHRpcGxpZXMgYSBwYXNzZWQgYWZmaW5lIHRyYW5zZm9ybSB0byB0aGUgbGVmdDogTSAqIHRoaXMuXG4gICAgICAgICAtIGEgKG51bWJlcilcbiAgICAgICAgIC0gYiAobnVtYmVyKVxuICAgICAgICAgLSBjIChudW1iZXIpXG4gICAgICAgICAtIGQgKG51bWJlcilcbiAgICAgICAgIC0gZSAobnVtYmVyKVxuICAgICAgICAgLSBmIChudW1iZXIpXG4gICAgICAgICAqIG9yXG4gICAgICAgICAtIG1hdHJpeCAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgTWF0cml4LnByb3RvdHlwZS5tdWx0TGVmdCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICBpZiAoYSAmJiBhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdExlZnQoYS5hLCBhLmIsIGEuYywgYS5kLCBhLmUsIGEuZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYU5ldyA9IGEgKiB0aGlzLmEgKyBjICogdGhpcy5iLFxuICAgICAgICAgICAgICAgIGNOZXcgPSBhICogdGhpcy5jICsgYyAqIHRoaXMuZCxcbiAgICAgICAgICAgICAgICBlTmV3ID0gYSAqIHRoaXMuZSArIGMgKiB0aGlzLmYgKyBlO1xuICAgICAgICAgICAgdGhpcy5iID0gYiAqIHRoaXMuYSArIGQgKiB0aGlzLmI7XG4gICAgICAgICAgICB0aGlzLmQgPSBiICogdGhpcy5jICsgZCAqIHRoaXMuZDtcbiAgICAgICAgICAgIHRoaXMuZiA9IGIgKiB0aGlzLmUgKyBkICogdGhpcy5mICsgZjtcblxuICAgICAgICAgICAgdGhpcy5hID0gYU5ldztcbiAgICAgICAgICAgIHRoaXMuYyA9IGNOZXc7XG4gICAgICAgICAgICB0aGlzLmUgPSBlTmV3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmludmVydFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmludmVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeCA9IG1lLmEgKiBtZS5kIC0gbWUuYiAqIG1lLmM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtZS5kIC8geCwgLW1lLmIgLyB4LCAtbWUuYyAvIHgsIG1lLmEgLyB4LCAobWUuYyAqIG1lLmYgLSBtZS5kICogbWUuZSkgLyB4LCAobWUuYiAqIG1lLmUgLSBtZS5hICogbWUuZikgLyB4KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguY2xvbmVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnRyYW5zbGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogVHJhbnNsYXRlIHRoZSBtYXRyaXhcbiAgICAgICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICAgLSB5IChudW1iZXIpIHZlcnRpY2FsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmUgKz0geCAqIHRoaXMuYSArIHkgKiB0aGlzLmM7XG4gICAgICAgICAgICB0aGlzLmYgKz0geCAqIHRoaXMuYiArIHkgKiB0aGlzLmQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2NhbGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNjYWxlcyB0aGUgbWF0cml4XG4gICAgICAgICAtIHggKG51bWJlcikgYW1vdW50IHRvIGJlIHNjYWxlZCwgd2l0aCBgMWAgcmVzdWx0aW5nIGluIG5vIGNoYW5nZVxuICAgICAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgdG8gc2NhbGUgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMuIChPdGhlcndpc2UgYHhgIGFwcGxpZXMgdG8gYm90aCBheGVzLilcbiAgICAgICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gc2NhbGVcbiAgICAgICAgIC0gY3kgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHNjYWxlXG4gICAgICAgICAqIERlZmF1bHQgY3gsIGN5IGlzIHRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XG4gICAgICAgICAgICB5ID09IG51bGwgJiYgKHkgPSB4KTtcbiAgICAgICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIHRoaXMuYSAqPSB4O1xuICAgICAgICAgICAgdGhpcy5iICo9IHg7XG4gICAgICAgICAgICB0aGlzLmMgKj0geTtcbiAgICAgICAgICAgIHRoaXMuZCAqPSB5O1xuICAgICAgICAgICAgKGN4IHx8IGN5KSAmJiB0aGlzLnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgucm90YXRlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBtYXRyaXhcbiAgICAgICAgIC0gYSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvbiwgaW4gZGVncmVlc1xuICAgICAgICAgLSB4IChudW1iZXIpIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgICAgICAtIHkgKG51bWJlcikgdmVydGljYWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ucm90YXRlID0gZnVuY3Rpb24gKGEsIHgsIHkpIHtcbiAgICAgICAgICAgIGEgPSBTbmFwLnJhZChhKTtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgdmFyIGNvcyA9ICttYXRoLmNvcyhhKS50b0ZpeGVkKDkpLFxuICAgICAgICAgICAgICAgIHNpbiA9ICttYXRoLnNpbihhKS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoY29zLCBzaW4sIC1zaW4sIGNvcywgeCwgeSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoMSwgMCwgMCwgMSwgLXgsIC15KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1hcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNrZXdzIHRoZSBtYXRyaXggYWxvbmcgdGhlIHgtYXhpc1xuICAgICAgICAgLSB4IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHgtYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2tld1ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1lcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNrZXdzIHRoZSBtYXRyaXggYWxvbmcgdGhlIHktYXhpc1xuICAgICAgICAgLSB5IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHktYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2tld1kgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tldygwLCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1xuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogU2tld3MgdGhlIG1hdHJpeFxuICAgICAgICAgLSB5IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHktYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgICAtIHggKG51bWJlcikgQW5nbGUgdG8gc2tldyBhbG9uZyB0aGUgeC1heGlzIChpbiBkZWdyZWVzKS5cbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5za2V3ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgeCA9IFNuYXAucmFkKHgpO1xuICAgICAgICAgICAgeSA9IFNuYXAucmFkKHkpO1xuICAgICAgICAgICAgdmFyIGMgPSBtYXRoLnRhbih4KS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdmFyIGIgPSBtYXRoLnRhbih5KS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKDEsIGIsIGMsIDEsIDAsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC54XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHggY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueVxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmEgKyB5ICogdGhpcy5jICsgdGhpcy5lO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC55XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHkgY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueFxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmIgKyB5ICogdGhpcy5kICsgdGhpcy5mO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzW1N0ci5mcm9tQ2hhckNvZGUoOTcgKyBpKV0udG9GaXhlZCg0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJtYXRyaXgoXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV0uam9pbigpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLm9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5lLnRvRml4ZWQoNCksIHRoaXMuZi50b0ZpeGVkKDQpXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbm9ybShhKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUoYSkge1xuICAgICAgICAgICAgdmFyIG1hZyA9IG1hdGguc3FydChub3JtKGEpKTtcbiAgICAgICAgICAgIGFbMF0gJiYgKGFbMF0gLz0gbWFnKTtcbiAgICAgICAgICAgIGFbMV0gJiYgKGFbMV0gLz0gbWFnKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5kZXRlcm1pbmFudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogRmluZHMgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgICAgID0gKG51bWJlcikgZGV0ZXJtaW5hbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmEgKiB0aGlzLmQgLSB0aGlzLmIgKiB0aGlzLmM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNwbGl0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTcGxpdHMgbWF0cml4IGludG8gcHJpbWl0aXZlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgICAgICBvIGR4IChudW1iZXIpIHRyYW5zbGF0aW9uIGJ5IHhcbiAgICAgICAgIG8gZHkgKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeVxuICAgICAgICAgbyBzY2FsZXggKG51bWJlcikgc2NhbGUgYnkgeFxuICAgICAgICAgbyBzY2FsZXkgKG51bWJlcikgc2NhbGUgYnkgeVxuICAgICAgICAgbyBzaGVhciAobnVtYmVyKSBzaGVhclxuICAgICAgICAgbyByb3RhdGUgKG51bWJlcikgcm90YXRpb24gaW4gZGVnXG4gICAgICAgICBvIGlzU2ltcGxlIChib29sZWFuKSBjb3VsZCBpdCBiZSByZXByZXNlbnRlZCB2aWEgc2ltcGxlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb25cbiAgICAgICAgICAgIG91dC5keCA9IHRoaXMuZTtcbiAgICAgICAgICAgIG91dC5keSA9IHRoaXMuZjtcblxuICAgICAgICAgICAgLy8gc2NhbGUgYW5kIHNoZWFyXG4gICAgICAgICAgICB2YXIgcm93ID0gW1t0aGlzLmEsIHRoaXMuYl0sIFt0aGlzLmMsIHRoaXMuZF1dO1xuICAgICAgICAgICAgb3V0LnNjYWxleCA9IG1hdGguc3FydChub3JtKHJvd1swXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1swXSk7XG5cbiAgICAgICAgICAgIG91dC5zaGVhciA9IHJvd1swXVswXSAqIHJvd1sxXVswXSArIHJvd1swXVsxXSAqIHJvd1sxXVsxXTtcbiAgICAgICAgICAgIHJvd1sxXSA9IFtyb3dbMV1bMF0gLSByb3dbMF1bMF0gKiBvdXQuc2hlYXIsIHJvd1sxXVsxXSAtIHJvd1swXVsxXSAqIG91dC5zaGVhcl07XG5cbiAgICAgICAgICAgIG91dC5zY2FsZXkgPSBtYXRoLnNxcnQobm9ybShyb3dbMV0pKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShyb3dbMV0pO1xuICAgICAgICAgICAgb3V0LnNoZWFyIC89IG91dC5zY2FsZXk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVybWluYW50KCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb3V0LnNjYWxleCA9IC1vdXQuc2NhbGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgICAgdmFyIHNpbiA9IHJvd1swXVsxXSxcbiAgICAgICAgICAgICAgICBjb3MgPSByb3dbMV1bMV07XG4gICAgICAgICAgICBpZiAoY29zIDwgMCkge1xuICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSBTbmFwLmRlZyhtYXRoLmFjb3MoY29zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IDM2MCAtIG91dC5yb3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gU25hcC5kZWcobWF0aC5hc2luKHNpbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXQuaXNTaW1wbGUgPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmIChvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpIHx8ICFvdXQucm90YXRlKTtcbiAgICAgICAgICAgIG91dC5pc1N1cGVyU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiBvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgb3V0Lm5vUm90YXRpb24gPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgudG9UcmFuc2Zvcm1TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgdHJhbnNmb3JtIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gbWF0cml4XG4gICAgICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmdcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by50b1RyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uIChzaG9ydGVyKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNob3J0ZXIgfHwgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKCErcy5zaGVhci50b0ZpeGVkKDkpKSB7XG4gICAgICAgICAgICAgICAgcy5zY2FsZXggPSArcy5zY2FsZXgudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICBzLnNjYWxleSA9ICtzLnNjYWxleS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHMucm90YXRlID0gK3Mucm90YXRlLnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICAocy5keCB8fCBzLmR5ID8gXCJ0XCIgKyBbK3MuZHgudG9GaXhlZCg0KSwgK3MuZHkudG9GaXhlZCg0KV0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5yb3RhdGUgPyBcInJcIiArIFsrcy5yb3RhdGUudG9GaXhlZCg0KSwgMCwgMF0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5zY2FsZXggIT0gMSB8fCBzLnNjYWxleSAhPSAxID8gXCJzXCIgKyBbcy5zY2FsZXgsIHMuc2NhbGV5LCAwLCAwXSA6IEUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoTWF0cml4LnByb3RvdHlwZSk7XG4gICAgLypcXFxuICAgICAqIFNuYXAuTWF0cml4XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNYXRyaXggY29uc3RydWN0b3IsIGV4dGVuZCBvbiB5b3VyIG93biByaXNrLlxuICAgICAqIFRvIGNyZWF0ZSBtYXRyaWNlcyB1c2UgQFNuYXAubWF0cml4LlxuICAgIFxcKi9cbiAgICBTbmFwLk1hdHJpeCA9IE1hdHJpeDtcbiAgICAvKlxcXG4gICAgICogU25hcC5tYXRyaXhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xuICAgICAtIGEgKG51bWJlcilcbiAgICAgLSBiIChudW1iZXIpXG4gICAgIC0gYyAobnVtYmVyKVxuICAgICAtIGQgKG51bWJlcilcbiAgICAgLSBlIChudW1iZXIpXG4gICAgIC0gZiAobnVtYmVyKVxuICAgICAqIG9yXG4gICAgIC0gc3ZnTWF0cml4IChTVkdNYXRyaXgpXG4gICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgIFxcKi9cbiAgICBTbmFwLm1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwLFxuICAgICAgICBpcyA9IFNuYXAuaXMsXG4gICAgICAgIGdldFNvbWVEZWZzID0gU25hcC5fLmdldFNvbWVEZWZzLFxuICAgICAgICByZVVSTFZhbHVlID0gL151cmxcXCgoWydcIl0/KShbXildKylcXDFcXCkkLyxcbiAgICAgICAgJCA9IFNuYXAuXy4kLFxuICAgICAgICBVUkwgPSBTbmFwLnVybCxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBzZXBhcmF0b3IgPSBTbmFwLl8uc2VwYXJhdG9yLFxuICAgICAgICBFID0gXCJcIjtcbiAgICAvKlxcXG4gICAgICogU25hcC5kZXVybFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVW53cmFwcyBwYXRoIGZyb20gYFwidXJsKDxwYXRoPilcImAuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgdXJsIHBhdGhcbiAgICAgPSAoc3RyaW5nKSB1bndyYXBwZWQgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLmRldXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBTdHJpbmcodmFsdWUpLm1hdGNoKHJlVVJMVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzID8gcmVzWzJdIDogdmFsdWU7XG4gICAgfVxuICAgIC8vIEF0dHJpYnV0ZXMgZXZlbnQgaGFuZGxlcnNcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXNrXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCAmJiB2YWx1ZS5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBnZXRTb21lRGVmcyh0aGlzKS5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwibWFza1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IG1ha2UoXCJtYXNrXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBtYXNrLm5vZGUuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhbWFzay5ub2RlLmlkICYmICQobWFzay5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IG1hc2suaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBtYXNrOiBVUkwobWFzay5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKGZ1bmN0aW9uIChjbGlwSXQpIHtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFwiLCBjbGlwSXQpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5jbGlwLXBhdGhcIiwgY2xpcEl0KTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFBhdGhcIiwgY2xpcEl0KTtcbiAgICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgY2xpcCxcbiAgICAgICAgICAgICAgICBub2RlID0gdmFsdWUubm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiY2xpcFBhdGhcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gbmV3IEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJzdmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xpcCkge1xuICAgICAgICAgICAgICAgIGNsaXAgPSBtYWtlKFwiY2xpcFBhdGhcIiwgZ2V0U29tZURlZnModGhpcykpO1xuICAgICAgICAgICAgICAgIGNsaXAubm9kZS5hcHBlbmRDaGlsZCh2YWx1ZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAhY2xpcC5ub2RlLmlkICYmICQoY2xpcC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjbGlwLmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgICAgIFwiY2xpcC1wYXRoXCI6IFVSTChjbGlwLm5vZGUuaWQgfHwgY2xpcC5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGZpbGxTdHJva2UobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQgJiYgdmFsdWUubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicmFkaWFsR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwibGluZWFyR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicGF0dGVyblwiKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGdldFNvbWVEZWZzKHRoaXMpLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXAodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwicmFkaWFsR3JhZGllbnRcIiB8fCB2YWx1ZS50eXBlID09IFwibGluZWFyR3JhZGllbnRcIlxuICAgICAgICAgICAgICAgICAgIHx8IHZhbHVlLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxsID0gVVJMKHZhbHVlLm5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSB2YWx1ZS5hdHRyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsbCA9IFNuYXAuY29sb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFkID0gU25hcChnZXRTb21lRGVmcyh0aGlzKS5vd25lclNWR0VsZW1lbnQpLmdyYWRpZW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ3JhZC5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChncmFkLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGdyYWQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgPSBVUkwoZ3JhZC5ub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSBTdHIoZmlsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGZpbGw7XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwgYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLnN0eWxlW25hbWVdID0gRTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZmlsbFwiLCBmaWxsU3Ryb2tlKFwiZmlsbFwiKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuc3Ryb2tlXCIsIGZpbGxTdHJva2UoXCJzdHJva2VcIikpO1xuICAgIHZhciBncmFkcmcgPSAvXihbbHJdKSg/OlxcKChbXildKilcXCkpPyguKikkL2k7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdyYWQucGFyc2VcIiwgZnVuY3Rpb24gcGFyc2VHcmFkKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBTdHIoc3RyaW5nKTtcbiAgICAgICAgdmFyIHRva2VucyA9IHN0cmluZy5tYXRjaChncmFkcmcpO1xuICAgICAgICBpZiAoIXRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlbnNbMV0sXG4gICAgICAgICAgICBwYXJhbXMgPSB0b2tlbnNbMl0sXG4gICAgICAgICAgICBzdG9wcyA9IHRva2Vuc1szXTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNwbGl0KC9cXHMqLFxccyovKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gK2VsID09IGVsID8gK2VsIDogZWw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PSAxICYmIHBhcmFtc1swXSA9PSAwKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcyA9IHN0b3BzLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgc3RvcHMgPSBzdG9wcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGVsWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVsWzFdKSB7XG4gICAgICAgICAgICAgICAgb3V0Lm9mZnNldCA9IHBhcnNlRmxvYXQoZWxbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZW4gPSBzdG9wcy5sZW5ndGgsXG4gICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgZnVuY3Rpb24gc2VlZChpLCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gKGVuZCAtIHN0YXJ0KSAvIChpIC0gaik7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gajsgayA8IGk7IGsrKykge1xuICAgICAgICAgICAgICAgIHN0b3BzW2tdLm9mZnNldCA9ICsoK3N0YXJ0ICsgc3RlcCAqIChrIC0gaikpLnRvRml4ZWQoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBpZiAoXCJvZmZzZXRcIiBpbiBzdG9wc1tpXSkge1xuICAgICAgICAgICAgc2VlZChpLCBzdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BzW2xlbl0ub2Zmc2V0ID0gc3RvcHNbbGVuXS5vZmZzZXQgfHwgMTAwO1xuICAgICAgICBzZWVkKGxlbiwgc3RvcHNbbGVuXS5vZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgc3RvcHM6IHN0b3BzXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5kXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAoaXModmFsdWUsIFwiYXJyYXlcIikgJiYgaXModmFsdWVbMF0sIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9bcnVvXS9pKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBTbmFwLnBhdGgudG9BYnNvbHV0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtkOiB2YWx1ZX0pO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFsdWUgPSBTdHIodmFsdWUpO1xuICAgICAgICB2YXIgdHh0ID0gZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHR4dCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnBhdGhcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMuYXR0cih7ZDogdmFsdWV9KTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xhc3NcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IHZhbHVlO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci52aWV3Qm94XCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdmI7XG4gICAgICAgIGlmIChpcyh2YWx1ZSwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZiID0gW3ZhbHVlLngsIHZhbHVlLnksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKHZhbHVlLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YiA9IHZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogdmJcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odmFsdWUpO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5yXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICByeDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcnk6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGlkLCB0cCwgbm9kZTtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy50ZXh0UGF0aCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHAubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0cC5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXModmFsdWUsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZnMgPSBnZXRTb21lRGVmcyh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHdyYXAoZGVmcy5wYXJlbnROb2RlKS5wYXRoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgubm9kZSk7XG4gICAgICAgICAgICAgICAgaWQgPSBwYXRoLmlkO1xuICAgICAgICAgICAgICAgIHBhdGguYXR0cih7aWQ6IGlkfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmF0dHIoe2lkOiBpZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdHAgPSB0aGlzLnRleHRQYXRoO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRwLmF0dHIoe1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHAgPSAkKFwidGV4dFBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0cCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFBhdGggPSB3cmFwKHRwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIudGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgdHVuZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9ICQoXCJ0c3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGNodW5rLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZENoaWxkKHR1bmVyKGNodW5rW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQ2hpbGQoZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUoY2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQubm9ybWFsaXplICYmIG91dC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0dW5lZCA9IHR1bmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHdoaWxlICh0dW5lZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0dW5lZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBmdW5jdGlvbiBzZXRGb250U2l6ZSh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAodmFsdWUgPT0gK3ZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLmZvbnRTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZvbnRTaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZm9udC1zaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG5cblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRQYXRoO1xuICAgIH0pKC0xKTtcbiAgICAvLyBNYXJrZXJzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdsb2IuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFya2VyLVwiICsgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTbmFwKGdsb2IuZG9jLmdldEVsZW1lbnRCeUlkKHN0eWxlLm1hdGNoKHJlVVJMVmFsdWUpWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIoZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFwibWFya2VyXCIgKyBlbmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiIHx8ICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcIm1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHZhbHVlLm5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVtuYW1lXSA9IFVSTChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1lbmRcIiwgZ2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlckVuZFwiLCBnZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyLXN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlclN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1taWRcIiwgZ2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlck1pZFwiLCBnZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLWVuZFwiLCBzZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyRW5kXCIsIHNldHRlcihcImVuZFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXItc3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyU3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLW1pZFwiLCBzZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyTWlkXCIsIHNldHRlcihcIm1pZFwiKSkoLTEpO1xuICAgIH0oKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJyZWN0XCIgJiYgJCh0aGlzLm5vZGUsIFwicnhcIikgPT0gJCh0aGlzLm5vZGUsIFwicnlcIikpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUsIFwicnhcIik7XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gdGV4dEV4dHJhY3Qobm9kZSkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpLnRhZ05hbWUgPT0gXCJ0c3BhblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIGNoaS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh0ZXh0RXh0cmFjdChjaGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB0ZXh0RXh0cmFjdCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG91dC5sZW5ndGggPT0gMSA/IG91dFswXSA6IG91dDtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbGxcIiwgZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV2ZShcInNuYXAudXRpbC5nZXRhdHRyLmZpbGxcIiwgdGhpcywgdHJ1ZSkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBTbmFwKFNuYXAuZGV1cmwodmFsdWUpKSB8fCB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuc3Ryb2tlXCIsIGZ1bmN0aW9uIChpbnRlcm5hbCkge1xuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5zdHJva2VcIiwgdGhpcywgdHJ1ZSkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBTbmFwKFNuYXAuZGV1cmwodmFsdWUpKSB8fCB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudmlld0JveFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciB2YiA9ICQodGhpcy5ub2RlLCBcInZpZXdCb3hcIik7XG4gICAgICAgIGlmICh2Yikge1xuICAgICAgICAgICAgdmIgPSB2Yi5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goK3ZiWzBdLCArdmJbMV0sICt2YlsyXSwgK3ZiWzNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5wb2ludHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9ICQodGhpcy5ub2RlLCBcInBvaW50c1wiKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIucGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZFwiKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmNsYXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gZ2V0Rm9udFNpemUoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGUuZm9udFNpemU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZvbnRTaXplXCIsIGdldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuZm9udC1zaXplXCIsIGdldEZvbnRTaXplKSgtMSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciByZ05vdFNwYWNlID0gL1xcUysvZyxcbiAgICAgICAgcmdCYWRTcGFjZSA9IC9bXFx0XFxyXFxuXFxmXS9nLFxuICAgICAgICByZ1RyaW0gPSAvKF5cXHMrfFxccyskKS9nLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hZGRDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgY2xhc3MgbmFtZSBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgICAqKlxuICAgICA9IChFbGVtZW50KSBvcmlnaW5hbCBlbGVtZW50LlxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFkZENsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gU3RyKHZhbHVlIHx8IFwiXCIpLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgZWxlbSA9IHRoaXMubm9kZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwsXG4gICAgICAgICAgICBjdXJDbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIGNsYXp6LFxuICAgICAgICAgICAgZmluYWxWYWx1ZTtcblxuICAgICAgICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAoIX5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5wdXNoKGNsYXp6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBjdXJDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUuYmFzZVZhbCA9IGZpbmFsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBTdHIodmFsdWUgfHwgXCJcIikubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgY2xhenosXG4gICAgICAgICAgICBmaW5hbFZhbHVlO1xuICAgICAgICBpZiAoY3VyQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGN1ckNsYXNzZXMuam9pbihcIiBcIik7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lICE9IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmhhc0NsYXNzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGVsZW1lbnQgaGFzIGEgZ2l2ZW4gY2xhc3MgbmFtZSBpbiB0aGUgbGlzdCBvZiBjbGFzcyBuYW1lcyBhcHBsaWVkIHRvIGl0LlxuICAgICAtIHZhbHVlIChzdHJpbmcpIGNsYXNzIG5hbWVcbiAgICAgKipcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHRoZSBlbGVtZW50IGhhcyBnaXZlbiBjbGFzc1xuICAgIFxcKi9cbiAgICBlbHByb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW107XG4gICAgICAgIHJldHVybiAhIX5jdXJDbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9nZ2xlQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZCBvciByZW1vdmUgb25lIG9yIG1vcmUgY2xhc3NlcyBmcm9tIHRoZSBlbGVtZW50LCBkZXBlbmRpbmcgb24gZWl0aGVyXG4gICAgICogdGhlIGNsYXNz4oCZcyBwcmVzZW5jZSBvciB0aGUgdmFsdWUgb2YgdGhlIGBmbGFnYCBhcmd1bWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgIC0gZmxhZyAoYm9vbGVhbikgdmFsdWUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNsYXNzIHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUsIGZsYWcpIHtcbiAgICAgICAgaWYgKGZsYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NlcyA9ICh2YWx1ZSB8fCBcIlwiKS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsLFxuICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBjbGF6eixcbiAgICAgICAgICAgIGZpbmFsVmFsdWU7XG4gICAgICAgIGogPSAwO1xuICAgICAgICB3aGlsZSAoY2xhenogPSBjbGFzc2VzW2orK10pIHtcbiAgICAgICAgICAgIHBvcyA9IGN1ckNsYXNzZXMuaW5kZXhPZihjbGF6eik7XG4gICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMucHVzaChjbGF6eik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbFZhbHVlID0gY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0ge1xuICAgICAgICAgICAgXCIrXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgeTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCItXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIvXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4IC8geTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICogeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgcmVVbml0ID0gL1thLXpdKyQvaSxcbiAgICAgICAgcmVBZGRvbiA9IC9eXFxzKihbK1xcLVxcLypdKVxccyo9XFxzKihbXFxkLmVFK1xcLV0rKVxccyooW15cXGRcXHNdKyk/XFxzKiQvO1xuICAgIGZ1bmN0aW9uIGdldE51bWJlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VW5pdCh1bml0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gK3ZhbC50b0ZpeGVkKDMpICsgdW5pdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHJcIiwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgcGx1cyA9IFN0cih2YWwpLm1hdGNoKHJlQWRkb24pO1xuICAgICAgICBpZiAocGx1cykge1xuICAgICAgICAgICAgdmFyIGV2bnQgPSBldmUubnQoKSxcbiAgICAgICAgICAgICAgICBuYW1lID0gZXZudC5zdWJzdHJpbmcoZXZudC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKSxcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5hdHRyKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0ciA9IHt9O1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciB1bml0ID0gcGx1c1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW3BsdXNbMV1dO1xuICAgICAgICAgICAgaWYgKGFVbml0ICYmIGFVbml0ID09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvcChwYXJzZUZsb2F0KGEpLCArcGx1c1syXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmFzUFgobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFsID0gb3AodGhpcy5hc1BYKG5hbWUpLCB0aGlzLmFzUFgobmFtZSwgcGx1c1syXSArIHVuaXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihhKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXRyW25hbWVdID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5hdHRyKGF0cik7XG4gICAgICAgIH1cbiAgICB9KSgtMTApO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5lcXVhbFwiLCBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICB2YXIgQSwgQiwgYSA9IFN0cih0aGlzLmF0dHIobmFtZSkgfHwgXCJcIiksXG4gICAgICAgICAgICBlbCA9IHRoaXMsXG4gICAgICAgICAgICBicGx1cyA9IFN0cihiKS5tYXRjaChyZUFkZG9uKTtcbiAgICAgICAgaWYgKGJwbHVzKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBicGx1c1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW2JwbHVzWzFdXTtcbiAgICAgICAgICAgIGlmIChhVW5pdCAmJiBhVW5pdCA9PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcGFyc2VGbG9hdChhKSxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9wKHBhcnNlRmxvYXQoYSksICticGx1c1syXSksXG4gICAgICAgICAgICAgICAgICAgIGY6IGdldFVuaXQoYVVuaXQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuYXNQWChuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBhLFxuICAgICAgICAgICAgICAgICAgICB0bzogb3AoYSwgdGhpcy5hc1BYKG5hbWUsIGJwbHVzWzJdICsgdW5pdCkpLFxuICAgICAgICAgICAgICAgICAgICBmOiBnZXROdW1iZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoLTEwKTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIHByb3RvID0gUGFwZXIucHJvdG90eXBlLFxuICAgICAgICBpcyA9IFNuYXAuaXM7XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnJlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqXG4gICAgICogRHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodFxuICAgICAtIHJ4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHJhZGl1cyBmb3Igcm91bmRlZCBjb3JuZXJzLCBkZWZhdWx0IGlzIDBcbiAgICAgLSByeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgcmFkaXVzIGZvciByb3VuZGVkIGNvcm5lcnMsIGRlZmF1bHQgaXMgcnggb3IgMFxuICAgICA9IChvYmplY3QpIHRoZSBgcmVjdGAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gcmVndWxhciByZWN0YW5nbGVcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnJlY3QoMTAsIDEwLCA1MCwgNTApO1xuICAgICB8IC8vIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVyc1xuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCg0MCwgNDAsIDUwLCA1MCwgMTApO1xuICAgIFxcKi9cbiAgICBwcm90by5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHJ4LCByeSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIHggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIucnggPSByeDtcbiAgICAgICAgICAgICAgICBhdHRyLnJ5ID0gcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJyZWN0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNpcmNsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBjaXJjbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHIgKG51bWJlcikgcmFkaXVzXG4gICAgID0gKG9iamVjdCkgdGhlIGBjaXJjbGVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDUwLCA1MCwgNDApO1xuICAgIFxcKi9cbiAgICBwcm90by5jaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5LCByKSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAoaXMoY3gsIFwib2JqZWN0XCIpICYmIGN4ID09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICAgIGF0dHIgPSBjeDtcbiAgICAgICAgfSBlbHNlIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcImNpcmNsZVwiLCBhdHRyKTtcbiAgICB9O1xuXG4gICAgdmFyIHByZWxvYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3JjLCBmKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gZ2xvYi5kb2MuY3JlYXRlRWxlbWVudChcImltZ1wiKSxcbiAgICAgICAgICAgICAgICBib2R5ID0gZ2xvYi5kb2MuYm9keTtcbiAgICAgICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZi5jYWxsKGltZyk7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmltYWdlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQbGFjZXMgYW4gaW1hZ2Ugb24gdGhlIHN1cmZhY2VcbiAgICAgKipcbiAgICAgLSBzcmMgKHN0cmluZykgVVJJIG9mIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgLSB4IChudW1iZXIpIHggb2Zmc2V0IHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IG9mZnNldCBwb3NpdGlvblxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgICAtIGhlaWdodCAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAgID0gKG9iamVjdCkgdGhlIGBpbWFnZWAgZWxlbWVudFxuICAgICAqIG9yXG4gICAgID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUgYGltYWdlYFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5pbWFnZShcImFwcGxlLnBuZ1wiLCAxMCwgMTAsIDgwLCA4MCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmltYWdlID0gZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsKFwiaW1hZ2VcIik7XG4gICAgICAgIGlmIChpcyhzcmMsIFwib2JqZWN0XCIpICYmIFwic3JjXCIgaW4gc3JjKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHNyYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSB7XG4gICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IHNyYyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LnggPSB4O1xuICAgICAgICAgICAgICAgIHNldC55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc2V0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZChzcmMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZWxsaXBzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYW4gZWxsaXBzZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0gcnggKG51bWJlcikgaG9yaXpvbnRhbCByYWRpdXNcbiAgICAgLSByeSAobnVtYmVyKSB2ZXJ0aWNhbCByYWRpdXNcbiAgICAgPSAob2JqZWN0KSB0aGUgYGVsbGlwc2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuZWxsaXBzZSg1MCwgNTAsIDQwLCAyMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmVsbGlwc2UgPSBmdW5jdGlvbiAoY3gsIGN5LCByeCwgcnkpIHtcbiAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgIGlmIChpcyhjeCwgXCJvYmplY3RcIikgJiYgY3ggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IGN4O1xuICAgICAgICB9IGVsc2UgaWYgKGN4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPXtcbiAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICAgICAgICByeTogcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJlbGxpcHNlXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIFBhcGVyLnBhdGgoKTogVW5jbGVhciBmcm9tIHRoZSBsaW5rIHdoYXQgYSBDYXRtdWxsLVJvbSBjdXJ2ZXRvIGlzLCBhbmQgd2h5IGl0IHdvdWxkIG1ha2UgbGlmZSBhbnkgZWFzaWVyLlxuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wYXRoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxwYXRoPmAgZWxlbWVudCB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIHRoZSBwYXRoJ3MgZGVmaW5pdGlvblxuICAgICAtIHBhdGhTdHJpbmcgKHN0cmluZykgI29wdGlvbmFsIHBhdGggc3RyaW5nIGluIFNWRyBmb3JtYXRcbiAgICAgKiBQYXRoIHN0cmluZyBjb25zaXN0cyBvZiBvbmUtbGV0dGVyIGNvbW1hbmRzLCBmb2xsb3dlZCBieSBjb21tYSBzZXByYXJhdGVkIGFyZ3VtZW50cyBpbiBudW1lcmljYWwgZm9ybS4gRXhhbXBsZTpcbiAgICAgfCBcIk0xMCwyMEwzMCw0MFwiXG4gICAgICogVGhpcyBleGFtcGxlIGZlYXR1cmVzIHR3byBjb21tYW5kczogYE1gLCB3aXRoIGFyZ3VtZW50cyBgKDEwLCAyMClgIGFuZCBgTGAgd2l0aCBhcmd1bWVudHMgYCgzMCwgNDApYC4gVXBwZXJjYXNlIGxldHRlciBjb21tYW5kcyBleHByZXNzIGNvb3JkaW5hdGVzIGluIGFic29sdXRlIHRlcm1zLCB3aGlsZSBsb3dlcmNhc2UgY29tbWFuZHMgZXhwcmVzcyB0aGVtIGluIHJlbGF0aXZlIHRlcm1zIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZGVjbGFyZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgIyA8cD5IZXJlIGlzIHNob3J0IGxpc3Qgb2YgY29tbWFuZHMgYXZhaWxhYmxlLCBmb3IgbW9yZSBkZXRhaWxzIHNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcIiB0aXRsZT1cIkRldGFpbHMgb2YgYSBwYXRoJ3MgZGF0YSBhdHRyaWJ1dGUncyBmb3JtYXQgYXJlIGRlc2NyaWJlZCBpbiB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXCI+U1ZHIHBhdGggc3RyaW5nIGZvcm1hdDwvYT4gb3IgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NWRy9UdXRvcmlhbC9QYXRoc1wiPmFydGljbGUgYWJvdXQgcGF0aCBzdHJpbmdzIGF0IE1ETjwvYT4uPC9wPlxuICAgICAjIDx0YWJsZT48dGhlYWQ+PHRyPjx0aD5Db21tYW5kPC90aD48dGg+TmFtZTwvdGg+PHRoPlBhcmFtZXRlcnM8L3RoPjwvdHI+PC90aGVhZD48dGJvZHk+XG4gICAgICMgPHRyPjx0ZD5NPC90ZD48dGQ+bW92ZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+WjwvdGQ+PHRkPmNsb3NlcGF0aDwvdGQ+PHRkPihub25lKTwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkw8L3RkPjx0ZD5saW5ldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5IPC90ZD48dGQ+aG9yaXpvbnRhbCBsaW5ldG88L3RkPjx0ZD54KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlY8L3RkPjx0ZD52ZXJ0aWNhbCBsaW5ldG88L3RkPjx0ZD55KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkM8L3RkPjx0ZD5jdXJ2ZXRvPC90ZD48dGQ+KHgxIHkxIHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UzwvdGQ+PHRkPnNtb290aCBjdXJ2ZXRvPC90ZD48dGQ+KHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UTwvdGQ+PHRkPnF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5UPC90ZD48dGQ+c21vb3RoIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5BPC90ZD48dGQ+ZWxsaXB0aWNhbCBhcmM8L3RkPjx0ZD4ocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5SPC90ZD48dGQ+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F0bXVsbOKAk1JvbV9zcGxpbmUjQ2F0bXVsbC5FMi44MC45M1JvbV9zcGxpbmVcIj5DYXRtdWxsLVJvbSBjdXJ2ZXRvPC9hPio8L3RkPjx0ZD54MSB5MSAoeCB5KSs8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPlxuICAgICAqICogX0NhdG11bGwtUm9tIGN1cnZldG9fIGlzIGEgbm90IHN0YW5kYXJkIFNWRyBjb21tYW5kIGFuZCBhZGRlZCB0byBtYWtlIGxpZmUgZWFzaWVyLlxuICAgICAqIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gYSBwYXRoIGNvbnNpc3RzIG9mIG9ubHkgdGhyZWUgY29tbWFuZHM6IGBNMTAsMTBS4oCmemAuIEluIHRoaXMgY2FzZSB0aGUgcGF0aCBjb25uZWN0cyBiYWNrIHRvIGl0cyBzdGFydGluZyBwb2ludC5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIucGF0aChcIk0xMCAxMEw5MCA5MFwiKTtcbiAgICAgfCAvLyBkcmF3IGEgZGlhZ29uYWwgbGluZTpcbiAgICAgfCAvLyBtb3ZlIHRvIDEwLDEwLCBsaW5lIHRvIDkwLDkwXG4gICAgXFwqL1xuICAgIHByb3RvLnBhdGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKGlzKGQsIFwib2JqZWN0XCIpICYmICFpcyhkLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0gZDtcbiAgICAgICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgICAgICBhdHRyID0ge2Q6IGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0aFwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgZ3JvdXAgZWxlbWVudFxuICAgICAqKlxuICAgICAtIHZhcmFyZ3MgKOKApikgI29wdGlvbmFsIGVsZW1lbnRzIHRvIG5lc3Qgd2l0aGluIHRoZSBncm91cFxuICAgICA9IChvYmplY3QpIHRoZSBgZ2AgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZyhjMiwgYzEpOyAvLyBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIGRpZmZlcmVudFxuICAgICAqIG9yXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZygpO1xuICAgICB8IGcuYWRkKGMyLCBjMSk7XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5ncm91cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBQYXBlci5nXG4gICAgXFwqL1xuICAgIHByb3RvLmdyb3VwID0gcHJvdG8uZyA9IGZ1bmN0aW9uIChmaXJzdCkge1xuICAgICAgICB2YXIgYXR0cixcbiAgICAgICAgICAgIGVsID0gdGhpcy5lbChcImdcIik7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZmlyc3QgJiYgIWZpcnN0LnR5cGUpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLmFkZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc3ZnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgbmVzdGVkIFNWRyBlbGVtZW50LlxuICAgICAtIHggKG51bWJlcikgQG9wdGlvbmFsIFggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB5IChudW1iZXIpIEBvcHRpb25hbCBZIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gd2lkdGggKG51bWJlcikgQG9wdGlvbmFsIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIEBvcHRpb25hbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB2YnggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggWFxuICAgICAtIHZieSAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBZXG4gICAgIC0gdmJ3IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IHdpZHRoXG4gICAgIC0gdmJoIChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IGhlaWdodFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgc3ZnYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnN2ZyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB2YngsIHZieSwgdmJ3LCB2YmgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiB5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YnggIT0gbnVsbCAmJiB2YnkgIT0gbnVsbCAmJiB2YncgIT0gbnVsbCAmJiB2YmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLnZpZXdCb3ggPSBbdmJ4LCB2YnksIHZidywgdmJoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInN2Z1wiLCBhdHRycyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIubWFza1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXF1aXZhbGVudCBpbiBiZWhhdmlvdXIgdG8gQFBhcGVyLmcsIGV4Y2VwdCBpdOKAmXMgYSBtYXNrLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgbWFza2AgZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBwcm90by5tYXNrID0gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgZWwgPSB0aGlzLmVsKFwibWFza1wiKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBmaXJzdCAmJiAhZmlyc3QudHlwZSkge1xuICAgICAgICAgICAgZWwuYXR0cihmaXJzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWwuYWRkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wdHJuXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IGluIGJlaGF2aW91ciB0byBAUGFwZXIuZywgZXhjZXB0IGl04oCZcyBhIHBhdHRlcm4uXG4gICAgIC0geCAobnVtYmVyKSBAb3B0aW9uYWwgWCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHkgKG51bWJlcikgQG9wdGlvbmFsIFkgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB3aWR0aCAobnVtYmVyKSBAb3B0aW9uYWwgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgQG9wdGlvbmFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGBwYXR0ZXJuYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnB0cm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgdngsIHZ5LCB2dywgdmgpIHtcbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyID0ge3BhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwifTtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgYXR0ci54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgICAgICAgYXR0ci55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnggIT0gbnVsbCAmJiB2eSAhPSBudWxsICYmIHZ3ICE9IG51bGwgJiYgdmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt2eCwgdnksIHZ3LCB2aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt4IHx8IDAsIHkgfHwgMCwgd2lkdGggfHwgMCwgaGVpZ2h0IHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0dGVyblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci51c2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8dXNlPiBlbGVtZW50LlxuICAgICAtIGlkIChzdHJpbmcpIEBvcHRpb25hbCBpZCBvZiBlbGVtZW50IHRvIGxpbmtcbiAgICAgKiBvclxuICAgICAtIGlkIChFbGVtZW50KSBAb3B0aW9uYWwgZWxlbWVudCB0byBsaW5rXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGB1c2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8udXNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaWQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZC5hdHRyKFwiaWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQuYXR0cih7aWQ6IFNuYXAuXy5pZChpZCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoU3RyaW5nKGlkKS5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ1c2VcIiwge1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUudXNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zeW1ib2xcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8c3ltYm9sPiBlbGVtZW50LlxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgID0gKG9iamVjdCkgdGhlIGBzeW1ib2xgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8uc3ltYm9sID0gZnVuY3Rpb24gKHZ4LCB2eSwgdncsIHZoKSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmICh2eCAhPSBudWxsICYmIHZ5ICE9IG51bGwgJiYgdncgIT0gbnVsbCAmJiB2aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyLnZpZXdCb3ggPSBbdngsIHZ5LCB2dywgdmhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJzeW1ib2xcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIudGV4dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSB0ZXh0IHN0cmluZ1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB0ZXh0IChzdHJpbmd8YXJyYXkpIFRoZSB0ZXh0IHN0cmluZyB0byBkcmF3IG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gbmVzdCB3aXRoaW4gc2VwYXJhdGUgYDx0c3Bhbj5gIGVsZW1lbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGB0ZXh0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdDEgPSBwYXBlci50ZXh0KDUwLCA1MCwgXCJTbmFwXCIpO1xuICAgICB8IHZhciB0MiA9IHBhcGVyLnRleHQoNTAsIDUwLCBbXCJTXCIsXCJuXCIsXCJhXCIsXCJwXCJdKTtcbiAgICAgfCAvLyBUZXh0IHBhdGggdXNhZ2VcbiAgICAgfCB0MS5hdHRyKHt0ZXh0cGF0aDogXCJNMTAsMTBMMTAwLDEwMFwifSk7XG4gICAgIHwgLy8gb3JcbiAgICAgfCB2YXIgcHRoID0gcGFwZXIucGF0aChcIk0xMCwxMEwxMDAsMTAwXCIpO1xuICAgICB8IHQxLmF0dHIoe3RleHRwYXRoOiBwdGh9KTtcbiAgICBcXCovXG4gICAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uICh4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0IHx8IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ0ZXh0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmxpbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgbGluZVxuICAgICAqKlxuICAgICAtIHgxIChudW1iZXIpIHggY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnRcbiAgICAgLSB5MSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0XG4gICAgIC0geDIgKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBlbmRcbiAgICAgLSB5MiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIGVuZFxuICAgICA9IChvYmplY3QpIHRoZSBgbGluZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHQxID0gcGFwZXIubGluZSg1MCwgNTAsIDEwMCwgMTAwKTtcbiAgICBcXCovXG4gICAgcHJvdG8ubGluZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICBpZiAoaXMoeDEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0geDE7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJsaW5lXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBvbHlsaW5lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlsaW5lXG4gICAgICoqXG4gICAgIC0gcG9pbnRzIChhcnJheSkgYXJyYXkgb2YgcG9pbnRzXG4gICAgICogb3JcbiAgICAgLSB2YXJhcmdzICjigKYpIHBvaW50c1xuICAgICA9IChvYmplY3QpIHRoZSBgcG9seWxpbmVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBwMSA9IHBhcGVyLnBvbHlsaW5lKFsxMCwgMTAsIDEwMCwgMTAwXSk7XG4gICAgIHwgdmFyIHAyID0gcGFwZXIucG9seWxpbmUoMTAsIDEwLCAxMDAsIDEwMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLnBvbHlsaW5lID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtwb2ludHM6IHBvaW50c307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwb2x5bGluZVwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wb2x5Z29uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24uIFNlZSBAUGFwZXIucG9seWxpbmVcbiAgICBcXCovXG4gICAgcHJvdG8ucG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyhwb2ludHMsIFwib2JqZWN0XCIpICYmICFpcyhwb2ludHMsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGF0dHIgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7cG9pbnRzOiBwb2ludHN9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicG9seWdvblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8vIGdyYWRpZW50c1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkID0gU25hcC5fLiQ7XG4gICAgICAgIC8vIGdyYWRpZW50cycgaGVscGVyc1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuc3RvcHNcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE9ubHkgZm9yIGdyYWRpZW50cyFcbiAgICAgICAgICogUmV0dXJucyBhcnJheSBvZiBncmFkaWVudCBzdG9wcyBlbGVtZW50cy5cbiAgICAgICAgID0gKGFycmF5KSB0aGUgc3RvcHMgYXJyYXkuXG4gICAgICAgIFxcKi9cbiAgICAgICAgZnVuY3Rpb24gR3N0b3BzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKFwic3RvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuYWRkU3RvcFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogT25seSBmb3IgZ3JhZGllbnRzIVxuICAgICAgICAgKiBBZGRzIGFub3RoZXIgc3RvcCB0byB0aGUgZ3JhZGllbnQuXG4gICAgICAgICAtIGNvbG9yIChzdHJpbmcpIHN0b3BzIGNvbG9yXG4gICAgICAgICAtIG9mZnNldCAobnVtYmVyKSBzdG9wcyBvZmZzZXQgMC4uMTAwXG4gICAgICAgICA9IChvYmplY3QpIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBmdW5jdGlvbiBHYWRkU3RvcChjb2xvciwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9ICQoXCJzdG9wXCIpLFxuICAgICAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogK29mZnNldCArIFwiJVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbG9yID0gU25hcC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBhdHRyW1wic3RvcC1jb2xvclwiXSA9IGNvbG9yLmhleDtcbiAgICAgICAgICAgIGlmIChjb2xvci5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgIGF0dHJbXCJzdG9wLW9wYWNpdHlcIl0gPSBjb2xvci5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChzdG9wLCBhdHRyKTtcbiAgICAgICAgICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHMoKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRlZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcE9mZnNldCA9IHBhcnNlRmxvYXQoc3RvcHNbaV0uYXR0cihcIm9mZnNldFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BPZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShzdG9wLCBzdG9wc1tpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gR2dldEJCb3goKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciB4MSA9ICQodGhpcy5ub2RlLCBcIngxXCIpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyID0gJCh0aGlzLm5vZGUsIFwieDJcIikgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAkKHRoaXMubm9kZSwgXCJ5MVwiKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB5MiA9ICQodGhpcy5ub2RlLCBcInkyXCIpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goeDEsIHkxLCBtYXRoLmFicyh4MiAtIHgxKSwgbWF0aC5hYnMoeTIgLSB5MSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSB0aGlzLm5vZGUuY3ggfHwgLjUsXG4gICAgICAgICAgICAgICAgICAgIGN5ID0gdGhpcy5ub2RlLmN5IHx8IC41LFxuICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5ub2RlLnIgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChjeCAtIHIsIGN5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuc2V0U3RvcHNcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE9ubHkgZm9yIGdyYWRpZW50cyFcbiAgICAgICAgICogVXBkYXRlcyBzdG9wcyBvZiB0aGUgZ3JhZGllbnQgYmFzZWQgb24gcGFzc2VkIGdyYWRpZW50IGRlc2NyaXB0b3IuIFNlZSBAUHBhZXIuZ3JhZGllbnRcbiAgICAgICAgIC0gc3RyIChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3IgcGFydCBhZnRlciBgKClgLlxuICAgICAgICAgPSAob2JqZWN0KSBncmFkaWVudCBlbGVtZW50XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJsKDAsIDAsIDEsIDEpIzAwMC0jZjAwLSNmZmZcIik7XG4gICAgICAgICB8IGcuc2V0U3RvcHMoXCIjZmZmLSMwMDAtI2YwMC0jZmMwXCIpO1xuICAgICAgICBcXCovXG4gICAgICAgIGZ1bmN0aW9uIEdzZXRTdG9wcyhzdHIpIHtcbiAgICAgICAgICAgIHZhciBncmFkID0gc3RyLFxuICAgICAgICAgICAgICAgIHN0b3BzID0gdGhpcy5zdG9wcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBcImwoMCwwLDAsMSlcIiArIHN0cikuZmlyc3REZWZpbmVkKCkuc3RvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVNuYXAuaXMoZ3JhZCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBTbmFwLmNvbG9yKGdyYWRbaV0uY29sb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHtcIm9mZnNldFwiOiBncmFkW2ldLm9mZnNldCArIFwiJVwifTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cltcInN0b3AtY29sb3JcIl0gPSBjb2xvci5oZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvci5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cltcInN0b3Atb3BhY2l0eVwiXSA9IGNvbG9yLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHNbaV0uYXR0cihhdHRyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBzdG9wcy5sZW5ndGg7IGkgPCBncmFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTdG9wKGdyYWRbaV0uY29sb3IsIGdyYWRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdyYWRpZW50KGRlZnMsIHN0cikge1xuICAgICAgICAgICAgdmFyIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBzdHIpLmZpcnN0RGVmaW5lZCgpLFxuICAgICAgICAgICAgICAgIGVsO1xuICAgICAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkLnBhcmFtcy51bnNoaWZ0KGRlZnMpO1xuICAgICAgICAgICAgaWYgKGdyYWQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwibFwiKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBncmFkaWVudExpbmVhci5hcHBseSgwLCBncmFkLnBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZ3JhZGllbnRSYWRpYWwuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYWQudHlwZSAhPSBncmFkLnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdG9wcyA9IGdyYWQuc3RvcHMsXG4gICAgICAgICAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgICAgICAgZWwuYWRkU3RvcChzdG9wLmNvbG9yLCBzdG9wLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRMaW5lYXIoZGVmcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwibGluZWFyR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGVsLnNldFN0b3BzID0gR3NldFN0b3BzO1xuICAgICAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRSYWRpYWwoZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwicmFkaWFsR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnggIT0gbnVsbCAmJiBmeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ4OiBmeCxcbiAgICAgICAgICAgICAgICAgICAgZnk6IGZ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5ncmFkaWVudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgICoqXG4gICAgICAgICAtIGdyYWRpZW50IChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3JcbiAgICAgICAgID4gR3JhZGllbnQgRGVzY3JpcHRvclxuICAgICAgICAgKiBUaGUgZ3JhZGllbnQgZGVzY3JpcHRvciBpcyBhbiBleHByZXNzaW9uIGZvcm1hdHRlZCBhc1xuICAgICAgICAgKiBmb2xsb3dzOiBgPHR5cGU+KDxjb29yZHM+KTxjb2xvcnM+YC4gIFRoZSBgPHR5cGU+YCBjYW4gYmVcbiAgICAgICAgICogZWl0aGVyIGxpbmVhciBvciByYWRpYWwuICBUaGUgdXBwZXJjYXNlIGBMYCBvciBgUmAgbGV0dGVyc1xuICAgICAgICAgKiBpbmRpY2F0ZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZmZzZXQgZnJvbSB0aGUgU1ZHIHN1cmZhY2UuXG4gICAgICAgICAqIExvd2VyY2FzZSBgbGAgb3IgYHJgIGxldHRlcnMgaW5kaWNhdGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICogY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZ3JhZGllbnQgaXNcbiAgICAgICAgICogYXBwbGllZC4gIENvb3JkaW5hdGVzIHNwZWNpZnkgYSBsaW5lYXIgZ3JhZGllbnQgdmVjdG9yIGFzXG4gICAgICAgICAqIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAsIG9yIGEgcmFkaWFsIGdyYWRpZW50IGFzIGBjeGAsIGBjeWAsXG4gICAgICAgICAqIGByYCBhbmQgb3B0aW9uYWwgYGZ4YCwgYGZ5YCBzcGVjaWZ5aW5nIGEgZm9jYWwgcG9pbnQgYXdheVxuICAgICAgICAgKiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS4gU3BlY2lmeSBgPGNvbG9ycz5gIGFzIGEgbGlzdFxuICAgICAgICAgKiBvZiBkYXNoLXNlcGFyYXRlZCBDU1MgY29sb3IgdmFsdWVzLiAgRWFjaCBjb2xvciBtYXkgYmVcbiAgICAgICAgICogZm9sbG93ZWQgYnkgYSBjdXN0b20gb2Zmc2V0IHZhbHVlLCBzZXBhcmF0ZWQgd2l0aCBhIGNvbG9uXG4gICAgICAgICAqIGNoYXJhY3Rlci5cbiAgICAgICAgID4gRXhhbXBsZXNcbiAgICAgICAgICogTGluZWFyIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRvcC1sZWZ0IGNvcm5lciB0byBib3R0b20tcmlnaHRcbiAgICAgICAgICogY29ybmVyLCBmcm9tIGJsYWNrIHRocm91Z2ggcmVkIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwibCgwLCAwLCAxLCAxKSMwMDAtI2YwMC0jZmZmXCIpO1xuICAgICAgICAgKiBMaW5lYXIgZ3JhZGllbnQsIGFic29sdXRlIGZyb20gKDAsIDApIHRvICgxMDAsIDEwMCksIGZyb20gYmxhY2tcbiAgICAgICAgICogdGhyb3VnaCByZWQgYXQgMjUlIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwiTCgwLCAwLCAxMDAsIDEwMCkjMDAwLSNmMDA6MjUtI2ZmZlwiKTtcbiAgICAgICAgICogUmFkaWFsIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgd2l0aCByYWRpdXNcbiAgICAgICAgICogaGFsZiB0aGUgd2lkdGgsIGZyb20gYmxhY2sgdG8gd2hpdGU6XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJyKDAuNSwgMC41LCAwLjUpIzAwMC0jZmZmXCIpO1xuICAgICAgICAgKiBUbyBhcHBseSB0aGUgZ3JhZGllbnQ6XG4gICAgICAgICB8IHBhcGVyLmNpcmNsZSg1MCwgNTAsIDQwKS5hdHRyKHtcbiAgICAgICAgIHwgICAgIGZpbGw6IGdcbiAgICAgICAgIHwgfSk7XG4gICAgICAgICA9IChvYmplY3QpIHRoZSBgZ3JhZGllbnRgIGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by5ncmFkaWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFkaWVudCh0aGlzLmRlZnMsIHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50TGluZWFyID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRMaW5lYXIodGhpcy5kZWZzLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50UmFkaWFsID0gZnVuY3Rpb24gKGN4LCBjeSwgciwgZngsIGZ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRSYWRpYWwodGhpcy5kZWZzLCBjeCwgY3ksIHIsIGZ4LCBmeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUGFwZXIudG9TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBkID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgc3ZnID0gdGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBmLmFwcGVuZENoaWxkKGQpO1xuICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICAgICAgU25hcC5fLiQoc3ZnLCB7eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0pO1xuICAgICAgICAgICAgcmVzID0gZC5pbm5lckhUTUw7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKGYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLnRvRGF0YVVSTFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIEBQYXBlciBhcyBEYXRhIFVSSSBzdHJpbmcuXG4gICAgICAgICA9IChzdHJpbmcpIERhdGEgVVJJIHN0cmluZ1xuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmJ0b2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGhpcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5jbGVhclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIHBhcGVyLCBleGNlcHQgPGRlZnM+LlxuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lICE9IFwiZGVmc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm90by5jbGVhci5jYWxsKHtub2RlOiBub2RlfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBjbG9uZSA9IFNuYXAuXy5jbG9uZSxcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgUEkgPSBtYXRoLlBJLFxuICAgICAgICBtbWluID0gbWF0aC5taW4sXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgcG93ID0gbWF0aC5wb3csXG4gICAgICAgIGFicyA9IG1hdGguYWJzO1xuICAgIGZ1bmN0aW9uIHBhdGhzKHBzKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcbiAgICAgICAgaWYgKHBbcHNdKSB7XG4gICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBbcHNdID0ge1xuICAgICAgICAgICAgICAgIHNsZWVwOiAxMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkgaWYgKHBbaGFzXShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICAgICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAgICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwW3BzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHkgPSB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICAgICAgeDI6IHggKyB3aWR0aCxcbiAgICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgY3g6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICByMTogbWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcjI6IG1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHIwOiBtYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcGF0aDogcmVjdFBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgICB2YjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiLFwiKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aENsb25lKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmV6bGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSxcbiAgICAgICAgICAgICAgICBnZXRUb3RMZW4ocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlbmd0aEZhY3RvcnkoaXN0b3RhbCwgc3VicGF0aCkge1xuICAgICAgICBmdW5jdGlvbiBPKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICsoK3ZhbCkudG9GaXhlZCgzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5fLmNhY2hlcihmdW5jdGlvbiAocGF0aCwgbGVuZ3RoLCBvbmx5c3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmF0dHIoXCJkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcCwgbCwgc3AgPSBcIlwiLCBzdWJwYXRocyA9IHt9LCBwb2ludCxcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuICsgbCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnBhdGggJiYgIXN1YnBhdGhzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwICs9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDXCIgKyBPKHBvaW50LnN0YXJ0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnN0YXJ0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm0ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubS55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC55KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlzdGFydCkge3JldHVybiBzcDt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGF0aHMuc3RhcnQgPSBzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNXCIgKyBPKHBvaW50LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnkpICsgXCJDXCIgKyBPKHBvaW50Lm4ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubi55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5lbmQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQuZW5kLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXN0b3RhbCAmJiAhc3VicGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcCArPSBwLnNoaWZ0KCkgKyBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicGF0aHMuZW5kID0gc3A7XG4gICAgICAgICAgICBwb2ludCA9IGlzdG90YWwgPyBsZW4gOiBzdWJwYXRoID8gc3VicGF0aHMgOiBmaW5kRG90c0F0U2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSwgbnVsbCwgU25hcC5fLmNsb25lKTtcbiAgICB9XG4gICAgdmFyIGdldFRvdGFsTGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgxKSxcbiAgICAgICAgZ2V0UG9pbnRBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoKSxcbiAgICAgICAgZ2V0U3VicGF0aHNBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMCwgMSk7XG4gICAgZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQsXG4gICAgICAgICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgICAgICB0MyA9IHQyICogdCxcbiAgICAgICAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICAgICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5LFxuICAgICAgICAgICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgICAgICAgICBteSA9IHAxeSArIDIgKiB0ICogKGMxeSAtIHAxeSkgKyB0MiAqIChjMnkgLSAyICogYzF5ICsgcDF5KSxcbiAgICAgICAgICAgIG54ID0gYzF4ICsgMiAqIHQgKiAoYzJ4IC0gYzF4KSArIHQyICogKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgICAgICAgICBheCA9IHQxICogcDF4ICsgdCAqIGMxeCxcbiAgICAgICAgICAgIGF5ID0gdDEgKiBwMXkgKyB0ICogYzF5LFxuICAgICAgICAgICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgICAgICAgICBjeSA9IHQxICogYzJ5ICsgdCAqIHAyeSxcbiAgICAgICAgICAgIGFscGhhID0gOTAgLSBtYXRoLmF0YW4yKG14IC0gbngsIG15IC0gbnkpICogMTgwIC8gUEk7XG4gICAgICAgIC8vIChteCA+IG54IHx8IG15IDwgbnkpICYmIChhbHBoYSArPSAxODApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBtOiB7eDogbXgsIHk6IG15fSxcbiAgICAgICAgICAgIG46IHt4OiBueCwgeTogbnl9LFxuICAgICAgICAgICAgc3RhcnQ6IHt4OiBheCwgeTogYXl9LFxuICAgICAgICAgICAgZW5kOiB7eDogY3gsIHk6IGN5fSxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZXppZXJCQm94KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XG4gICAgICAgIGlmICghU25hcC5pcyhwMXgsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHAxeCA9IFtwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJib3ggPSBjdXJ2ZURpbS5hcHBseShudWxsLCBwMXgpO1xuICAgICAgICByZXR1cm4gYm94KFxuICAgICAgICAgICAgYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWluLnksXG4gICAgICAgICAgICBiYm94Lm1heC54IC0gYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWF4LnkgLSBiYm94Lm1pbi55XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuICB4ID49IGJib3gueCAmJlxuICAgICAgICAgICAgICAgIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJlxuICAgICAgICAgICAgICAgIHkgPj0gYmJveC55ICYmXG4gICAgICAgICAgICAgICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94Mikge1xuICAgICAgICBiYm94MSA9IGJveChiYm94MSk7XG4gICAgICAgIGJib3gyID0gYm94KGJib3gyKTtcbiAgICAgICAgcmV0dXJuIGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54LCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55MilcbiAgICAgICAgICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55MilcbiAgICAgICAgICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnhcbiAgICAgICAgICAgICAgICB8fCBiYm94Mi54IDwgYmJveDEueDIgJiYgYmJveDIueCA+IGJib3gxLngpXG4gICAgICAgICAgICAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55XG4gICAgICAgICAgICAgICAgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICAgICAgICAgIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgICAgICAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICB6ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgICAgICAgdmFyIHoyID0geiAvIDIsXG4gICAgICAgICAgICBuID0gMTIsXG4gICAgICAgICAgICBUdmFsdWVzID0gWy0uMTI1MiwuMTI1MiwtLjM2NzgsLjM2NzgsLS41ODczLC41ODczLC0uNzY5OSwuNzY5OSwtLjkwNDEsLjkwNDEsLS45ODE2LC45ODE2XSxcbiAgICAgICAgICAgIEN2YWx1ZXMgPSBbMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLFxuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgICAgICAgICAgIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KSxcbiAgICAgICAgICAgICAgICB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCksXG4gICAgICAgICAgICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuICAgICAgICAgICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBtYXRoLnNxcnQoY29tYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoyICogc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUb3RMZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsbCkge1xuICAgICAgICBpZiAobGwgPCAwIHx8IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIDwgbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IDEsXG4gICAgICAgICAgICBzdGVwID0gdCAvIDIsXG4gICAgICAgICAgICB0MiA9IHQgLSBzdGVwLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGUgPSAuMDE7XG4gICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIHdoaWxlIChhYnMobCAtIGxsKSA+IGUpIHtcbiAgICAgICAgICAgIHN0ZXAgLz0gMjtcbiAgICAgICAgICAgIHQyICs9IChsIDwgbGwgPyAxIDogLTEpICogc3RlcDtcbiAgICAgICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1tYXgoeDEsIHgyKSA8IG1taW4oeDMsIHg0KSB8fFxuICAgICAgICAgICAgbW1pbih4MSwgeDIpID4gbW1heCh4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWF4KHkxLCB5MikgPCBtbWluKHkzLCB5NCkgfHxcbiAgICAgICAgICAgIG1taW4oeTEsIHkyKSA+IG1tYXgoeTMsIHk0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICAgICAgICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB5ID0gbnkgLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB4MiA9ICtweC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPCArbW1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA+ICttbWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA8ICttbWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyID4gK21tYXgoeTMsIHk0KS50b0ZpeGVkKDIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDogcHgsIHk6IHB5fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXIoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyQ291bnQoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICAgICAgICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpLFxuICAgICAgICAgICAgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuICAgICAgICBpZiAoIWlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgICAgICAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsMSA9IGJlemxlbi5hcHBseSgwLCBiZXoxKSxcbiAgICAgICAgICAgIGwyID0gYmV6bGVuLmFwcGx5KDAsIGJlejIpLFxuICAgICAgICAgICAgbjEgPSB+fihsMSAvIDgpLFxuICAgICAgICAgICAgbjIgPSB+fihsMiAvIDgpLFxuICAgICAgICAgICAgZG90czEgPSBbXSxcbiAgICAgICAgICAgIGRvdHMyID0gW10sXG4gICAgICAgICAgICB4eSA9IHt9LFxuICAgICAgICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgICAgICAgICAgZG90czEucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMiArIDE7IGkrKykge1xuICAgICAgICAgICAgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejIuY29uY2F0KGkgLyBuMikpO1xuICAgICAgICAgICAgZG90czIucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMn0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGkgPSBkb3RzMVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZGkxID0gZG90czFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkaiA9IGRvdHMyW2pdLFxuICAgICAgICAgICAgICAgICAgICBkajEgPSBkb3RzMltqICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNpID0gYWJzKGRpMS54IC0gZGkueCkgPCAuMDAxID8gXCJ5XCIgOiBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgY2ogPSBhYnMoZGoxLnggLSBkai54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBpcyA9IGludGVyc2VjdChkaS54LCBkaS55LCBkaTEueCwgZGkxLnksIGRqLngsIGRqLnksIGRqMS54LCBkajEueSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4eVtpcy54LnRvRml4ZWQoNCldID09IGlzLnkudG9GaXhlZCg0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeHlbaXMueC50b0ZpeGVkKDQpXSA9IGlzLnkudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gZGkudCArIGFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gZGoudCArIGFicygoaXNbY2pdIC0gZGpbY2pdKSAvIChkajFbY2pdIC0gZGpbY2pdKSkgKiAoZGoxLnQgLSBkai50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSAmJiB0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MTogdDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyOiB0MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhJbnRlcnNlY3Rpb24ocGF0aDEsIHBhdGgyKSB7XG4gICAgICAgIHJldHVybiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEludGVyc2VjdGlvbk51bWJlcihwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyLCBqdXN0Q291bnQpIHtcbiAgICAgICAgcGF0aDEgPSBwYXRoMmN1cnZlKHBhdGgxKTtcbiAgICAgICAgcGF0aDIgPSBwYXRoMmN1cnZlKHBhdGgyKTtcbiAgICAgICAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MW0sIHkxbSwgeDJtLCB5Mm0sIGJlejEsIGJlejIsXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuICAgICAgICAgICAgaWYgKHBpWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeDEgPSB4MW0gPSBwaVsxXTtcbiAgICAgICAgICAgICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTFdLmNvbmNhdChwaS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYmV6MVs2XTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBiZXoxWzddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlejEgPSBbeDEsIHkxLCB4MSwgeTEsIHgxbSwgeTFtLCB4MW0sIHkxbV07XG4gICAgICAgICAgICAgICAgICAgIHgxID0geDFtO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkxbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcGF0aDIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGogPSBwYXRoMltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm0gPSBwalsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwalswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gYmV6Mls2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGJlejJbN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyLCB4MiwgeTIsIHgybSwgeTJtLCB4Mm0sIHkybV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGludHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IGludHIubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQxID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MSA9IGJlejE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MiA9IGJlejI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoaW50cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBhdGgocGF0aCwgeCwgeSkge1xuICAgICAgICB2YXIgYmJveCA9IHBhdGhCQm94KHBhdGgpO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkgJiZcbiAgICAgICAgICAgICAgIGludGVyUGF0aEhlbHBlcihwYXRoLCBbW1wiTVwiLCB4LCB5XSwgW1wiSFwiLCBiYm94LngyICsgMTBdXSwgMSkgJSAyID09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhCQm94KHBhdGgpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuICAgICAgICBpZiAocHRoLmJib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZShwdGguYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgWCA9IFtdLFxuICAgICAgICAgICAgWSA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBbMV07XG4gICAgICAgICAgICAgICAgeSA9IHBbMl07XG4gICAgICAgICAgICAgICAgWC5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIFkucHVzaCh5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGN1cnZlRGltKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgIFggPSBYLmNvbmNhdChkaW0ubWluLngsIGRpbS5tYXgueCk7XG4gICAgICAgICAgICAgICAgWSA9IFkuY29uY2F0KGRpbS5taW4ueSwgZGltLm1heC55KTtcbiAgICAgICAgICAgICAgICB4ID0gcFs1XTtcbiAgICAgICAgICAgICAgICB5ID0gcFs2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgeG1pbiA9IG1taW4uYXBwbHkoMCwgWCksXG4gICAgICAgICAgICB5bWluID0gbW1pbi5hcHBseSgwLCBZKSxcbiAgICAgICAgICAgIHhtYXggPSBtbWF4LmFwcGx5KDAsIFgpLFxuICAgICAgICAgICAgeW1heCA9IG1tYXguYXBwbHkoMCwgWSksXG4gICAgICAgICAgICBiYiA9IGJveCh4bWluLCB5bWluLCB4bWF4IC0geG1pbiwgeW1heCAtIHltaW4pO1xuICAgICAgICBwdGguYmJveCA9IGNsb25lKGJiKTtcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN0UGF0aCh4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFtcIk1cIiwgK3ggKyArciwgeV0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCB3IC0gciAqIDIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCBoIC0gciAqIDJdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgLXIsIHJdLFxuICAgICAgICAgICAgICAgIFtcImxcIiwgciAqIDIgLSB3LCAwXSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCByICogMiAtIGhdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgLXJdLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtbXCJNXCIsIHgsIHldLCBbXCJsXCIsIHcsIDBdLCBbXCJsXCIsIDAsIGhdLCBbXCJsXCIsIC13LCAwXSwgW1wielwiXV07XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGxpcHNlUGF0aCh4LCB5LCByeCwgcnksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gbnVsbCAmJiByeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByeSA9IHJ4O1xuICAgICAgICB9XG4gICAgICAgIHggPSAreDtcbiAgICAgICAgeSA9ICt5O1xuICAgICAgICByeCA9ICtyeDtcbiAgICAgICAgcnkgPSArcnk7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgICAgICAgIHgxID0geCArIHJ4ICogTWF0aC5jb3MoLXJ5ICogcmFkKSxcbiAgICAgICAgICAgICAgICB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKSxcbiAgICAgICAgICAgICAgICB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCksXG4gICAgICAgICAgICAgICAgeTIgPSB5ICsgcnggKiBNYXRoLnNpbigtYSAqIHJhZCksXG4gICAgICAgICAgICAgICAgcmVzID0gW1tcIk1cIiwgeDEsIHkxXSwgW1wiQVwiLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBbXG4gICAgICAgICAgICAgICAgW1wiTVwiLCB4LCB5XSxcbiAgICAgICAgICAgICAgICBbXCJtXCIsIDAsIC1yeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIDIgKiByeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHZhciB1bml0MnB4ID0gU25hcC5fdW5pdDJweCxcbiAgICAgICAgZ2V0UGF0aCA9IHtcbiAgICAgICAgcGF0aDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihcInBhdGhcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGF0dHIuY3gsIGF0dHIuY3ksIGF0dHIucik7XG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbGxpcHNlUGF0aChhdHRyLmN4IHx8IDAsIGF0dHIuY3kgfHwgMCwgYXR0ci5yeCwgYXR0ci5yeSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0LCBhdHRyLnJ4LCBhdHRyLnJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBbZWwuYXR0cihcIngxXCIpIHx8IDAsIGVsLmF0dHIoXCJ5MVwiKSB8fCAwLCBlbC5hdHRyKFwieDJcIiksIGVsLmF0dHIoXCJ5MlwiKV07XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlsaW5lOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1cIiArIGVsLmF0dHIoXCJwb2ludHNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb246IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZWwuYXR0cihcInBvaW50c1wiKSArIFwielwiO1xuICAgICAgICB9LFxuICAgICAgICBkZWZsdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhdGhUb1JlbGF0aXZlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2U7XG4gICAgICAgIGlmIChwdGgucmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5yZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU25hcC5pcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIVNuYXAuaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgeSA9IHBhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICByZXMucHVzaChbXCJNXCIsIHgsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcmVzW2ldID0gW10sXG4gICAgICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAocGFbMF0gIT0gbG93ZXJDYXNlLmNhbGwocGFbMF0pKSB7XG4gICAgICAgICAgICAgICAgclswXSA9IGxvd2VyQ2FzZS5jYWxsKHBhWzBdKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArKHBhWzZdIC0geCkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArKHBhWzddIC0geSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICsocGFbMV0gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gKyhwYVtqXSAtIChqICUgMiA/IHggOiB5KSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHIgPSByZXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocGFbMF0gPT0gXCJtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXggPSBwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgIG15ID0gcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXVtrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSByZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgc3dpdGNoIChyZXNbaV1bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgICAgICAgICB4ID0gbXg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBteTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgICAgICAgICAgeCArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICB5ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHggKz0gK3Jlc1tpXVtsZW4gLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBwdGgucmVsID0gcGF0aENsb25lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhUb0Fic29sdXRlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KTtcbiAgICAgICAgaWYgKHB0aC5hYnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmFicyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIWlzKHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGhBcnJheSB8fCAhcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtbXCJNXCIsIDAsIDBdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgcGEwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICAgICAgICAgIHkgPSArcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgbXggPSB4O1xuICAgICAgICAgICAgbXkgPSB5O1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIHJlc1swXSA9IFtcIk1cIiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNyeiA9IHBhdGhBcnJheS5sZW5ndGggPT0gMyAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzBdWzBdID09IFwiTVwiICYmXG4gICAgICAgICAgICBwYXRoQXJyYXlbMV1bMF0udG9VcHBlckNhc2UoKSA9PSBcIlJcIiAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzJdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJaXCI7XG4gICAgICAgIGZvciAodmFyIHIsIHBhLCBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHIgPSBbXSk7XG4gICAgICAgICAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgIHBhMCA9IHBhWzBdO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBwYTAudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICtwYVs3XSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdHMgPSBbeCwgeV0uY29uY2F0KHBhLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAyLCBqaiA9IGRvdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbal0gPSArZG90c1tqXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1srK2pdID0gK2RvdHNbal0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiT1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGRvdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJVXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gK3BhWzJdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArcGFbal0gKyAoaiAlIDIgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYTAgPT0gXCJSXCIpIHtcbiAgICAgICAgICAgICAgICBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICAgICAgICAgICAgciA9IFtcIlJcIl0uY29uY2F0KHBhLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGEwID09IFwiVVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhMCA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcHRoLmFicyA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsMmMoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcTJjKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIF8xMyA9IDEgLyAzLFxuICAgICAgICAgICAgXzIzID0gMiAvIDM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXzEzICogeDEgKyBfMjMgKiBheCxcbiAgICAgICAgICAgICAgICBfMTMgKiB5MSArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgIF8xMyAqIHgyICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgXzEzICogeTIgKyBfMjMgKiBheSxcbiAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICB5MlxuICAgICAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICB2YXIgXzEyMCA9IFBJICogMTIwIC8gMTgwLFxuICAgICAgICAgICAgcmFkID0gUEkgLyAxODAgKiAoK2FuZ2xlIHx8IDApLFxuICAgICAgICAgICAgcmVzID0gW10sXG4gICAgICAgICAgICB4eSxcbiAgICAgICAgICAgIHJvdGF0ZSA9IFNuYXAuXy5jYWNoZXIoZnVuY3Rpb24gKHgsIHksIHJhZCkge1xuICAgICAgICAgICAgICAgIHZhciBYID0geCAqIG1hdGguY29zKHJhZCkgLSB5ICogbWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgICAgICAgICAgWSA9IHggKiBtYXRoLnNpbihyYWQpICsgeSAqIG1hdGguY29zKHJhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4OiBYLCB5OiBZfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJ4IHx8ICFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICAgICAgICAgIHgxID0geHkueDtcbiAgICAgICAgICAgIHkxID0geHkueTtcbiAgICAgICAgICAgIHh5ID0gcm90YXRlKHgyLCB5MiwgLXJhZCk7XG4gICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICB5MiA9IHh5Lnk7XG4gICAgICAgICAgICB2YXIgY29zID0gbWF0aC5jb3MoUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgc2luID0gbWF0aC5zaW4oUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgICAgICB2YXIgaCA9IHggKiB4IC8gKHJ4ICogcngpICsgeSAqIHkgLyAocnkgKiByeSk7XG4gICAgICAgICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgICAgICBoID0gbWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgICAgICAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgICAgICAgICAgcnkyID0gcnkgKiByeSxcbiAgICAgICAgICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgICAgICAgICAgbWF0aC5zcXJ0KGFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgICAgICAgICAgICBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgICAgICAgICBmMSA9IG1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgICAgICAgICAgIGYyID0gbWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG5cbiAgICAgICAgICAgIGYxID0geDEgPCBjeCA/IFBJIC0gZjEgOiBmMTtcbiAgICAgICAgICAgIGYyID0geDIgPCBjeCA/IFBJIC0gZjIgOiBmMjtcbiAgICAgICAgICAgIGYxIDwgMCAmJiAoZjEgPSBQSSAqIDIgKyBmMSk7XG4gICAgICAgICAgICBmMiA8IDAgJiYgKGYyID0gUEkgKiAyICsgZjIpO1xuICAgICAgICAgICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgICAgICAgICAgIGYxID0gZjEgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgICAgIGYyID0gZjIgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICAgICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICAgICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgICAgICAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGYgPSBmMiAtIGYxO1xuICAgICAgICBpZiAoYWJzKGRmKSA+IF8xMjApIHtcbiAgICAgICAgICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgICAgICAgICAgIHgyb2xkID0geDIsXG4gICAgICAgICAgICAgICAgeTJvbGQgPSB5MjtcbiAgICAgICAgICAgIGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSk7XG4gICAgICAgICAgICB4MiA9IGN4ICsgcnggKiBtYXRoLmNvcyhmMik7XG4gICAgICAgICAgICB5MiA9IGN5ICsgcnkgKiBtYXRoLnNpbihmMik7XG4gICAgICAgICAgICByZXMgPSBhMmMoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICAgICAgICB9XG4gICAgICAgIGRmID0gZjIgLSBmMTtcbiAgICAgICAgdmFyIGMxID0gbWF0aC5jb3MoZjEpLFxuICAgICAgICAgICAgczEgPSBtYXRoLnNpbihmMSksXG4gICAgICAgICAgICBjMiA9IG1hdGguY29zKGYyKSxcbiAgICAgICAgICAgIHMyID0gbWF0aC5zaW4oZjIpLFxuICAgICAgICAgICAgdCA9IG1hdGgudGFuKGRmIC8gNCksXG4gICAgICAgICAgICBoeCA9IDQgLyAzICogcnggKiB0LFxuICAgICAgICAgICAgaHkgPSA0IC8gMyAqIHJ5ICogdCxcbiAgICAgICAgICAgIG0xID0gW3gxLCB5MV0sXG4gICAgICAgICAgICBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV0sXG4gICAgICAgICAgICBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl0sXG4gICAgICAgICAgICBtNCA9IFt4MiwgeTJdO1xuICAgICAgICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICAgICAgICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB2YXIgbmV3cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld3Jlc1tpXSA9IGkgJSAyID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld3JlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRG90QXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gICAgICAgIHZhciB0MSA9IDEgLSB0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG93KHQxLCAzKSAqIHAxeCArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgcG93KHQsIDMpICogcDJ4LFxuICAgICAgICAgICAgeTogcG93KHQxLCAzKSAqIHAxeSArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgcG93KHQsIDMpICogcDJ5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBib3VuZGluZyBib3ggb2YgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgIC8vIFNvdXJjZTogaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4gICAgLy8gTW9kaWZpY2F0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL3RpbW8yMjM0NVxuICAgIGZ1bmN0aW9uIGN1cnZlRGltKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgdHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICAgICAgICBzcXJ0YjJhYyA9IG1hdGguc3FydChiMmFjKTtcbiAgICAgICAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGpsZW4gPSBqLFxuICAgICAgICAgICAgbXQ7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIGJvdW5kc1swXVtqXSA9IG10ICogbXQgKiBtdCAqIHgwICsgMyAqIG10ICogbXQgKiB0ICogeDEgKyAzICogbXQgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgICAgICAgICBib3VuZHNbMV1bal0gPSBtdCAqIG10ICogbXQgKiB5MCArIDMgKiBtdCAqIG10ICogdCAqIHkxICsgMyAqIG10ICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgICAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICAgICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluOiB7eDogbW1pbi5hcHBseSgwLCBib3VuZHNbMF0pLCB5OiBtbWluLmFwcGx5KDAsIGJvdW5kc1sxXSl9LFxuICAgICAgICAgIG1heDoge3g6IG1tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogbW1heC5hcHBseSgwLCBib3VuZHNbMV0pfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGgyY3VydmUocGF0aCwgcGF0aDIpIHtcbiAgICAgICAgdmFyIHB0aCA9ICFwYXRoMiAmJiBwYXRocyhwYXRoKTtcbiAgICAgICAgaWYgKCFwYXRoMiAmJiBwdGguY3VydmUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgICAgICBhdHRycyA9IHt4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbH0sXG4gICAgICAgICAgICBhdHRyczIgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCwgcGNvbSkge1xuICAgICAgICAgICAgICAgIHZhciBueCwgbnk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhKHBhdGhbMF0gaW4ge1Q6IDEsIFE6IDF9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQoYTJjLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09IFwiQ1wiIHx8IHBjb20gPT0gXCJTXCIpIHsgLy8gSW4gXCJTXCIgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDsgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCIsIG54LCBueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIlFcIiB8fCBwY29tID09IFwiVFwiKSB7IC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueSAqIDIgLSBkLnF5OyAgICAgICAgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhBcmMgPSBmdW5jdGlvbiAocHAsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXMxW2ldID0gXCJBXCI7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgQzpzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyICYmIChwY29tczJbaV0gPSBcIkFcIik7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbXCJDXCJdLmNvbmNhdChwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhNID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMiwgYTEsIGEyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09IFwiTVwiICYmIHBhdGgyW2ldWzBdICE9IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbXCJNXCIsIGEyLngsIGEyLnldKTtcbiAgICAgICAgICAgICAgICAgICAgYTEuYnggPSAwO1xuICAgICAgICAgICAgICAgICAgICBhMS5ieSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGExLnggPSBwYXRoMVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYTEueSA9IHBhdGgxW2ldWzJdO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGNvbXMxID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICAgICAgICBwY29tczIgPSBbXSwgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHAyXG4gICAgICAgICAgICBwZmlyc3QgPSBcIlwiLCAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgIHBjb20gPSBcIlwiOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHBbaV0gJiYgKHBmaXJzdCA9IHBbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICAgICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpIC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBpICYmICggcGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbaV0gPSBwcm9jZXNzUGF0aChwW2ldLCBhdHRycywgcGNvbSk7IC8vIFByZXZpb3VzIHBhdGggY29tbWFuZCBpcyBpbnB1dHRlZCB0byBwcm9jZXNzUGF0aFxuXG4gICAgICAgICAgICBpZiAocGNvbXMxW2ldICE9IFwiQVwiICYmIHBmaXJzdCA9PSBcIkNcIikgcGNvbXMxW2ldID0gXCJDXCI7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgICAgICAgICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgQzpzXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBjb21zMVxuXG4gICAgICAgICAgICBpZiAocDIpIHsgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICAgICAgICAgICAgcDJbaV0gJiYgKHBmaXJzdCA9IHAyW2ldWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAocGZpcnN0ICE9IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMltpIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIsIHBjb20pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBjb21zMltpXSAhPSBcIkFcIiAmJiBwZmlyc3QgPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGNvbXMyW2ldID0gXCJDXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZml4QXJjKHAyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeE0ocCwgcDIsIGF0dHJzLCBhdHRyczIsIGkpO1xuICAgICAgICAgICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgICAgICAgICB2YXIgc2VnID0gcFtpXSxcbiAgICAgICAgICAgICAgICBzZWcyID0gcDIgJiYgcDJbaV0sXG4gICAgICAgICAgICAgICAgc2VnbGVuID0gc2VnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZWcybGVuID0gcDIgJiYgc2VnMi5sZW5ndGg7XG4gICAgICAgICAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICAgICAgICAgIGF0dHJzLmJ4ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gNF0pIHx8IGF0dHJzLng7XG4gICAgICAgICAgICBhdHRycy5ieSA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgICAgICAgICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHRvRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICAgICAgICAgIGF0dHJzMi5ieSA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDNdKSB8fCBhdHRyczIueSk7XG4gICAgICAgICAgICBhdHRyczIueCA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAyKSB7XG4gICAgICAgICAgICBwdGguY3VydmUgPSBwYXRoQ2xvbmUocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAyID8gW3AsIHAyXSA6IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcFBhdGgocGF0aCwgbWF0cml4KSB7XG4gICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCwgeSwgaSwgaiwgaWksIGpqLCBwYXRoaTtcbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoaSA9IHBhdGhbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhpLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICB4ID0gbWF0cml4LngocGF0aGlbal0sIHBhdGhpW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgeSA9IG1hdHJpeC55KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgIHBhdGhpW2pdID0geDtcbiAgICAgICAgICAgICAgICBwYXRoaVtqICsgMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9zY2hlcGVycy5jYy9nZXR0aW5nLXRvLXRoZS1wb2ludFxuICAgIGZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyKGNycCwgeikge1xuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNycC5sZW5ndGg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSAtIDJdLCB5OiArY3JwW2kgLSAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpXSwgICAgIHk6ICtjcnBbaSArIDFdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyAyXSwgeTogK2NycFtpICsgM119LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XX1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpTGVuIC0gMl0sIHk6ICtjcnBbaUxlbiAtIDFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSA0ID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSAyID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzJdLCB5OiArY3JwWzNdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSBwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHt4OiArY3JwW2ldLCB5OiArY3JwW2kgKyAxXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5wdXNoKFtcIkNcIixcbiAgICAgICAgICAgICAgICAgICgtcFswXS54ICsgNiAqIHBbMV0ueCArIHBbMl0ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICAocFsxXS54ICsgNiAqIHBbMl0ueCAtIHBbM10ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueSArIDYqcFsyXS55IC0gcFszXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICBwWzJdLngsXG4gICAgICAgICAgICAgICAgICBwWzJdLnlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0XG4gICAgU25hcC5wYXRoID0gcGF0aHM7XG5cbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIHBhdGggaW4gcGl4ZWxzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgKipcbiAgICAgPSAobnVtYmVyKSBsZW5ndGhcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5nZXRQb2ludEF0TGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIGFsb25nIHRoZSBnaXZlbiBwYXRoXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBsZW5ndGggKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoLCBleGNsdWRpbmcgbm9uLXJlbmRlcmluZyBqdW1wc1xuICAgICAqKlxuICAgICA9IChvYmplY3QpIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlLFxuICAgICBvICAgICBhbHBoYTogKG51bWJlcikgYW5nbGUgb2YgZGVyaXZhdGl2ZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFBvaW50QXRMZW5ndGggPSBnZXRQb2ludEF0TGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgc3VicGF0aCBvZiBhIGdpdmVuIHBhdGggYmV0d2VlbiBnaXZlbiBzdGFydCBhbmQgZW5kIGxlbmd0aHNcbiAgICAgKipcbiAgICAgLSBwYXRoIChzdHJpbmcpIFNWRyBwYXRoIHN0cmluZ1xuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFN1YnBhdGggPSBmdW5jdGlvbiAocGF0aCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG90YWxMZW5ndGgocGF0aCkgLSB0byA8IDFlLTYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIGZyb20pLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IGdldFN1YnBhdGhzQXRMZW5ndGgocGF0aCwgdG8sIDEpO1xuICAgICAgICByZXR1cm4gZnJvbSA/IGdldFN1YnBhdGhzQXRMZW5ndGgoYSwgZnJvbSkuZW5kIDogYTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggaW4gcGl4ZWxzIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgID0gKG51bWJlcikgbGVuZ3RoXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0VG90YWxMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aCgpL0VsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTogSWYgYSA8cGF0aD4gaXMgYnJva2VuIGludG8gZGlmZmVyZW50IHNlZ21lbnRzLCBpcyB0aGUganVtcCBkaXN0YW5jZSB0byB0aGUgbmV3IGNvb3JkaW5hdGVzIHNldCBieSB0aGUgX01fIG9yIF9tXyBjb21tYW5kcyBjYWxjdWxhdGVkIGFzIHBhcnQgb2YgdGhlIHBhdGgncyB0b3RhbCBsZW5ndGg/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIG9uIHRoZSBnaXZlbiBwYXRoIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgICoqXG4gICAgIC0gbGVuZ3RoIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCwgZXhjbHVkaW5nIG5vbi1yZW5kZXJpbmcganVtcHNcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvaW50QXRMZW5ndGgodGhpcy5hdHRyKFwiZFwiKSwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmdldFN1YnBhdGgoKTogU2ltaWxhciB0byB0aGUgcHJvYmxlbSBmb3IgRWxlbWVudC5nZXRQb2ludEF0TGVuZ3RoKCkuIFVuY2xlYXIgaG93IHRoaXMgd291bGQgd29yayBmb3IgYSBzZWdtZW50ZWQgcGF0aC4gT3ZlcmFsbCwgdGhlIGNvbmNlcHQgb2YgX3N1YnBhdGhfIGFuZCB3aGF0IEknbSBjYWxsaW5nIGEgX3NlZ21lbnRfIChzZXJpZXMgb2Ygbm9uLV9NXyBvciBfWl8gY29tbWFuZHMpIGlzIHVuY2xlYXIuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzdWJwYXRoIG9mIGEgZ2l2ZW4gZWxlbWVudCBmcm9tIGdpdmVuIHN0YXJ0IGFuZCBlbmQgbGVuZ3RocyAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnBhdGguZ2V0U3VicGF0aCh0aGlzLmF0dHIoXCJkXCIpLCBmcm9tLCB0byk7XG4gICAgfTtcbiAgICBTbmFwLl8uYm94ID0gYm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZmluZERvdHNBdFNlZ21lbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogRmluZHMgZG90IGNvb3JkaW5hdGVzIG9uIHRoZSBnaXZlbiBjdWJpYyBiZXppw6lyIGN1cnZlIGF0IHRoZSBnaXZlbiB0XG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHQgKG51bWJlcikgcG9zaXRpb24gb24gdGhlIGN1cnZlICgwLi4xKVxuICAgICA9IChvYmplY3QpIHBvaW50IGluZm9ybWF0aW9uIGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIG06IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBhbmNob3IsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgYW5jaG9yXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIG46IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBhbmNob3JcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgc3RhcnQ6IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgZW5kOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIHRoZSBjdXJ2ZSBkZXJpdmF0aXZlIGF0IHRoZSBwb2ludFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmZpbmREb3RzQXRTZWdtZW50ID0gZmluZERvdHNBdFNlZ21lbnQ7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5iZXppZXJCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdpdmVuIGN1YmljIGJlemnDqXIgY3VydmVcbiAgICAgLSBwMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgICogb3JcbiAgICAgLSBiZXogKGFycmF5KSBhcnJheSBvZiBzaXggcG9pbnRzIGZvciBiZXppw6lyIGN1cnZlXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCB0b3AgcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYm90dG9tIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGggb2YgdGhlIGJveCxcbiAgICAgbyAgICAgaGVpZ2h0OiAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGJveFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmJlemllckJCb3ggPSBiZXppZXJCQm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNQb2ludEluc2lkZUJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIGJvdW5kaW5nIGJveFxuICAgICAtIGJib3ggKHN0cmluZykgYm91bmRpbmcgYm94XG4gICAgIC0geCAoc3RyaW5nKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIC0geSAoc3RyaW5nKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBwb2ludCBpcyBpbnNpZGVcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzUG9pbnRJbnNpZGVCQm94ID0gaXNQb2ludEluc2lkZUJCb3g7XG4gICAgU25hcC5jbG9zZXN0ID0gZnVuY3Rpb24gKHgsIHksIFgsIFkpIHtcbiAgICAgICAgdmFyIHIgPSAxMDAsXG4gICAgICAgICAgICBiID0gYm94KHggLSByIC8gMiwgeSAtIHIgLyAyLCByLCByKSxcbiAgICAgICAgICAgIGluc2lkZSA9IFtdLFxuICAgICAgICAgICAgZ2V0dGVyID0gWFswXS5oYXNPd25Qcm9wZXJ0eShcInhcIikgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogWFtpXS55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IFlbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvdW5kID0gMDtcbiAgICAgICAgd2hpbGUgKHIgPD0gMWU2ICYmICFmb3VuZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gWC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHh5ID0gZ2V0dGVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1BvaW50SW5zaWRlQkJveChiLCB4eS54LCB4eS55KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUucHVzaCh4eSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgICAgICAgYiA9IGJveCh4IC0gciAvIDIsIHkgLSByIC8gMiwgciwgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSAxZTYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gSW5maW5pdHksXG4gICAgICAgICAgICByZXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW5zaWRlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsID0gU25hcC5sZW4oeCwgeSwgaW5zaWRlW2ldLngsIGluc2lkZVtpXS55KTtcbiAgICAgICAgICAgIGlmIChsZW4gPiBsKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gbDtcbiAgICAgICAgICAgICAgICBpbnNpZGVbaV0ubGVuID0gbDtcbiAgICAgICAgICAgICAgICByZXMgPSBpbnNpZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNCQm94SW50ZXJzZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHR3byBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICAgLSBiYm94MSAoc3RyaW5nKSBmaXJzdCBib3VuZGluZyBib3hcbiAgICAgLSBiYm94MiAoc3RyaW5nKSBzZWNvbmQgYm91bmRpbmcgYm94XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzQkJveEludGVyc2VjdCA9IGlzQkJveEludGVyc2VjdDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmludGVyc2VjdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBGaW5kcyBpbnRlcnNlY3Rpb25zIG9mIHR3byBwYXRoc1xuICAgICAtIHBhdGgxIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0gcGF0aDIgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIGRvdHMgb2YgaW50ZXJzZWN0aW9uXG4gICAgIG8gW1xuICAgICBvICAgICB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCxcbiAgICAgbyAgICAgICAgIHQxOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgdDI6IChudW1iZXIpIHQgdmFsdWUgZm9yIHNlZ21lbnQgb2YgcGF0aDIsXG4gICAgIG8gICAgICAgICBzZWdtZW50MTogKG51bWJlcikgb3JkZXIgbnVtYmVyIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgc2VnbWVudDI6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMixcbiAgICAgbyAgICAgICAgIGJlejE6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgYmV6MjogKGFycmF5KSBlaWdodCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgYmV6acOpciBjdXJ2ZSBmb3IgdGhlIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgfVxuICAgICBvIF1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbiA9IHBhdGhJbnRlcnNlY3Rpb247XG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbk51bWJlciA9IHBhdGhJbnRlcnNlY3Rpb25OdW1iZXI7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBhIGdpdmVuIGNsb3NlZCBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZTogZmlsbCBtb2RlIGRvZXNu4oCZdCBhZmZlY3QgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0geCAobnVtYmVyKSB4IG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLnBhdGguaXNQb2ludEluc2lkZSA9IGlzUG9pbnRJbnNpZGVQYXRoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBwYXRoXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRCQm94ID0gcGF0aEJCb3g7XG4gICAgU25hcC5wYXRoLmdldCA9IGdldFBhdGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC50b1JlbGF0aXZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggY29vcmRpbmF0ZXMgaW50byByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKGFycmF5KSBwYXRoIHN0cmluZ1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9SZWxhdGl2ZSA9IHBhdGhUb1JlbGF0aXZlO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgudG9BYnNvbHV0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIGNvb3JkaW5hdGVzIGludG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgcGF0aCBzdHJpbmdcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvQWJzb2x1dGUgPSBwYXRoVG9BYnNvbHV0ZTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLnRvQ3ViaWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byBhIG5ldyBwYXRoIHdoZXJlIGFsbCBzZWdtZW50cyBhcmUgY3ViaWMgYmV6acOpciBjdXJ2ZXNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9DdWJpYyA9IHBhdGgyY3VydmU7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5tYXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgcGF0aCBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIG1hdHJpeCAob2JqZWN0KSBzZWUgQE1hdHJpeFxuICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybWVkIHBhdGggc3RyaW5nXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5tYXAgPSBtYXBQYXRoO1xuICAgIFNuYXAucGF0aC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIFNuYXAucGF0aC5jbG9uZSA9IHBhdGhDbG9uZTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbW1heCA9IE1hdGgubWF4LFxuICAgICAgICBtbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBTZXRcbiAgICB2YXIgU2V0ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcblx0dGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic2V0XCI7XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RoaXMuaXRlbXMubGVuZ3RoXSA9IHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRwcm90byA9IFNldC5wcm90b3R5cGU7XG4gICAgLypcXFxuICAgICAqIFNldC5wdXNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGVhY2ggYXJndW1lbnQgdG8gdGhlIGN1cnJlbnQgc2V0XG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSxcbiAgICAgICAgICAgIGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXNbbGVuXSA9IHRoaXMuaXRlbXNbbGVuXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQucG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGxhc3QgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICAgICA9IChvYmplY3QpIGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCAmJiBkZWxldGUgdGhpc1t0aGlzLmxlbmd0aC0tXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmZvckVhY2hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEV4ZWN1dGVzIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgICAqXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdGhlIGxvb3Agc3RvcHMgcnVubmluZy5cbiAgICAgKipcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pIGZ1bmN0aW9uIHRvIHJ1blxuICAgICAtIHRoaXNBcmcgKG9iamVjdCkgY29udGV4dCBvYmplY3QgZm9yIHRoZSBjYWxsYmFja1xuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuaXRlbXNbaV0sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyBlYWNoIGVsZW1lbnQgaW4gc2V0IGluIHN5bmMuXG4gICAgICpcbiAgICAgKipcbiAgICAgLSBhdHRycyAob2JqZWN0KSBrZXktdmFsdWUgcGFpcnMgb2YgZGVzdGluYXRpb24gYXR0cmlidXRlc1xuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiBmcm9tIEBtaW5hIG9yIGN1c3RvbVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHNcbiAgICAgKiBvclxuICAgICAtIGFuaW1hdGlvbiAoYXJyYXkpIGFycmF5IG9mIGFuaW1hdGlvbiBwYXJhbWV0ZXIgZm9yIGVhY2ggZWxlbWVudCBpbiBzZXQgaW4gZm9ybWF0IGBbYXR0cnMsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXWBcbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGFuaW1hdGUgYWxsIGVsZW1lbnRzIGluIHNldCB0byByYWRpdXMgMTBcbiAgICAgfCBzZXQuYW5pbWF0ZSh7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluKTtcbiAgICAgfCAvLyBvclxuICAgICB8IC8vIGFuaW1hdGUgZmlyc3QgZWxlbWVudCB0byByYWRpdXMgMTAsIGJ1dCBzZWNvbmQgdG8gcmFkaXVzIDIwIGFuZCBpbiBkaWZmZXJlbnQgdGltZVxuICAgICB8IHNldC5hbmltYXRlKFt7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluXSwgW3tyOiAyMH0sIDE1MDAsIG1pbmEuZWFzZWluXSk7XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIFNuYXAuXy5BbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXR0cnMuY2FsbGJhY2s7XG4gICAgICAgICAgICBlYXNpbmcgPSBhdHRycy5lYXNpbmc7XG4gICAgICAgICAgICBtcyA9IGVhc2luZy5kdXI7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzLmF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChTbmFwLmlzKGF0dHJzLCBcImFycmF5XCIpICYmIFNuYXAuaXMoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YXIgZWFjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZ2luLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gYmVnaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSB0aGlzLmI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNiID0gMCxcbiAgICAgICAgICAgIHNldCA9IHRoaXMsXG4gICAgICAgICAgICBjYWxsYmFja2VyID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgrK2NiID09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFuaW1jcmVhdGVkLlwiICsgZWwuaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldICYmIGVsLmFuaW1hdGUuYXBwbHkoZWwsIGFyZ3NbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5hbmltYXRlKGF0dHJzLCBtcywgZWFzaW5nLCBjYWxsYmFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnJlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gb2YgdGhlIHNldC5cbiAgICAgKlxuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wKCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmJpbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNwZWNpZmllcyBob3cgdG8gaGFuZGxlIGEgc3BlY2lmaWMgYXR0cmlidXRlIHdoZW4gYXBwbGllZFxuICAgICAqIHRvIGEgc2V0LlxuICAgICAqXG4gICAgICoqXG4gICAgIC0gYXR0ciAoc3RyaW5nKSBhdHRyaWJ1dGUgbmFtZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgICogb3JcbiAgICAgLSBhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBuYW1lXG4gICAgIC0gZWxlbWVudCAoRWxlbWVudCkgc3BlY2lmaWMgZWxlbWVudCBpbiB0aGUgc2V0IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgKiBvclxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSBlbGVtZW50IChFbGVtZW50KSBzcGVjaWZpYyBlbGVtZW50IGluIHRoZSBzZXQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICAtIGVhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCB0byBiaW5kIHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgPSAob2JqZWN0KSBTZXQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmJpbmQgPSBmdW5jdGlvbiAoYXR0ciwgYSwgYikge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2F0dHJdID0gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmFtZSA9IGIgfHwgYXR0cjtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbYXR0cl0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGRhdGFbYW5hbWVdID0gdjtcbiAgICAgICAgICAgICAgICBhLmF0dHIoZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hdHRyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IG9mIEBFbGVtZW50LmF0dHIuXG4gICAgID0gKG9iamVjdCkgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5hdHRyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB1bmJvdW5kID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW2tdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1trXSh2YWx1ZVtrXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuYm91bmRba10gPSB2YWx1ZVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uYXR0cih1bmJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuY2xlYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnNwbGljZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyByYW5nZSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBpbmRleCAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgZGVsZXRpb25cbiAgICAgLSBjb3VudCAobnVtYmVyKSBudW1iZXIgb2YgZWxlbWVudCB0byByZW1vdmVcbiAgICAgLSBpbnNlcnRpb27igKYgKG9iamVjdCkgI29wdGlvbmFsIGVsZW1lbnRzIHRvIGluc2VydFxuICAgICA9IChvYmplY3QpIHNldCBlbGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5zcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBpbnNlcnRpb24pIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBtbWF4KHRoaXMubGVuZ3RoICsgaW5kZXgsIDApIDogaW5kZXg7XG4gICAgICAgIGNvdW50ID0gbW1heCgwLCBtbWluKHRoaXMubGVuZ3RoIC0gaW5kZXgsIGNvdW50KSk7XG4gICAgICAgIHZhciB0YWlsID0gW10sXG4gICAgICAgICAgICB0b2RlbCA9IFtdLFxuICAgICAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvZGVsLnB1c2godGhpc1tpbmRleCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdGFpbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuICsgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleCArIGldID0gdGhpc1tpbmRleCArIGldID0gaSA8IGFyZ2xlbiA/IGFyZ3NbaV0gOiB0YWlsW2kgLSBhcmdsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCA9IHRoaXMubGVuZ3RoIC09IGNvdW50IC0gYXJnbGVuO1xuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldCh0b2RlbCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmV4Y2x1ZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBvYmplY3Qgd2FzIGZvdW5kIGFuZCByZW1vdmVkIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5leGNsdWRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKHRoaXNbaV0gPT0gZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5pbnNlcnRBZnRlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyBzZXQgZWxlbWVudHMgYWZ0ZXIgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIHNldCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIHRoaXMgZWxlbWVudFxuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5pbnNlcnRBZnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFVuaW9uIG9mIGFsbCBiYm94ZXMgb2YgdGhlIHNldC4gU2VlIEBFbGVtZW50LmdldEJCb3guXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94IGRlc2NyaXB0b3IuIFNlZSBARWxlbWVudC5nZXRCQm94LlxuICAgIFxcKi9cbiAgICBzZXRwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCA9IFtdLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgeDIgPSBbXSxcbiAgICAgICAgICAgIHkyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaS0tOykgaWYgKCF0aGlzLml0ZW1zW2ldLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLml0ZW1zW2ldLmdldEJCb3goKTtcbiAgICAgICAgICAgIHgucHVzaChib3gueCk7XG4gICAgICAgICAgICB5LnB1c2goYm94LnkpO1xuICAgICAgICAgICAgeDIucHVzaChib3gueCArIGJveC53aWR0aCk7XG4gICAgICAgICAgICB5Mi5wdXNoKGJveC55ICsgYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IG1taW4uYXBwbHkoMCwgeCk7XG4gICAgICAgIHkgPSBtbWluLmFwcGx5KDAsIHkpO1xuICAgICAgICB4MiA9IG1tYXguYXBwbHkoMCwgeDIpO1xuICAgICAgICB5MiA9IG1tYXguYXBwbHkoMCwgeTIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHksXG4gICAgICAgICAgICBjeDogeCArICh4MiAtIHgpIC8gMixcbiAgICAgICAgICAgIGN5OiB5ICsgKHkyIC0geSkgLyAyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0Lmluc2VydEFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIHNldC5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBOZXcgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbG9uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMgPSBuZXcgU2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHMucHVzaCh0aGlzLml0ZW1zW2ldLmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgc2V0cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNuYXBcXHUyMDE4cyBzZXRcIjtcbiAgICB9O1xuICAgIHNldHByb3RvLnR5cGUgPSBcInNldFwiO1xuICAgIC8vIGV4cG9ydFxuICAgIC8qXFxcbiAgICAgKiBTbmFwLlNldFxuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBTZXQgY29uc3RydWN0b3IuXG4gICAgXFwqL1xuICAgIFNuYXAuU2V0ID0gU2V0O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnNldFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBhbmQgZmlsbHMgaXQgd2l0aCBsaXN0IG9mIGFyZ3VtZW50cy5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBOZXcgU2V0IG9iamVjdFxuICAgICB8IHZhciByID0gcGFwZXIucmVjdCgwLCAwLCAxMCwgMTApLFxuICAgICB8ICAgICBzMSA9IFNuYXAuc2V0KCksIC8vIGVtcHR5IHNldFxuICAgICB8ICAgICBzMiA9IFNuYXAuc2V0KHIsIHBhcGVyLmNpcmNsZSgxMDAsIDEwMCwgMjApKTsgLy8gcHJlZmlsbGVkIHNldFxuICAgIFxcKi9cbiAgICBTbmFwLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXQucHVzaC5hcHBseShzZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbmFtZXMgPSB7fSxcbiAgICAgICAgcmVVbml0ID0gL1slYS16XSskL2ksXG4gICAgICAgIFN0ciA9IFN0cmluZztcbiAgICBuYW1lcy5zdHJva2UgPSBuYW1lcy5maWxsID0gXCJjb2xvdXJcIjtcbiAgICBmdW5jdGlvbiBnZXRFbXB0eShpdGVtKSB7XG4gICAgICAgIHZhciBsID0gaXRlbVswXTtcbiAgICAgICAgc3dpdGNoIChsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6IHJldHVybiBbbCwgMCwgMF07XG4gICAgICAgICAgICBjYXNlIFwibVwiOiByZXR1cm4gW2wsIDEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgY2FzZSBcInJcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDAsIGl0ZW1bMl0sIGl0ZW1bM11dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDEsIDEsIGl0ZW1bM10sIGl0ZW1bNF1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxLCAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbGlzZVRyYW5zZm9ybSh0MSwgdDIsIGdldEJCb3gpIHtcbiAgICAgICAgdDEgPSB0MSB8fCBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgIHQyID0gdDIgfHwgbmV3IFNuYXAuTWF0cml4O1xuICAgICAgICB0MSA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcodDEudG9UcmFuc2Zvcm1TdHJpbmcoKSkgfHwgW107XG4gICAgICAgIHQyID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0Mi50b1RyYW5zZm9ybVN0cmluZygpKSB8fCBbXTtcbiAgICAgICAgdmFyIG1heGxlbmd0aCA9IE1hdGgubWF4KHQxLmxlbmd0aCwgdDIubGVuZ3RoKSxcbiAgICAgICAgICAgIGZyb20gPSBbXSxcbiAgICAgICAgICAgIHRvID0gW10sXG4gICAgICAgICAgICBpID0gMCwgaiwgamosXG4gICAgICAgICAgICB0dDEsIHR0MjtcbiAgICAgICAgZm9yICg7IGkgPCBtYXhsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHQxID0gdDFbaV0gfHwgZ2V0RW1wdHkodDJbaV0pO1xuICAgICAgICAgICAgdHQyID0gdDJbaV0gfHwgZ2V0RW1wdHkodHQxKTtcbiAgICAgICAgICAgIGlmICh0dDFbMF0gIT0gdHQyWzBdIHx8XG4gICAgICAgICAgICAgICAgdHQxWzBdLnRvTG93ZXJDYXNlKCkgPT0gXCJyXCIgJiYgKHR0MVsyXSAhPSB0dDJbMl0gfHwgdHQxWzNdICE9IHR0MlszXSkgfHxcbiAgICAgICAgICAgICAgICB0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInNcIiAmJiAodHQxWzNdICE9IHR0MlszXSB8fCB0dDFbNF0gIT0gdHQyWzRdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IFNuYXAuXy50cmFuc2Zvcm0ybWF0cml4KHQxLCBnZXRCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICB0MiA9IFNuYXAuXy50cmFuc2Zvcm0ybWF0cml4KHQyLCBnZXRCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gW1tcIm1cIiwgdDEuYSwgdDEuYiwgdDEuYywgdDEuZCwgdDEuZSwgdDEuZl1dO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFtbXCJtXCIsIHQyLmEsIHQyLmIsIHQyLmMsIHQyLmQsIHQyLmUsIHQyLmZdXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tW2ldID0gW107XG4gICAgICAgICAgICB0b1tpXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBNYXRoLm1heCh0dDEubGVuZ3RoLCB0dDIubGVuZ3RoKTsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBqIGluIHR0MSAmJiAoZnJvbVtpXVtqXSA9IHR0MVtqXSk7XG4gICAgICAgICAgICAgICAgaiBpbiB0dDIgJiYgKHRvW2ldW2pdID0gdHQyW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShmcm9tKSxcbiAgICAgICAgICAgIHRvOiBwYXRoMmFycmF5KHRvKSxcbiAgICAgICAgICAgIGY6IGdldFBhdGgoZnJvbSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVbml0KHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiArdmFsLnRvRml4ZWQoMykgKyB1bml0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaWV3Qm94KHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb2xvdXIoY2xyKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnJnYihjbHJbMF0sIGNsclsxXSwgY2xyWzJdLCBjbHJbM10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQYXRoKHBhdGgpIHtcbiAgICAgICAgdmFyIGsgPSAwLCBpLCBpaSwgaiwgamosIG91dCwgYSwgYiA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgb3V0ID0gXCJbXCI7XG4gICAgICAgICAgICBhID0gWydcIicgKyBwYXRoW2ldWzBdICsgJ1wiJ107XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGFbal0gPSBcInZhbFtcIiArIGsrKyArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IGEgKyBcIl1cIjtcbiAgICAgICAgICAgIGJbaV0gPSBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKFwidmFsXCIsIFwicmV0dXJuIFNuYXAucGF0aC50b1N0cmluZy5jYWxsKFtcIiArIGIgKyBcIl0pXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoMmFycmF5KHBhdGgpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHBhdGhbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICAgICAgICBpZiAoIVNuYXAuaXMoYXJyMSwgXCJhcnJheVwiKSB8fCAhU25hcC5pcyhhcnIyLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjEudG9TdHJpbmcoKSA9PSBhcnIyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIEVsZW1lbnQucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKG5hbWUsIGIpIHtcbiAgICAgICAgcmV0dXJuIGV2ZShcInNuYXAudXRpbC5lcXVhbFwiLCB0aGlzLCBuYW1lLCBiKS5maXJzdERlZmluZWQoKTtcbiAgICB9O1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5lcXVhbFwiLCBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICB2YXIgQSwgQiwgYSA9IFN0cih0aGlzLmF0dHIobmFtZSkgfHwgXCJcIiksXG4gICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIGlmIChuYW1lc1tuYW1lXSA9PSBcImNvbG91clwiKSB7XG4gICAgICAgICAgICBBID0gU25hcC5jb2xvcihhKTtcbiAgICAgICAgICAgIEIgPSBTbmFwLmNvbG9yKGIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBbQS5yLCBBLmcsIEEuYiwgQS5vcGFjaXR5XSxcbiAgICAgICAgICAgICAgICB0bzogW0IuciwgQi5nLCBCLmIsIEIub3BhY2l0eV0sXG4gICAgICAgICAgICAgICAgZjogZ2V0Q29sb3VyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidmlld0JveFwiKSB7XG4gICAgICAgICAgICBBID0gdGhpcy5hdHRyKG5hbWUpLnZiLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIEIgPSBiLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogQSxcbiAgICAgICAgICAgICAgICB0bzogQixcbiAgICAgICAgICAgICAgICBmOiBnZXRWaWV3Qm94XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcImdyYWRpZW50VHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcInBhdHRlcm5UcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBiID0gU3RyKGIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IHRoaXMubWF0cml4O1xuICAgICAgICAgICAgaWYgKCFTbmFwLl8ucmdUcmFuc2Zvcm0udGVzdChiKSkge1xuICAgICAgICAgICAgICAgIGIgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeChTbmFwLl8uc3ZnVHJhbnNmb3JtMnN0cmluZyhiKSwgdGhpcy5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiID0gU25hcC5fLnRyYW5zZm9ybTJtYXRyaXgoYiwgdGhpcy5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVxdWFsaXNlVHJhbnNmb3JtKGEsIGIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QkJveCgxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwiZFwiIHx8IG5hbWUgPT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIEEgPSBTbmFwLnBhdGgudG9DdWJpYyhhLCBiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShBWzBdKSxcbiAgICAgICAgICAgICAgICB0bzogcGF0aDJhcnJheShBWzFdKSxcbiAgICAgICAgICAgICAgICBmOiBnZXRQYXRoKEFbMF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgICAgIEEgPSBTdHIoYSkuc3BsaXQoU25hcC5fLnNlcGFyYXRvcik7XG4gICAgICAgICAgICBCID0gU3RyKGIpLnNwbGl0KFNuYXAuXy5zZXBhcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBBLFxuICAgICAgICAgICAgICAgIHRvOiBCLFxuICAgICAgICAgICAgICAgIGY6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1lcmljKGEpICYmIGlzTnVtZXJpYyhiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgIHRvOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYVVuaXQgPSBhLm1hdGNoKHJlVW5pdCksXG4gICAgICAgICAgICBiVW5pdCA9IFN0cihiKS5tYXRjaChyZVVuaXQpO1xuICAgICAgICBpZiAoYVVuaXQgJiYgYXJyYXlFcXVhbChhVW5pdCwgYlVuaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHBhcnNlRmxvYXQoYSksXG4gICAgICAgICAgICAgICAgdG86IHBhcnNlRmxvYXQoYiksXG4gICAgICAgICAgICAgICAgZjogZ2V0VW5pdChhVW5pdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYXNQWChuYW1lKSxcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hc1BYKG5hbWUsIGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIHN1cHBvcnRzVG91Y2ggPSBcImNyZWF0ZVRvdWNoXCIgaW4gZ2xvYi5kb2MsXG4gICAgZXZlbnRzID0gW1xuICAgICAgICBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZWRvd25cIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLFxuICAgICAgICBcIm1vdXNlb3ZlclwiLCBcIm1vdXNldXBcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIixcbiAgICAgICAgXCJ0b3VjaGNhbmNlbFwiXG4gICAgXSxcbiAgICB0b3VjaE1hcCA9IHtcbiAgICAgICAgbW91c2Vkb3duOiBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgbW91c2Vtb3ZlOiBcInRvdWNobW92ZVwiLFxuICAgICAgICBtb3VzZXVwOiBcInRvdWNoZW5kXCJcbiAgICB9LFxuICAgIGdldFNjcm9sbCA9IGZ1bmN0aW9uICh4eSwgZWwpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB4eSA9PSBcInlcIiA/IFwic2Nyb2xsVG9wXCIgOiBcInNjcm9sbExlZnRcIixcbiAgICAgICAgICAgIGRvYyA9IGVsICYmIGVsLm5vZGUgPyBlbC5ub2RlLm93bmVyRG9jdW1lbnQgOiBnbG9iLmRvYztcbiAgICAgICAgcmV0dXJuIGRvY1tuYW1lIGluIGRvYy5kb2N1bWVudEVsZW1lbnQgPyBcImRvY3VtZW50RWxlbWVudFwiIDogXCJib2R5XCJdW25hbWVdO1xuICAgIH0sXG4gICAgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9LFxuICAgIHByZXZlbnRUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBzdG9wVG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciByZWFsTmFtZSA9IHN1cHBvcnRzVG91Y2ggJiYgdG91Y2hNYXBbdHlwZV0gPyB0b3VjaE1hcFt0eXBlXSA6IHR5cGUsXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IGdldFNjcm9sbChcInlcIiwgZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW2hhc10odHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzW2ldLnRhcmdldCA9PSBvYmogfHwgb2JqLmNvbnRhaW5zKGUudGFyZ2V0VG91Y2hlc1tpXS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZGUgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRhcmdldFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ID0gb2xkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gcHJldmVudFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5jbGllbnRYICsgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGUuY2xpZW50WSArIHNjcm9sbFk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbWVudCwgZSwgeCwgeSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlICE9PSByZWFsTmFtZSkge1xuICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIocmVhbE5hbWUsIGYsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHJlYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWFsTmFtZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkcmFnID0gW10sXG4gICAgZHJhZ01vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgICBzY3JvbGxZID0gZ2V0U2Nyb2xsKFwieVwiKSxcbiAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIpLFxuICAgICAgICAgICAgZHJhZ2ksXG4gICAgICAgICAgICBqID0gZHJhZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIGRyYWdpID0gZHJhZ1tqXTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaCA9IGUudG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT0gZHJhZ2kuZWwuX2RyYWcuaWQgfHwgZHJhZ2kuZWwubm9kZS5jb250YWlucyh0b3VjaC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCA/IGUub3JpZ2luYWxFdmVudCA6IGUpLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkcmFnaS5lbC5ub2RlLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIC8vIG8gPSBkcmFnaS5lbC5wYXBlci5nZXRFbGVtZW50QnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiAobmV4dCA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgLy8gbyAmJiBldmUoXCJzbmFwLmRyYWcub3Zlci5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbCwgbyk7XG4gICAgICAgICAgICB4ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICB5ICs9IHNjcm9sbFk7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcubW92ZS5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5tb3ZlX3Njb3BlIHx8IGRyYWdpLmVsLCB4IC0gZHJhZ2kuZWwuX2RyYWcueCwgeSAtIGRyYWdpLmVsLl9kcmFnLnksIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkcmFnVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBTbmFwLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgdmFyIGkgPSBkcmFnLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbaV07XG4gICAgICAgICAgICBkcmFnaS5lbC5fZHJhZyA9IHt9O1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnLmVuZC5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbmRfc2NvcGUgfHwgZHJhZ2kuc3RhcnRfc2NvcGUgfHwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgZSk7XG4gICAgICAgICAgICBldmUub2ZmKFwic25hcC5kcmFnLiouXCIgKyBkcmFnaS5lbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZyA9IFtdO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBjbGljayBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBkb3VibGUgY2xpY2sgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmRibGNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgZG91YmxlIGNsaWNrIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZWRvd24gZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlZG93blxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlZG93biBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2Vtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2Vtb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2VvdXQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2VvdXQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNlb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2VvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2VvdmVyIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZXVwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2V1cCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNldXAgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaHN0YXJ0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaHN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hzdGFydCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2htb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaG1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hjYW5jZWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hjYW5jZWwgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGZvciAodmFyIGkgPSBldmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBTbmFwW2V2ZW50TmFtZV0gPSBlbHByb3RvW2V2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNuYXAuaXMoZm4sIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmOiBmbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZDogYWRkRXZlbnQodGhpcy5ub2RlIHx8IGRvY3VtZW50LCBldmVudE5hbWUsIGZuLCBzY29wZSB8fCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAodGhpcy5ldmVudHNbaV0ubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbaV0uZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTbmFwW1widW5cIiArIGV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgZWxwcm90b1tcInVuXCIgKyBldmVudE5hbWVdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBsID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobC0tKSBpZiAoZXZlbnRzW2xdLm5hbWUgPT0gZXZlbnROYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50c1tsXS5mID09IGZuIHx8ICFmbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzW2xdLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaWNlKGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAhZXZlbnRzLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5ldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50c1tpXSk7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmhvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGhvdmVyIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gZl9pbiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIGluXG4gICAgIC0gZl9vdXQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBvdXRcbiAgICAgLSBpY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgaG92ZXIgaW4gaGFuZGxlclxuICAgICAtIG9jb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBob3ZlciBvdXQgaGFuZGxlclxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaG92ZXIgPSBmdW5jdGlvbiAoZl9pbiwgZl9vdXQsIHNjb3BlX2luLCBzY29wZV9vdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VvdmVyKGZfaW4sIHNjb3BlX2luKS5tb3VzZW91dChmX291dCwgc2NvcGVfb3V0IHx8IHNjb3BlX2luKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuaG92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgaG92ZXIgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGZfaW4gKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBpblxuICAgICAtIGZfb3V0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgb3V0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51bmhvdmVyID0gZnVuY3Rpb24gKGZfaW4sIGZfb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVubW91c2VvdmVyKGZfaW4pLnVubW91c2VvdXQoZl9vdXQpO1xuICAgIH07XG4gICAgdmFyIGRyYWdnYWJsZSA9IFtdO1xuICAgIC8vIFNJRVJSQSB1bmNsZWFyIHdoYXQgX2NvbnRleHRfIHJlZmVycyB0byBmb3Igc3RhcnRpbmcsIGVuZGluZywgbW92aW5nIHRoZSBkcmFnIGdlc3R1cmUuXG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZHJhZygpOiBfeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VfOiBXaGVyZSBhcmUgdGhlIHgveSB2YWx1ZXMgb2Zmc2V0IGZyb20/XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZHJhZygpOiBtdWNoIG9mIHRoaXMgbWVtYmVyJ3MgZG9jIGFwcGVhcnMgdG8gYmUgZHVwbGljYXRlZCBmb3Igc29tZSByZWFzb24uXG4gICAgLy8gU0lFUlJBIFVuY2xlYXIgYWJvdXQgdGhpcyBzZW50ZW5jZTogX0FkZGl0aW9uYWxseSBmb2xsb3dpbmcgZHJhZyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQ6IGRyYWcuc3RhcnQuPGlkPiBvbiBzdGFydCwgZHJhZy5lbmQuPGlkPiBvbiBlbmQgYW5kIGRyYWcubW92ZS48aWQ+IG9uIGV2ZXJ5IG1vdmUuXyBJcyB0aGVyZSBhIGdsb2JhbCBfZHJhZ18gb2JqZWN0IHRvIHdoaWNoIHlvdSBjYW4gYXNzaWduIGhhbmRsZXJzIGtleWVkIGJ5IGFuIGVsZW1lbnQncyBJRD9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kcmFnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBhbiBlbGVtZW50J3MgZHJhZyBnZXN0dXJlXG4gICAgICoqXG4gICAgIC0gb25tb3ZlIChmdW5jdGlvbikgaGFuZGxlciBmb3IgbW92aW5nXG4gICAgIC0gb25zdGFydCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGRyYWcgc3RhcnRcbiAgICAgLSBvbmVuZCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGRyYWcgZW5kXG4gICAgIC0gbWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIG1vdmluZyBoYW5kbGVyXG4gICAgIC0gc2NvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGRyYWcgc3RhcnQgaGFuZGxlclxuICAgICAtIGVjb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBkcmFnIGVuZCBoYW5kbGVyXG4gICAgICogQWRkaXRpb25hbHkgZm9sbG93aW5nIGBkcmFnYCBldmVudHMgYXJlIHRyaWdnZXJlZDogYGRyYWcuc3RhcnQuPGlkPmAgb24gc3RhcnQsIFxuICAgICAqIGBkcmFnLmVuZC48aWQ+YCBvbiBlbmQgYW5kIGBkcmFnLm1vdmUuPGlkPmAgb24gZXZlcnkgbW92ZS4gV2hlbiBlbGVtZW50IGlzIGRyYWdnZWQgb3ZlciBhbm90aGVyIGVsZW1lbnQgXG4gICAgICogYGRyYWcub3Zlci48aWQ+YCBmaXJlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogU3RhcnQgZXZlbnQgYW5kIHN0YXJ0IGhhbmRsZXIgYXJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogTW92ZSBldmVudCBhbmQgbW92ZSBoYW5kbGVyIGFyZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIGR4IChudW1iZXIpIHNoaWZ0IGJ5IHggZnJvbSB0aGUgc3RhcnQgcG9pbnRcbiAgICAgbyBkeSAobnVtYmVyKSBzaGlmdCBieSB5IGZyb20gdGhlIHN0YXJ0IHBvaW50XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogRW5kIGV2ZW50IGFuZCBlbmQgaGFuZGxlciBhcmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5kcmFnID0gZnVuY3Rpb24gKG9ubW92ZSwgb25zdGFydCwgb25lbmQsIG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ1RyYW5zZm9ybTtcbiAgICAgICAgICAgIHJldHVybiBlbC5kcmFnKGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IG9yaWdUcmFuc2Zvcm0gKyAob3JpZ1RyYW5zZm9ybSA/IFwiVFwiIDogXCJ0XCIpICsgW2R4LCBkeV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvcmlnVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0oKS5sb2NhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0KGUsIHgsIHkpIHtcbiAgICAgICAgICAgIChlLm9yaWdpbmFsRXZlbnQgfHwgZSkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVsLl9kcmFnLnggPSB4O1xuICAgICAgICAgICAgZWwuX2RyYWcueSA9IHk7XG4gICAgICAgICAgICBlbC5fZHJhZy5pZCA9IGUuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICFkcmFnLmxlbmd0aCAmJiBTbmFwLm1vdXNlbW92ZShkcmFnTW92ZSkubW91c2V1cChkcmFnVXApO1xuICAgICAgICAgICAgZHJhZy5wdXNoKHtlbDogZWwsIG1vdmVfc2NvcGU6IG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlOiBzdGFydF9zY29wZSwgZW5kX3Njb3BlOiBlbmRfc2NvcGV9KTtcbiAgICAgICAgICAgIG9uc3RhcnQgJiYgZXZlLm9uKFwic25hcC5kcmFnLnN0YXJ0LlwiICsgZWwuaWQsIG9uc3RhcnQpO1xuICAgICAgICAgICAgb25tb3ZlICYmIGV2ZS5vbihcInNuYXAuZHJhZy5tb3ZlLlwiICsgZWwuaWQsIG9ubW92ZSk7XG4gICAgICAgICAgICBvbmVuZCAmJiBldmUub24oXCJzbmFwLmRyYWcuZW5kLlwiICsgZWwuaWQsIG9uZW5kKTtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZy5zdGFydC5cIiArIGVsLmlkLCBzdGFydF9zY29wZSB8fCBtb3ZlX3Njb3BlIHx8IGVsLCB4LCB5LCBlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KGUsIHgsIHkpIHtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZ2luaXQuXCIgKyBlbC5pZCwgZWwsIGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAuZHJhZ2luaXQuXCIgKyBlbC5pZCwgc3RhcnQpO1xuICAgICAgICBlbC5fZHJhZyA9IHt9O1xuICAgICAgICBkcmFnZ2FibGUucHVzaCh7ZWw6IGVsLCBzdGFydDogc3RhcnQsIGluaXQ6IGluaXR9KTtcbiAgICAgICAgZWwubW91c2Vkb3duKGluaXQpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIEVsZW1lbnQub25EcmFnT3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2hvcnRjdXQgdG8gYXNzaWduIGV2ZW50IGhhbmRsZXIgZm9yIGBkcmFnLm92ZXIuPGlkPmAgZXZlbnQsIHdoZXJlIGBpZGAgaXMgdGhlIGVsZW1lbnQncyBgaWRgIChzZWUgQEVsZW1lbnQuaWQpXG4gICAgIC0gZiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGV2ZW50LCBmaXJzdCBhcmd1bWVudCB3b3VsZCBiZSB0aGUgZWxlbWVudCB5b3UgYXJlIGRyYWdnaW5nIG92ZXJcbiAgICBcXCovXG4gICAgLy8gZWxwcm90by5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGYpIHtcbiAgICAvLyAgICAgZiA/IGV2ZS5vbihcInNuYXAuZHJhZy5vdmVyLlwiICsgdGhpcy5pZCwgZikgOiBldmUudW5iaW5kKFwic25hcC5kcmFnLm92ZXIuXCIgKyB0aGlzLmlkKTtcbiAgICAvLyB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZHJhZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgZHJhZyBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udW5kcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IGRyYWdnYWJsZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIGlmIChkcmFnZ2FibGVbaV0uZWwgPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy51bm1vdXNlZG93bihkcmFnZ2FibGVbaV0uaW5pdCk7XG4gICAgICAgICAgICBkcmFnZ2FibGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgZXZlLnVuYmluZChcInNuYXAuZHJhZy4qLlwiICsgdGhpcy5pZCk7XG4gICAgICAgICAgICBldmUudW5iaW5kKFwic25hcC5kcmFnaW5pdC5cIiArIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgICFkcmFnZ2FibGUubGVuZ3RoICYmIFNuYXAudW5tb3VzZW1vdmUoZHJhZ01vdmUpLnVubW91c2V1cChkcmFnVXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIHBwcm90byA9IFBhcGVyLnByb3RvdHlwZSxcbiAgICAgICAgcmd1cmwgPSAvXlxccyp1cmxcXCgoLispXFwpLyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICAkID0gU25hcC5fLiQ7XG4gICAgU25hcC5maWx0ZXIgPSB7fTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZmlsdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxmaWx0ZXI+YCBlbGVtZW50XG4gICAgICoqXG4gICAgIC0gZmlsc3RyIChzdHJpbmcpIFNWRyBmcmFnbWVudCBvZiBmaWx0ZXIgcHJvdmlkZWQgYXMgYSBzdHJpbmdcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgICAqIE5vdGU6IEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBmaWx0ZXJzIGVtYmVkZGVkIGludG8gdGhlIHBhZ2UgaW5zaWRlIGFuIGVtcHR5IFNWRyBlbGVtZW50LlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGYgPSBwYXBlci5maWx0ZXIoJzxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCIyXCIvPicpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBwcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gKGZpbHN0cikge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzO1xuICAgICAgICBpZiAocGFwZXIudHlwZSAhPSBcInN2Z1wiKSB7XG4gICAgICAgICAgICBwYXBlciA9IHBhcGVyLnBhcGVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gU25hcC5wYXJzZShTdHIoZmlsc3RyKSksXG4gICAgICAgICAgICBpZCA9IFNuYXAuXy5pZCgpLFxuICAgICAgICAgICAgd2lkdGggPSBwYXBlci5ub2RlLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gcGFwZXIubm9kZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBmaWx0ZXIgPSAkKFwiZmlsdGVyXCIpO1xuICAgICAgICAkKGZpbHRlciwge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZmlsdGVyVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGYubm9kZSk7XG4gICAgICAgIHBhcGVyLmRlZnMuYXBwZW5kQ2hpbGQoZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGZpbHRlcik7XG4gICAgfTtcblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZmlsdGVyXCIpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gU3RyKHApLm1hdGNoKHJndXJsKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBTbmFwLnNlbGVjdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5maWx0ZXJcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdmFsdWUudHlwZSA9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIGlkID0gdmFsdWUubm9kZS5pZDtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtpZDogdmFsdWUuaWR9KTtcbiAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IFNuYXAudXJsKGlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuYmx1clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGJsdXIgZmlsdGVyXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSBhbW91bnQgb2YgaG9yaXpvbnRhbCBibHVyLCBpbiBwaXhlbHNcbiAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgdmVydGljYWwgYmx1ciwgaW4gcGl4ZWxzXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcihTbmFwLmZpbHRlci5ibHVyKDUsIDEwKSksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJsdXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0geSA9PSBudWxsID8geCA6IFt4LCB5XTtcbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCdcXDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCJ7ZGVmfVwiLz4nLCB7XG4gICAgICAgICAgICBkZWY6IGRlZlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJsdXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2hhZG93XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2hhZG93IGZpbHRlclxuICAgICAqKlxuICAgICAtIGR4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGR5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBibHVyIChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgYmx1clxuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIG9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIHdoaWNoIG1ha2VzIGJsdXIgZGVmYXVsdCB0byBgNGAuIE9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIG9wYWNpdHkgKG51bWJlcikgI29wdGlvbmFsIGAwLi4xYCBvcGFjaXR5IG9mIHRoZSBzaGFkb3dcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKFNuYXAuZmlsdGVyLnNoYWRvdygwLCAyLCAuMykpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zaGFkb3cgPSBmdW5jdGlvbiAoZHgsIGR5LCBibHVyLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICBpZiAob3BhY2l0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBibHVyO1xuICAgICAgICAgICAgICAgIGJsdXIgPSA0O1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGJsdXI7XG4gICAgICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IFNuYXAuY29sb3IoY29sb3IpO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwie2JsdXJ9XCIvPjxmZU9mZnNldCBkeD1cIntkeH1cIiBkeT1cIntkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPjxmZUZsb29kIGZsb29kLWNvbG9yPVwie2NvbG9yfVwiLz48ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1clwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY0EgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie29wYWNpdHl9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+PC9mZU1lcmdlPicsIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeSxcbiAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2hhZG93LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmdyYXlzY2FsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGdyYXlzY2FsZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7Yn0ge2h9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4yMTI2ICsgMC43ODc0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43MTUyIC0gMC43MTUyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC43MTUyICsgMC4yODQ4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC4wNzIyICsgMC45Mjc4ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuZ3JheXNjYWxlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLnNlcGlhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2VwaWEgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuc2VwaWEgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7aH0ge2l9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4zOTMgKyAwLjYwNyAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzY5IC0gMC43NjkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjE4OSAtIDAuMTg5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4zNDkgLSAwLjM0OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNjg2ICsgMC4zMTQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjE2OCAtIDAuMTY4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yNzIgLSAwLjI3MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuNTM0IC0gMC41MzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBpOiAwLjEzMSArIDAuODY5ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2VwaWEudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2F0dXJhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzYXR1cmF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwie2Ftb3VudH1cIi8+Jywge1xuICAgICAgICAgICAgYW1vdW50OiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2F0dXJhdGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuaHVlUm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgaHVlLXJvdGF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvblxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5odWVSb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJodWVSb3RhdGVcIiB2YWx1ZXM9XCJ7YW5nbGV9XCIvPicsIHtcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmh1ZVJvdGF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5pbnZlcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBpbnZlcnQgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbi8vICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPVwibWF0cml4XCIgdmFsdWVzPVwiLTEgMCAwIDAgMSAgMCAtMSAwIDAgMSAgMCAwIC0xIDAgMSAgMCAwIDAgMSAwXCIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPVwic1JHQlwiLz5cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+Jywge1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmJyaWdodG5lc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBicmlnaHRuZXNzIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuY29udHJhc3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBjb250cmFzdCBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5jb250cmFzdCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPicsIHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogLjUgLSBhbW91bnQgLyAyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuY29udHJhc3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGJveCA9IFNuYXAuXy5ib3gsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgZmlyc3RMZXR0ZXIgPSAvXlteYS16XSooW3RibWxyY10pL2ksXG4gICAgICAgIHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVFwiICsgdGhpcy5keCArIFwiLFwiICsgdGhpcy5keTtcbiAgICAgICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRBbGlnblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzaGlmdCBuZWVkZWQgdG8gYWxpZ24gdGhlIGVsZW1lbnQgcmVsYXRpdmVseSB0byBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIG5vIGVsZW1lbnRzIHNwZWNpZmllZCwgcGFyZW50IGA8c3ZnPmAgY29udGFpbmVyIHdpbGwgYmUgdXNlZC5cbiAgICAgLSBlbCAob2JqZWN0KSBAb3B0aW9uYWwgYWxpZ25tZW50IGVsZW1lbnRcbiAgICAgLSB3YXkgKHN0cmluZykgb25lIG9mIHNpeCB2YWx1ZXM6IGBcInRvcFwiYCwgYFwibWlkZGxlXCJgLCBgXCJib3R0b21cImAsIGBcImxlZnRcImAsIGBcImNlbnRlclwiYCwgYFwicmlnaHRcImBcbiAgICAgPSAob2JqZWN0fHN0cmluZykgT2JqZWN0IGluIGZvcm1hdCBge2R4OiAsIGR5OiB9YCBhbHNvIGhhcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBhIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgICA+IFVzYWdlXG4gICAgIHwgZWwudHJhbnNmb3JtKGVsLmdldEFsaWduKGVsMiwgXCJ0b3BcIikpO1xuICAgICAqIG9yXG4gICAgIHwgdmFyIGR5ID0gZWwuZ2V0QWxpZ24oZWwyLCBcInRvcFwiKS5keTtcbiAgICBcXCovXG4gICAgRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxpZ24gPSBmdW5jdGlvbiAoZWwsIHdheSkge1xuICAgICAgICBpZiAod2F5ID09IG51bGwgJiYgaXMoZWwsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB3YXkgPSBlbDtcbiAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBieCA9IGVsLmdldEJCb3ggPyBlbC5nZXRCQm94KCkgOiBib3goZWwpLFxuICAgICAgICAgICAgYmIgPSB0aGlzLmdldEJCb3goKSxcbiAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICB3YXkgPSB3YXkgJiYgd2F5Lm1hdGNoKGZpcnN0TGV0dGVyKTtcbiAgICAgICAgd2F5ID0gd2F5ID8gd2F5WzFdLnRvTG93ZXJDYXNlKCkgOiBcImNcIjtcbiAgICAgICAgc3dpdGNoICh3YXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC55IC0gYmIueTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSAwO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IGJ4LnkyIC0gYmIueTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC5jeSAtIGJiLmN5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LnggLSBiYi54O1xuICAgICAgICAgICAgICAgIG91dC5keSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gYngueDIgLSBiYi54MjtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LmN4IC0gYmIuY3g7XG4gICAgICAgICAgICAgICAgb3V0LmR5ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG91dC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWxpZ25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFsaWducyB0aGUgZWxlbWVudCByZWxhdGl2ZWx5IHRvIGdpdmVuIG9uZSB2aWEgdHJhbnNmb3JtYXRpb24uXG4gICAgICogSWYgbm8gZWxlbWVudHMgc3BlY2lmaWVkLCBwYXJlbnQgYDxzdmc+YCBjb250YWluZXIgd2lsbCBiZSB1c2VkLlxuICAgICAtIGVsIChvYmplY3QpIEBvcHRpb25hbCBhbGlnbm1lbnQgZWxlbWVudFxuICAgICAtIHdheSAoc3RyaW5nKSBvbmUgb2Ygc2l4IHZhbHVlczogYFwidG9wXCJgLCBgXCJtaWRkbGVcImAsIGBcImJvdHRvbVwiYCwgYFwibGVmdFwiYCwgYFwiY2VudGVyXCJgLCBgXCJyaWdodFwiYFxuICAgICA9IChvYmplY3QpIHRoaXMgZWxlbWVudFxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYWxpZ24oZWwyLCBcInRvcFwiKTtcbiAgICAgKiBvclxuICAgICB8IGVsLmFsaWduKFwibWlkZGxlXCIpO1xuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hbGlnbiA9IGZ1bmN0aW9uIChlbCwgd2F5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShcIi4uLlwiICsgdGhpcy5nZXRBbGlnbihlbCwgd2F5KSk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIjtcbiAgICBmdW5jdGlvbiBzbGljZShmcm9tLCB0bywgZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGFyci5zbGljZShmcm9tLCB0byk7XG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYgPyBmKHJlcykgOiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMuZHVyID0gbXM7XG4gICAgICAgIGVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBlYXNpbmcpO1xuICAgICAgICBjYWxsYmFjayAmJiAodGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFNuYXAuXy5BbmltYXRpb24gPSBBbmltYXRpb247XG4gICAgLypcXFxuICAgICAqIFNuYXAuYW5pbWF0aW9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFuIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgLSBhdHRyIChvYmplY3QpIGF0dHJpYnV0ZXMgb2YgZmluYWwgZGVzdGluYXRpb25cbiAgICAgLSBkdXJhdGlvbiAobnVtYmVyKSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgb25lIG9mIGVhc2luZyBmdW5jdGlvbnMgb2YgQG1pbmEgb3IgY3VzdG9tIG9uZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiBhbmltYXRpb24gZW5kc1xuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3RcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5BbmltXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGEgc2V0IG9mIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgYWJsZSB0byBtYW5pcHVsYXRlIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBhbmltIChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3QsXG4gICAgIG8gICAgIG1pbmEgKG9iamVjdCkgQG1pbmEgb2JqZWN0LFxuICAgICBvICAgICBjdXJTdGF0dXMgKG51bWJlcikgMC4uMSDigJQgc3RhdHVzIG9mIHRoZSBhbmltYXRpb246IDAg4oCUIGp1c3Qgc3RhcnRlZCwgMSDigJQganVzdCBmaW5pc2hlZCxcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5BbmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkIGluIGVsLmFuaW1zKSBpZiAoZWwuYW5pbXNbaGFzXShpZCkpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbTogbmV3IEFuaW1hdGlvbihhLl9hdHRycywgYS5kdXIsIGEuZWFzaW5nLCBhLl9jYWxsYmFjayksXG4gICAgICAgICAgICAgICAgICAgIG1pbmE6IGEsXG4gICAgICAgICAgICAgICAgICAgIGN1clN0YXR1czogYS5zdGF0dXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGF0dXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0oZWwuYW5pbXNbaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJ1bnMgZ2VuZXJpYyBhbmltYXRpb24gb2Ygb25lIG51bWJlciBpbnRvIGFub3RoZXIgd2l0aCBhIGNhcmluZyBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcnxhcnJheSkgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnNcbiAgICAgLSB0byAobnVtYmVyfGFycmF5KSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAtIHNldHRlciAoZnVuY3Rpb24pIGNhcmluZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG51bWJlciBhcmd1bWVudFxuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGFuaW1hdGlvbiBlbmRzXG4gICAgID0gKG9iamVjdCkgYW5pbWF0aW9uIG9iamVjdCBpbiBAbWluYSBmb3JtYXRcbiAgICAgbyB7XG4gICAgIG8gICAgIGlkIChzdHJpbmcpIGFuaW1hdGlvbiBpZCwgY29uc2lkZXIgaXQgcmVhZC1vbmx5LFxuICAgICBvICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgZWFzaW5nIChmdW5jdGlvbikgZWFzaW5nLFxuICAgICBvICAgICBzcGVlZCAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgIHwgdmFyIHJlY3QgPSBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApO1xuICAgICB8IFNuYXAuYW5pbWF0ZSgwLCAxMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICB8ICAgICByZWN0LmF0dHIoe1xuICAgICB8ICAgICAgICAgeDogdmFsXG4gICAgIHwgICAgIH0pO1xuICAgICB8IH0sIDEwMDApO1xuICAgICB8IC8vIGluIGdpdmVuIGNvbnRleHQgaXMgZXF1aXZhbGVudCB0b1xuICAgICB8IHJlY3QuYW5pbWF0ZSh7eDogMTB9LCAxMDAwKTtcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzZXR0ZXIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShmcm9tLCB0bywgbm93LCBub3cgKyBtcywgbWluYS50aW1lLCBzZXR0ZXIsIGVhc2luZyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbXMgPSB0aGlzLmluQW5pbSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbmltcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBhbmltc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIGF0dHJzIChvYmplY3QpIGtleS12YWx1ZSBwYWlycyBvZiBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIHRoZSBhbmltYXRpb24gZW5kc1xuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdHRycy5jYWxsYmFjaztcbiAgICAgICAgICAgIGVhc2luZyA9IGF0dHJzLmVhc2luZztcbiAgICAgICAgICAgIG1zID0gYXR0cnMuZHVyO1xuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5hdHRyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBma2V5cyA9IFtdLCB0a2V5cyA9IFtdLCBrZXlzID0ge30sIGZyb20sIHRvLCBmLCBlcSxcbiAgICAgICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSBpZiAoYXR0cnNbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoZWwuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICBlcSA9IGVsLmVxdWFsKGtleSwgU3RyKGF0dHJzW2tleV0pKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gZXEuZnJvbTtcbiAgICAgICAgICAgICAgICB0byA9IGVxLnRvO1xuICAgICAgICAgICAgICAgIGYgPSBlcS5mO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gK2VsLmF0dHIoa2V5KTtcbiAgICAgICAgICAgICAgICB0byA9ICthdHRyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IGlzKGZyb20sIFwiYXJyYXlcIikgPyBmcm9tLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICBrZXlzW2tleV0gPSBzbGljZShma2V5cy5sZW5ndGgsIGZrZXlzLmxlbmd0aCArIGxlbiwgZik7XG4gICAgICAgICAgICBma2V5cyA9IGZrZXlzLmNvbmNhdChmcm9tKTtcbiAgICAgICAgICAgIHRrZXlzID0gdGtleXMuY29uY2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShma2V5cywgdGtleXMsIG5vdywgbm93ICsgbXMsIG1pbmEudGltZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGtleXMpIGlmIChrZXlzW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyW2tleV0gPSBrZXlzW2tleV0odmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYXR0cihhdHRyKTtcbiAgICAgICAgICAgIH0sIGVhc2luZyk7XG4gICAgICAgIGVsLmFuaW1zW2FuaW0uaWRdID0gYW5pbTtcbiAgICAgICAgYW5pbS5fYXR0cnMgPSBhdHRycztcbiAgICAgICAgYW5pbS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgZXZlKFwic25hcC5hbmltY3JlYXRlZC5cIiArIGVsLmlkLCBhbmltKTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLmZpbmlzaC5cIiArIGFuaW0uaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5vZmYoXCJtaW5hLiouXCIgKyBhbmltLmlkKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5hbmltc1thbmltLmlkXTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLnN0b3AuXCIgKyBhbmltLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUub2ZmKFwibWluYS4qLlwiICsgYW5pbS5pZCk7XG4gICAgICAgICAgICBkZWxldGUgZWwuYW5pbXNbYW5pbS5pZF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICAvLyBDb2xvdXJzIGFyZSBmcm9tIGh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY29cbiAgICB2YXIgcmVkICAgICAgICAgPSBcIiNmZmViZWUjZmZjZGQyI2VmOWE5YSNlNTczNzMjZWY1MzUwI2Y0NDMzNiNlNTM5MzUjZDMyZjJmI2M2MjgyOCNiNzFjMWMjZmY4YTgwI2ZmNTI1MiNmZjE3NDQjZDUwMDAwXCIsXG4gICAgICAgIHBpbmsgICAgICAgID0gXCIjRkNFNEVDI0Y4QkJEMCNGNDhGQjEjRjA2MjkyI0VDNDA3QSNFOTFFNjMjRDgxQjYwI0MyMTg1QiNBRDE0NTcjODgwRTRGI0ZGODBBQiNGRjQwODEjRjUwMDU3I0M1MTE2MlwiLFxuICAgICAgICBwdXJwbGUgICAgICA9IFwiI0YzRTVGNSNFMUJFRTcjQ0U5M0Q4I0JBNjhDOCNBQjQ3QkMjOUMyN0IwIzhFMjRBQSM3QjFGQTIjNkExQjlBIzRBMTQ4QyNFQTgwRkMjRTA0MEZCI0Q1MDBGOSNBQTAwRkZcIixcbiAgICAgICAgZGVlcHB1cnBsZSAgPSBcIiNFREU3RjYjRDFDNEU5I0IzOUREQiM5NTc1Q0QjN0U1N0MyIzY3M0FCNyM1RTM1QjEjNTEyREE4IzQ1MjdBMCMzMTFCOTIjQjM4OEZGIzdDNERGRiM2NTFGRkYjNjIwMEVBXCIsXG4gICAgICAgIGluZGlnbyAgICAgID0gXCIjRThFQUY2I0M1Q0FFOSM5RkE4REEjNzk4NkNCIzVDNkJDMCMzRjUxQjUjMzk0OUFCIzMwM0Y5RiMyODM1OTMjMUEyMzdFIzhDOUVGRiM1MzZERkUjM0Q1QUZFIzMwNEZGRVwiLFxuICAgICAgICBibHVlICAgICAgICA9IFwiI0UzRjJGRCNCQkRFRkIjOTBDQUY5IzY0QjVGNiM2NEI1RjYjMjE5NkYzIzFFODhFNSMxOTc2RDIjMTU2NUMwIzBENDdBMSM4MkIxRkYjNDQ4QUZGIzI5NzlGRiMyOTYyRkZcIixcbiAgICAgICAgbGlnaHRibHVlICAgPSBcIiNFMUY1RkUjQjNFNUZDIzgxRDRGQSM0RkMzRjcjMjlCNkY2IzAzQTlGNCMwMzlCRTUjMDI4OEQxIzAyNzdCRCMwMTU3OUIjODBEOEZGIzQwQzRGRiMwMEIwRkYjMDA5MUVBXCIsXG4gICAgICAgIGN5YW4gICAgICAgID0gXCIjRTBGN0ZBI0IyRUJGMiM4MERFRUEjNEREMEUxIzI2QzZEQSMwMEJDRDQjMDBBQ0MxIzAwOTdBNyMwMDgzOEYjMDA2MDY0Izg0RkZGRiMxOEZGRkYjMDBFNUZGIzAwQjhENFwiLFxuICAgICAgICB0ZWFsICAgICAgICA9IFwiI0UwRjJGMSNCMkRGREIjODBDQkM0IzREQjZBQyMyNkE2OUEjMDA5Njg4IzAwODk3QiMwMDc5NkIjMDA2OTVDIzAwNEQ0MCNBN0ZGRUIjNjRGRkRBIzFERTlCNiMwMEJGQTVcIixcbiAgICAgICAgZ3JlZW4gICAgICAgPSBcIiNFOEY1RTkjQzhFNkM5I0E1RDZBNyM4MUM3ODQjNjZCQjZBIzRDQUY1MCM0M0EwNDcjMzg4RTNDIzJFN0QzMiMxQjVFMjAjQjlGNkNBIzY5RjBBRSMwMEU2NzYjMDBDODUzXCIsXG4gICAgICAgIGxpZ2h0Z3JlZW4gID0gXCIjRjFGOEU5I0RDRURDOCNDNUUxQTUjQUVENTgxIzlDQ0M2NSM4QkMzNEEjN0NCMzQyIzY4OUYzOCM1NThCMkYjMzM2OTFFI0NDRkY5MCNCMkZGNTkjNzZGRjAzIzY0REQxN1wiLFxuICAgICAgICBsaW1lICAgICAgICA9IFwiI0Y5RkJFNyNGMEY0QzMjRTZFRTlDI0RDRTc3NSNENEUxNTcjQ0REQzM5I0MwQ0EzMyNBRkI0MkIjOUU5RDI0IzgyNzcxNyNGNEZGODEjRUVGRjQxI0M2RkYwMCNBRUVBMDBcIixcbiAgICAgICAgeWVsbG93ICAgICAgPSBcIiNGRkZERTcjRkZGOUM0I0ZGRjU5RCNGRkYxNzYjRkZFRTU4I0ZGRUIzQiNGREQ4MzUjRkJDMDJEI0Y5QTgyNSNGNTdGMTcjRkZGRjhEI0ZGRkYwMCNGRkVBMDAjRkZENjAwXCIsXG4gICAgICAgIGFtYmVyICAgICAgID0gXCIjRkZGOEUxI0ZGRUNCMyNGRkUwODIjRkZENTRGI0ZGQ0EyOCNGRkMxMDcjRkZCMzAwI0ZGQTAwMCNGRjhGMDAjRkY2RjAwI0ZGRTU3RiNGRkQ3NDAjRkZDNDAwI0ZGQUIwMFwiLFxuICAgICAgICBvcmFuZ2UgICAgICA9IFwiI0ZGRjNFMCNGRkUwQjIjRkZDQzgwI0ZGQjc0RCNGRkE3MjYjRkY5ODAwI0ZCOEMwMCNGNTdDMDAjRUY2QzAwI0U2NTEwMCNGRkQxODAjRkZBQjQwI0ZGOTEwMCNGRjZEMDBcIixcbiAgICAgICAgZGVlcG9yYW5nZSAgPSBcIiNGQkU5RTcjRkZDQ0JDI0ZGQUI5MSNGRjhBNjUjRkY3MDQzI0ZGNTcyMiNGNDUxMUUjRTY0QTE5I0Q4NDMxNSNCRjM2MEMjRkY5RTgwI0ZGNkU0MCNGRjNEMDAjREQyQzAwXCIsXG4gICAgICAgIGJyb3duICAgICAgID0gXCIjRUZFQkU5I0Q3Q0NDOCNCQ0FBQTQjQTE4ODdGIzhENkU2MyM3OTU1NDgjNkQ0QzQxIzVENDAzNyM0RTM0MkUjM0UyNzIzXCIsXG4gICAgICAgIGdyZXkgICAgICAgID0gXCIjRkFGQUZBI0Y1RjVGNSNFRUVFRUUjRTBFMEUwI0JEQkRCRCM5RTlFOUUjNzU3NTc1IzYxNjE2MSM0MjQyNDIjMjEyMTIxXCIsXG4gICAgICAgIGJsdWVncmV5ICAgID0gXCIjRUNFRkYxI0NGRDhEQyNCMEJFQzUjOTBBNEFFIzc4OTA5QyM2MDdEOEIjNTQ2RTdBIzQ1NUE2NCMzNzQ3NEYjMjYzMjM4XCI7XG4gICAgLypcXFxuICAgICAqIFNuYXAubXVpXG4gICAgIFsgcHJvcGVydHkgXVxuICAgICAqKlxuICAgICAqIENvbnRhaW4gTWF0ZXJpYWwgVUkgY29sb3Vycy5cbiAgICAgfCBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApLmF0dHIoe2ZpbGw6IFNuYXAubXVpLmRlZXBwdXJwbGUsIHN0cm9rZTogU25hcC5tdWkuYW1iZXJbNjAwXX0pO1xuICAgICAjIEZvciBjb2xvdXIgcmVmZXJlbmNlOiA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jb1wiPmh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY288L2E+LlxuICAgIFxcKi9cbiAgICBTbmFwLm11aSA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZsYXRcbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogQ29udGFpbiBGbGF0IFVJIGNvbG91cnMuXG4gICAgIHwgU25hcCgpLnJlY3QoMCwgMCwgMTAsIDEwKS5hdHRyKHtmaWxsOiBTbmFwLmZsYXQuY2Fycm90LCBzdHJva2U6IFNuYXAuZmxhdC53ZXRhc3BoYWx0fSk7XG4gICAgICMgRm9yIGNvbG91ciByZWZlcmVuY2U6IDxhIGhyZWY9XCJodHRwczovL3d3dy5tYXRlcmlhbHVpLmNvXCI+aHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jbzwvYT4uXG4gICAgXFwqL1xuICAgIFNuYXAuZmxhdCA9IHt9O1xuICAgIGZ1bmN0aW9uIHNhdmVDb2xvcihjb2xvcnMpIHtcbiAgICAgICAgY29sb3JzID0gY29sb3JzLnNwbGl0KC8oPz0jKS8pO1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgU3RyaW5nKGNvbG9yc1s1XSk7XG4gICAgICAgIGNvbG9yWzUwXSA9IGNvbG9yc1swXTtcbiAgICAgICAgY29sb3JbMTAwXSA9IGNvbG9yc1sxXTtcbiAgICAgICAgY29sb3JbMjAwXSA9IGNvbG9yc1syXTtcbiAgICAgICAgY29sb3JbMzAwXSA9IGNvbG9yc1szXTtcbiAgICAgICAgY29sb3JbNDAwXSA9IGNvbG9yc1s0XTtcbiAgICAgICAgY29sb3JbNTAwXSA9IGNvbG9yc1s1XTtcbiAgICAgICAgY29sb3JbNjAwXSA9IGNvbG9yc1s2XTtcbiAgICAgICAgY29sb3JbNzAwXSA9IGNvbG9yc1s3XTtcbiAgICAgICAgY29sb3JbODAwXSA9IGNvbG9yc1s4XTtcbiAgICAgICAgY29sb3JbOTAwXSA9IGNvbG9yc1s5XTtcbiAgICAgICAgaWYgKGNvbG9yc1sxMF0pIHtcbiAgICAgICAgICAgIGNvbG9yLkExMDAgPSBjb2xvcnNbMTBdO1xuICAgICAgICAgICAgY29sb3IuQTIwMCA9IGNvbG9yc1sxMV07XG4gICAgICAgICAgICBjb2xvci5BNDAwID0gY29sb3JzWzEyXTtcbiAgICAgICAgICAgIGNvbG9yLkE3MDAgPSBjb2xvcnNbMTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgU25hcC5tdWkucmVkID0gc2F2ZUNvbG9yKHJlZCk7XG4gICAgU25hcC5tdWkucGluayA9IHNhdmVDb2xvcihwaW5rKTtcbiAgICBTbmFwLm11aS5wdXJwbGUgPSBzYXZlQ29sb3IocHVycGxlKTtcbiAgICBTbmFwLm11aS5kZWVwcHVycGxlID0gc2F2ZUNvbG9yKGRlZXBwdXJwbGUpO1xuICAgIFNuYXAubXVpLmluZGlnbyA9IHNhdmVDb2xvcihpbmRpZ28pO1xuICAgIFNuYXAubXVpLmJsdWUgPSBzYXZlQ29sb3IoYmx1ZSk7XG4gICAgU25hcC5tdWkubGlnaHRibHVlID0gc2F2ZUNvbG9yKGxpZ2h0Ymx1ZSk7XG4gICAgU25hcC5tdWkuY3lhbiA9IHNhdmVDb2xvcihjeWFuKTtcbiAgICBTbmFwLm11aS50ZWFsID0gc2F2ZUNvbG9yKHRlYWwpO1xuICAgIFNuYXAubXVpLmdyZWVuID0gc2F2ZUNvbG9yKGdyZWVuKTtcbiAgICBTbmFwLm11aS5saWdodGdyZWVuID0gc2F2ZUNvbG9yKGxpZ2h0Z3JlZW4pO1xuICAgIFNuYXAubXVpLmxpbWUgPSBzYXZlQ29sb3IobGltZSk7XG4gICAgU25hcC5tdWkueWVsbG93ID0gc2F2ZUNvbG9yKHllbGxvdyk7XG4gICAgU25hcC5tdWkuYW1iZXIgPSBzYXZlQ29sb3IoYW1iZXIpO1xuICAgIFNuYXAubXVpLm9yYW5nZSA9IHNhdmVDb2xvcihvcmFuZ2UpO1xuICAgIFNuYXAubXVpLmRlZXBvcmFuZ2UgPSBzYXZlQ29sb3IoZGVlcG9yYW5nZSk7XG4gICAgU25hcC5tdWkuYnJvd24gPSBzYXZlQ29sb3IoYnJvd24pO1xuICAgIFNuYXAubXVpLmdyZXkgPSBzYXZlQ29sb3IoZ3JleSk7XG4gICAgU25hcC5tdWkuYmx1ZWdyZXkgPSBzYXZlQ29sb3IoYmx1ZWdyZXkpO1xuICAgIFNuYXAuZmxhdC50dXJxdW9pc2UgPSBcIiMxYWJjOWNcIjtcbiAgICBTbmFwLmZsYXQuZ3JlZW5zZWEgPSBcIiMxNmEwODVcIjtcbiAgICBTbmFwLmZsYXQuc3VuZmxvd2VyID0gXCIjZjFjNDBmXCI7XG4gICAgU25hcC5mbGF0Lm9yYW5nZSA9IFwiI2YzOWMxMlwiO1xuICAgIFNuYXAuZmxhdC5lbWVybGFuZCA9IFwiIzJlY2M3MVwiO1xuICAgIFNuYXAuZmxhdC5uZXBocml0aXMgPSBcIiMyN2FlNjBcIjtcbiAgICBTbmFwLmZsYXQuY2Fycm90ID0gXCIjZTY3ZTIyXCI7XG4gICAgU25hcC5mbGF0LnB1bXBraW4gPSBcIiNkMzU0MDBcIjtcbiAgICBTbmFwLmZsYXQucGV0ZXJyaXZlciA9IFwiIzM0OThkYlwiO1xuICAgIFNuYXAuZmxhdC5iZWxpemVob2xlID0gXCIjMjk4MGI5XCI7XG4gICAgU25hcC5mbGF0LmFsaXphcmluID0gXCIjZTc0YzNjXCI7XG4gICAgU25hcC5mbGF0LnBvbWVncmFuYXRlID0gXCIjYzAzOTJiXCI7XG4gICAgU25hcC5mbGF0LmFtZXRoeXN0ID0gXCIjOWI1OWI2XCI7XG4gICAgU25hcC5mbGF0Lndpc3RlcmlhID0gXCIjOGU0NGFkXCI7XG4gICAgU25hcC5mbGF0LmNsb3VkcyA9IFwiI2VjZjBmMVwiO1xuICAgIFNuYXAuZmxhdC5zaWx2ZXIgPSBcIiNiZGMzYzdcIjtcbiAgICBTbmFwLmZsYXQud2V0YXNwaGFsdCA9IFwiIzM0NDk1ZVwiO1xuICAgIFNuYXAuZmxhdC5taWRuaWdodGJsdWUgPSBcIiMyYzNlNTBcIjtcbiAgICBTbmFwLmZsYXQuY29uY3JldGUgPSBcIiM5NWE1YTZcIjtcbiAgICBTbmFwLmZsYXQuYXNiZXN0b3MgPSBcIiM3ZjhjOGRcIjtcbiAgICAvKlxcXG4gICAgICogU25hcC5pbXBvcnRNVUlDb2xvcnNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEltcG9ydHMgTWF0ZXJpYWwgVUkgY29sb3VycyBpbnRvIGdsb2JhbCBvYmplY3QuXG4gICAgIHwgU25hcC5pbXBvcnRNVUlDb2xvcnMoKTtcbiAgICAgfCBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApLmF0dHIoe2ZpbGw6IGRlZXBwdXJwbGUsIHN0cm9rZTogYW1iZXJbNjAwXX0pO1xuICAgICAjIEZvciBjb2xvdXIgcmVmZXJlbmNlOiA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jb1wiPmh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY288L2E+LlxuICAgIFxcKi9cbiAgICBTbmFwLmltcG9ydE1VSUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgY29sb3IgaW4gU25hcC5tdWkpIHtcbiAgICAgICAgICAgIGlmIChTbmFwLm11aS5oYXNPd25Qcm9wZXJ0eShjb2xvcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dbY29sb3JdID0gU25hcC5tdWlbY29sb3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NhbnZhc3Rvb2xzLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jYW52YXN0b29scy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NhbnZhc3Rvb2xzLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCB7IEZpbHRlclBpcGVsaW5lIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMuRmlsdGVyXCI7XHJcblxyXG5pbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEgfSBmcm9tIFwiLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IFJlZ2lvbk1hbmlwdWxhdGlvbkZ1bmN0aW9uLCBSZWdpb25DaGFuZ2VGdW5jdGlvbiB9IGZyb20gXCIuL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcbmltcG9ydCB7IFJlZ2lvblVwZGF0ZUZ1bmN0aW9uLCBSZWdpb25TZWxlY3Rpb25GdW5jdGlvbiB9IGZyb20gXCIuL0ludGVyZmFjZS9JUmVnaW9uc01hbmFnZXJDYWxsYmFja3NcIjtcclxuaW1wb3J0IHsgU2VsZWN0aW9uTm90aWZ5RnVuY3Rpb24sIFNlbGVjdGlvbkNvbmZpcm1GdW5jdGlvbiB9IGZyb20gXCIuL0ludGVyZmFjZS9JU2VsZWN0b3JDYWxsYmFja3NcIjtcclxuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZSB9IGZyb20gXCIuL0ludGVyZmFjZS9JU2VsZWN0b3JTZXR0aW5nc1wiO1xyXG5cclxuaW1wb3J0IHsgUmVnaW9uQ29tcG9uZW50IH0gZnJvbSBcIi4vUmVnaW9uL0NvbXBvbmVudC9SZWdpb25Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgUmVnaW9uc01hbmFnZXIgfSBmcm9tIFwiLi9SZWdpb24vUmVnaW9uc01hbmFnZXJcIjtcclxuXHJcbmltcG9ydCB7IEFyZWFTZWxlY3RvciB9IGZyb20gXCIuL1NlbGVjdGlvbi9BcmVhU2VsZWN0b3JcIjtcclxuXHJcbmltcG9ydCB7IFRvb2xiYXJJdGVtVHlwZX0gZnJvbSBcIi4vVG9vbGJhci9Ub29sYmFySWNvblwiO1xyXG5pbXBvcnQgeyBUb29sYmFyIH0gZnJvbSBcIi4vVG9vbGJhci9Ub29sYmFyXCI7XHJcbmltcG9ydCB7IElUb29sYmFySWNvbiB9IGZyb20gXCIuL0ludGVyZmFjZS9JVG9vbGJhckljb25cIjtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCB0eXBlIHRvIGRlc2NyaWJlIHRvb2xiYXIgcHJlc2V0c1xyXG4gKi9cclxudHlwZSBUb29sYmFySWNvbkRlc2NyaXB0aW9uID0ge1xyXG4gICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFTEVDVE9SIHwgVG9vbGJhckl0ZW1UeXBlLlNXSVRDSCB8IFRvb2xiYXJJdGVtVHlwZS5UUklHR0VSLFxyXG4gICAgYWN0aW9uOiBzdHJpbmcsXHJcbiAgICBpY29uRmlsZTogc3RyaW5nLFxyXG4gICAgdG9vbHRpcDogc3RyaW5nLFxyXG4gICAga2V5Y29kZTogc3RyaW5nLFxyXG4gICAgYWN0aW9uQ2FsbGJhY2s6IChhY3Rpb246IHN0cmluZywgcm06IFJlZ2lvbnNNYW5hZ2VyLCBzbDogQXJlYVNlbGVjdG9yKSA9PiB2b2lkLFxyXG4gICAgd2lkdGg/OiBudW1iZXIsXHJcbiAgICBoZWlnaHQ/OiBudW1iZXIsXHJcbiAgICBhY3RpdmF0ZTogYm9vbGVhbixcclxufSB8IHtcclxuICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TRVBBUkFUT1IsXHJcbn07XHJcblxyXG4vKipcclxuICogV3JhcHMgaW50ZXJuYWwgQ2FudmFzVG9vbHMgY29tcG9uZW50cyBpbnRvIG9uZSBFZGl0b3IgZXhwZXJpZW5jZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFZGl0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdG9vbGJhciBpY29ucyBwcmVzZXQgd2l0aCBhbGwgYXZhaWxhYmxlIGZlYXR1cmVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEZ1bGxUb29sYmFyU2V0OiBUb29sYmFySWNvbkRlc2NyaXB0aW9uW10gPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBUb29sYmFySXRlbVR5cGUuU0VMRUNUT1IsXHJcbiAgICAgICAgICAgIGFjdGlvbjogXCJub25lLXNlbGVjdFwiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJub25lLXNlbGVjdGlvbi5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJSZWdpb25zIE1hbmlwdWxhdGlvbiAoTSlcIixcclxuICAgICAgICAgICAga2V5Y29kZTogXCJLZXlNXCIsXHJcbiAgICAgICAgICAgIGFjdGlvbkNhbGxiYWNrOiAoYWN0aW9uLCBybSwgc2wpID0+IHtcclxuICAgICAgICAgICAgICAgIHNsLnNldFNlbGVjdGlvbk1vZGUoeyBtb2RlOiBTZWxlY3Rpb25Nb2RlLk5PTkUgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjdGl2YXRlOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFUEFSQVRPUixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFTEVDVE9SLFxyXG4gICAgICAgICAgICBhY3Rpb246IFwicG9pbnQtc2VsZWN0XCIsXHJcbiAgICAgICAgICAgIGljb25GaWxlOiBcInBvaW50LXNlbGVjdGlvbi5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJQb2ludC1zZWxlY3Rpb24gKFApXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiS2V5UFwiLFxyXG4gICAgICAgICAgICBhY3Rpb25DYWxsYmFjazogKGFjdGlvbiwgcm0sIHNsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzbC5zZXRTZWxlY3Rpb25Nb2RlKHsgbW9kZTogU2VsZWN0aW9uTW9kZS5QT0lOVCB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWN0aXZhdGU6IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBUb29sYmFySXRlbVR5cGUuU0VMRUNUT1IsXHJcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZWN0LXNlbGVjdFwiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJyZWN0LXNlbGVjdGlvbi5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJSZWN0YW5ndWxhciBib3ggKFIpXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiS2V5UlwiLFxyXG4gICAgICAgICAgICBhY3Rpb25DYWxsYmFjazogKGFjdGlvbiwgcm0sIHNsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzbC5zZXRTZWxlY3Rpb25Nb2RlKHsgbW9kZTogU2VsZWN0aW9uTW9kZS5SRUNUIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFTEVDVE9SLFxyXG4gICAgICAgICAgICBhY3Rpb246IFwiY29weS1zZWxlY3RcIixcclxuICAgICAgICAgICAgaWNvbkZpbGU6IFwiY29weS10LXNlbGVjdGlvbi5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJUZW1wbGF0ZS1iYXNlZCBib3ggKFQpXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiS2V5VFwiLFxyXG4gICAgICAgICAgICBhY3Rpb25DYWxsYmFjazogKGFjdGlvbiwgcm0sIHNsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25zID0gcm0uZ2V0U2VsZWN0ZWRSZWdpb25zKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaW9ucyAhPT0gdW5kZWZpbmVkICYmIHJlZ2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZWdpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsLnNldFNlbGVjdGlvbk1vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBTZWxlY3Rpb25Nb2RlLkNPUFlSRUNULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogbmV3IFJlY3Qoci5yZWdpb25EYXRhLndpZHRoLCByLnJlZ2lvbkRhdGEuaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2wuc2V0U2VsZWN0aW9uTW9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFNlbGVjdGlvbk1vZGUuQ09QWVJFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBuZXcgUmVjdCg0MCwgNDApLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TRUxFQ1RPUixcclxuICAgICAgICAgICAgYWN0aW9uOiBcInBvbHlsaW5lLXNlbGVjdFwiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJwb2x5bGluZS1zZWxlY3Rpb24uc3ZnXCIsXHJcbiAgICAgICAgICAgIHRvb2x0aXA6IFwiUG9seWxpbmUtc2VsZWN0aW9uIChZKVwiLFxyXG4gICAgICAgICAgICBrZXljb2RlOiBcIktleVlcIixcclxuICAgICAgICAgICAgYWN0aW9uQ2FsbGJhY2s6IChhY3Rpb24sIHJtLCBzbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2wuc2V0U2VsZWN0aW9uTW9kZSh7IG1vZGU6IFNlbGVjdGlvbk1vZGUuUE9MWUxJTkUgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjdGl2YXRlOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFTEVDVE9SLFxyXG4gICAgICAgICAgICBhY3Rpb246IFwicG9seWdvbi1zZWxlY3RcIixcclxuICAgICAgICAgICAgaWNvbkZpbGU6IFwicG9seWdvbi1zZWxlY3Rpb24uc3ZnXCIsXHJcbiAgICAgICAgICAgIHRvb2x0aXA6IFwiUG9seWdvbi1zZWxlY3Rpb24gKE8pXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiS2V5T1wiLFxyXG4gICAgICAgICAgICBhY3Rpb25DYWxsYmFjazogKGFjdGlvbiwgcm0sIHNsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzbC5zZXRTZWxlY3Rpb25Nb2RlKHsgbW9kZTogU2VsZWN0aW9uTW9kZS5QT0xZR09OIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TRVBBUkFUT1IsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5UUklHR0VSLFxyXG4gICAgICAgICAgICBhY3Rpb246IFwiZGVsZXRlLWFsbC1zZWxlY3RcIixcclxuICAgICAgICAgICAgaWNvbkZpbGU6IFwiZGVsZXRlLWFsbC1zZWxlY3Rpb24uc3ZnXCIsXHJcbiAgICAgICAgICAgIHRvb2x0aXA6IFwiRGVsZXRlIGFsbCByZWdpb25zXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiXCIsXHJcbiAgICAgICAgICAgIGFjdGlvbkNhbGxiYWNrOiAoYWN0aW9uLCBybSwgc2wpID0+IHtcclxuICAgICAgICAgICAgICAgIHJtLmRlbGV0ZUFsbFJlZ2lvbnMoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWN0aXZhdGU6IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBUb29sYmFySXRlbVR5cGUuU0VQQVJBVE9SLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBUb29sYmFySXRlbVR5cGUuU1dJVENILFxyXG4gICAgICAgICAgICBhY3Rpb246IFwic2VsZWN0aW9uLWxvY2tcIixcclxuICAgICAgICAgICAgaWNvbkZpbGU6IFwic2VsZWN0aW9uLWxvY2suc3ZnXCIsXHJcbiAgICAgICAgICAgIHRvb2x0aXA6IFwiTG9jay91bmxvY2sgcmVnaW9ucyAoTClcIixcclxuICAgICAgICAgICAga2V5Y29kZTogXCJLZXlMXCIsXHJcbiAgICAgICAgICAgIGFjdGlvbkNhbGxiYWNrOiAoYWN0aW9uLCBybSwgc2wpID0+IHtcclxuICAgICAgICAgICAgICAgIHJtLnRvZ2dsZUZyZWV6ZU1vZGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWN0aXZhdGU6IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBUb29sYmFySXRlbVR5cGUuU1dJVENILFxyXG4gICAgICAgICAgICBhY3Rpb246IFwiYmFja2dyb3VuZC10b2dnbGVcIixcclxuICAgICAgICAgICAgaWNvbkZpbGU6IFwiYmFja2dyb3VuZC10b2dnbGUuc3ZnXCIsXHJcbiAgICAgICAgICAgIHRvb2x0aXA6IFwiVG9nZ2xlIFJlZ2lvbiBCYWNrZ3JvdW5kIChCKVwiLFxyXG4gICAgICAgICAgICBrZXljb2RlOiBcIktleUJcIixcclxuICAgICAgICAgICAgYWN0aW9uQ2FsbGJhY2s6IChhY3Rpb24sIHJtLCBzbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcm0udG9nZ2xlQmFja2dyb3VuZCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdG9vbGJhciBpY29ucyBwcmVzZXQgd2l0aCBvbmx5IHJlY3QtcmVsYXRlZCBmZWF0dXJlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBSZWN0VG9vbGJhclNldDogVG9vbGJhckljb25EZXNjcmlwdGlvbltdID0gW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFTEVDVE9SLFxyXG4gICAgICAgICAgICBhY3Rpb246IFwibm9uZS1zZWxlY3RcIixcclxuICAgICAgICAgICAgaWNvbkZpbGU6IFwibm9uZS1zZWxlY3Rpb24uc3ZnXCIsXHJcbiAgICAgICAgICAgIHRvb2x0aXA6IFwiUmVnaW9ucyBNYW5pcHVsYXRpb24gKE0pXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiS2V5TVwiLFxyXG4gICAgICAgICAgICBhY3Rpb25DYWxsYmFjazogKGFjdGlvbiwgcm0sIHNsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzbC5zZXRTZWxlY3Rpb25Nb2RlKHsgbW9kZTogU2VsZWN0aW9uTW9kZS5OT05FIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TRVBBUkFUT1IsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TRUxFQ1RPUixcclxuICAgICAgICAgICAgYWN0aW9uOiBcInJlY3Qtc2VsZWN0XCIsXHJcbiAgICAgICAgICAgIGljb25GaWxlOiBcInJlY3Qtc2VsZWN0aW9uLnN2Z1wiLFxyXG4gICAgICAgICAgICB0b29sdGlwOiBcIlJlY3Rhbmd1bGFyIGJveCAoUilcIixcclxuICAgICAgICAgICAga2V5Y29kZTogXCJLZXlSXCIsXHJcbiAgICAgICAgICAgIGFjdGlvbkNhbGxiYWNrOiAoYWN0aW9uLCBybSwgc2wpID0+IHtcclxuICAgICAgICAgICAgICAgIHNsLnNldFNlbGVjdGlvbk1vZGUoeyBtb2RlOiBTZWxlY3Rpb25Nb2RlLlJFQ1QgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjdGl2YXRlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBUb29sYmFySXRlbVR5cGUuU0VMRUNUT1IsXHJcbiAgICAgICAgICAgIGFjdGlvbjogXCJjb3B5LXNlbGVjdFwiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJjb3B5LXQtc2VsZWN0aW9uLnN2Z1wiLFxyXG4gICAgICAgICAgICB0b29sdGlwOiBcIlRlbXBsYXRlLWJhc2VkIGJveCAoVClcIixcclxuICAgICAgICAgICAga2V5Y29kZTogXCJLZXlUXCIsXHJcbiAgICAgICAgICAgIGFjdGlvbkNhbGxiYWNrOiAoYWN0aW9uLCBybSwgc2wpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBybS5nZXRTZWxlY3RlZFJlZ2lvbnMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpb25zICE9PSB1bmRlZmluZWQgJiYgcmVnaW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHJlZ2lvbnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2wuc2V0U2VsZWN0aW9uTW9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFNlbGVjdGlvbk1vZGUuQ09QWVJFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBuZXcgUmVjdChyLnJlZ2lvbkRhdGEud2lkdGgsIHIucmVnaW9uRGF0YS5oZWlnaHQpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzbC5zZXRTZWxlY3Rpb25Nb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogU2VsZWN0aW9uTW9kZS5DT1BZUkVDVCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IG5ldyBSZWN0KDQwLCA0MCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjdGl2YXRlOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlNFUEFSQVRPUixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogVG9vbGJhckl0ZW1UeXBlLlRSSUdHRVIsXHJcbiAgICAgICAgICAgIGFjdGlvbjogXCJkZWxldGUtYWxsLXNlbGVjdFwiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJkZWxldGUtYWxsLXNlbGVjdGlvbi5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJEZWxldGUgYWxsIHJlZ2lvbnNcIixcclxuICAgICAgICAgICAga2V5Y29kZTogXCJcIixcclxuICAgICAgICAgICAgYWN0aW9uQ2FsbGJhY2s6IChhY3Rpb24sIHJtLCBzbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcm0uZGVsZXRlQWxsUmVnaW9ucygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TRVBBUkFUT1IsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TV0lUQ0gsXHJcbiAgICAgICAgICAgIGFjdGlvbjogXCJzZWxlY3Rpb24tbG9ja1wiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJzZWxlY3Rpb24tbG9jay5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJMb2NrL3VubG9jayByZWdpb25zIChMKVwiLFxyXG4gICAgICAgICAgICBrZXljb2RlOiBcIktleUxcIixcclxuICAgICAgICAgICAgYWN0aW9uQ2FsbGJhY2s6IChhY3Rpb24sIHJtLCBzbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcm0udG9nZ2xlRnJlZXplTW9kZSgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmF0ZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRvb2xiYXJJdGVtVHlwZS5TV0lUQ0gsXHJcbiAgICAgICAgICAgIGFjdGlvbjogXCJiYWNrZ3JvdW5kLXRvZ2dsZVwiLFxyXG4gICAgICAgICAgICBpY29uRmlsZTogXCJiYWNrZ3JvdW5kLXRvZ2dsZS5zdmdcIixcclxuICAgICAgICAgICAgdG9vbHRpcDogXCJUb2dnbGUgUmVnaW9uIEJhY2tncm91bmQgKEIpXCIsXHJcbiAgICAgICAgICAgIGtleWNvZGU6IFwiS2V5QlwiLFxyXG4gICAgICAgICAgICBhY3Rpb25DYWxsYmFjazogKGFjdGlvbiwgcm0sIHNsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBybS50b2dnbGVCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjdGl2YXRlOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIFNWRyB0ZW1wbGF0ZSB0byBkZWZpbmUgc2hhZG93IGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU1ZHRGVmc1RlbXBsYXRlID0gYFxyXG4gICAgICAgIDxkZWZzPlxyXG4gICAgICAgICAgICA8ZmlsdGVyIGlkPVwiYmxhY2stZ2xvd1wiPlxyXG4gICAgICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyIGluPVwiU291cmNlQWxwaGFcIiBzdGREZXZpYXRpb249XCIyXCIgLz5cclxuICAgICAgICAgICAgICAgIDxmZU9mZnNldCBkeD1cIjBcIiBkeT1cIjBcIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIgLz5cclxuICAgICAgICAgICAgICAgIDxmZUNvbXBvbmVudFRyYW5zZmVyPlxyXG4gICAgICAgICAgICAgICAgICAgIDxmZUZ1bmNBIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIjAuOFwiIC8+XHJcbiAgICAgICAgICAgICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+XHJcbiAgICAgICAgICAgICAgICA8ZmVNZXJnZT5cclxuICAgICAgICAgICAgICAgICAgICA8ZmVNZXJnZU5vZGUgLz5cclxuICAgICAgICAgICAgICAgICAgICA8ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIgLz5cclxuICAgICAgICAgICAgICAgIDwvZmVNZXJnZT5cclxuICAgICAgICAgICAgPC9maWx0ZXI+XHJcbiAgICAgICAgPC9kZWZzPmA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdXRvLXJlc2l6ZSBmbGFnIHRvIGF1dG9tYXRpY2FsbHkgdXBkYXRlIGVkaXRvciBpbnRlcm5hbHMgd2hlbiB0aGUgY29udGFpbmVyICh3aW5kb3cpIHNpemUgaXMgY2hhbmdlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1dG9SZXNpemU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBwcm94aSB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBBUEkgZm9yIHRoZSBgRWRpdG9yYCBpdHNlbGYsIGBSZWdpb25zTWFuYWdlcmAgKGBSTWApLCBgQXJlYVNlbGVjdG9yYCAoYEFTYCkgYW5kXHJcbiAgICAgKiBgRmlsdGVyUGlwZWxpbmVgIChgRlBgKS5cclxuICAgICAqIEByZW1hcmtzIEFzIG9mIG5vdyB0aG9zZSBhcGlzIGRvIG5vdCBvdmVybGFwLCBzbyBhbGwgbWV0aG9kcy9wcm9wZXJ0aWVzIG1pZ2h0IGJlIG1hcHBlZCBmcm9tIHVuaWZpZWQgQVBJLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGFwaSgpOiBFZGl0b3IgJiBSZWdpb25zTWFuYWdlciAmIEFyZWFTZWxlY3RvciAmIEZpbHRlclBpcGVsaW5lIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZWRBUEk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgYFJlZ2lvbnNNYW5hZ2VyYCBjYWxsZWQgd2hlbiBzb21lIHJlZ2lvbiBpcyBzZWxlY3RlZCBvciB1bnNlbGVjdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25SZWdpb25TZWxlY3RlZDogUmVnaW9uU2VsZWN0aW9uRnVuY3Rpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgYFJlZ2lvbnNNYW5hZ2VyYCBjYWxsZWQgd2hlbiBzb21lIHJlZ2lvbiBpcyBtb3ZpbmcuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvblJlZ2lvbk1vdmU6IFJlZ2lvblVwZGF0ZUZ1bmN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIGBSZWdpb25zTWFuYWdlcmAgY2FsbGVkIHdoZW4gc29tZSByZWdpb24gYmVnYW4gbW92aW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25SZWdpb25Nb3ZlQmVnaW46IFJlZ2lvblVwZGF0ZUZ1bmN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIGBSZWdpb25zTWFuYWdlcmAgY2FsbGVkIHdoZW4gc29tZSByZWdpb24gZW5kZWQgbW92aW5nLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25SZWdpb25Nb3ZlRW5kOiBSZWdpb25VcGRhdGVGdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGZvciBgUmVnaW9uc01hbmFnZXJgIGNhbGxlZCB3aGVuIHNvbWUgcmVnaW9uIGlzIGRlbGV0ZWQgZnJvbSBVSS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uUmVnaW9uRGVsZXRlOiBSZWdpb25VcGRhdGVGdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGZvciBgUmVnaW9uc01hbmFnZXJgIGNhbGxlZCB3aGVuIHBvaW50ZXIgZW50ZXJlZCBtYW5pcHVsYXRpb24gYXJlYS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uTWFuaXB1bGF0aW9uQmVnaW46IFJlZ2lvbk1hbmlwdWxhdGlvbkZ1bmN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIGBSZWdpb25zTWFuYWdlcmAgY2FsbGVkIHdoZW4gcG9pbnRlciBsZWF2ZWQgbWFuaXB1bGF0aW9uIGFyZWEuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbk1hbmlwdWxhdGlvbkVuZDogUmVnaW9uTWFuaXB1bGF0aW9uRnVuY3Rpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgYEFyZWFTZWxlY3RvcmAgY2FsbGVkIHdoZW4gdXNlciBiZWdhbiBzZWxlY3RpbmcgKGNyZWF0aW5nKSBuZXcgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25TZWxlY3Rpb25CZWdpbjogU2VsZWN0aW9uTm90aWZ5RnVuY3Rpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgYEFyZWFTZWxlY3RvcmAgY2FsbGVkIHdoZW4gdXNlciBlbmRlZCBzZWxlY3RpbmcgKGNyZWF0aW5nKSBuZXcgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25TZWxlY3Rpb25FbmQ6IFNlbGVjdGlvbkNvbmZpcm1GdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgcHJveGkgb2YgQVBJcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtZXJnZWRBUEk6IEVkaXRvciAmIFJlZ2lvbnNNYW5hZ2VyICYgQXJlYVNlbGVjdG9yICYgRmlsdGVyUGlwZWxpbmU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGBUb29sYmFyYCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG9vbGJhcjogVG9vbGJhcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgYFJlZ2lvbnNNYW5hZ2VyYCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnaW9uc01hbmFnZXI6IFJlZ2lvbnNNYW5hZ2VyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBgQXJlc1NlbGVjdG9yYCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXJlYVNlbGVjdG9yOiBBcmVhU2VsZWN0b3I7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIGBGaWx0ZXJQaXBlbGluZWAgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbHRlclBpcGVsaW5lOiBGaWx0ZXJQaXBlbGluZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgaG9zdCBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBlZGl0b3JTVkc6IFNWR1NWR0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGhvc3QgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29udGVudENhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGhvc3QgZGl2IGVsZW1lbnQgKGNvbnRhaW5zIFNWRyBhbmQgQ2FudmFzIGVsZW1lbnRzKS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBlZGl0b3JEaXY6IEhUTUxEaXZFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBSZWdpb25zTWFuYWdlciBmcmVlemluZyBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc1JNRnJvemVuOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNvdXJjZVdpZHRoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgY29udGVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzb3VyY2VIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGZyYW1lIHdpZHRoLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZyYW1lV2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGZyYW1lIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmcmFtZUhlaWdodDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRWRpdG9yYCBpbiBzcGVjaWZpZWQgZGl2LWNvbnRhaW5lci5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgZGl2LWNvbnRhaW5lciBmb3IgdGhlIGVkaXRvci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBFZGl0b3JgIGluIHNwZWNpZmllZCBkaXYtY29udGFpbmVyIGFuZCB3aXRoIGN1c3RvbSBidWlsZGluZyBjb21wb25lbnRzLlxyXG4gICAgICogQHJlbWFya3MgLSBPcmlnaW5hbGx5IGNyZWF0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIGRpdi1jb250YWluZXIgZm9yIHRoZSBlZGl0b3IuXHJcbiAgICAgKiBAcGFyYW0gYXJlYVNlbGVjdG9yIC0gVGhlIGBBcmVzU2VsZWN0b3JgIGNvbXBvbmVudCB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uc01hbmFnZXIgLSBUaGUgYFJlZ2lvbnNNYW5hZ2VyYCBjb21wb25lbnQgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBhcmVhU2VsZWN0b3I6IEFyZWFTZWxlY3RvciwgcmVnaW9uc01hbmFnZXI6IFJlZ2lvbnNNYW5hZ2VyKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYEVkaXRvcmAgaW4gc3BlY2lmaWVkIGRpdi1jb250YWluZXIgYW5kIHdpdGggY3VzdG9tIGJ1aWxkaW5nIGNvbXBvbmVudHMuXHJcbiAgICAgKiBAcmVtYXJrcyAtIE9yaWdpbmFsbHkgY3JlYXRlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgZGl2LWNvbnRhaW5lciBmb3IgdGhlIGVkaXRvci5cclxuICAgICAqIEBwYXJhbSBhcmVhU2VsZWN0b3IgLSBUaGUgYEFyZXNTZWxlY3RvcmAgY29tcG9uZW50IHRvIHVzZS5cclxuICAgICAqIEBwYXJhbSByZWdpb25zTWFuYWdlciAtIFRoZSBgUmVnaW9uc01hbmFnZXJgIGNvbXBvbmVudCB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyUGlwZWxpbmUgLSBUaGUgYEZpbHRlclBpcGVsaW5lYCBjb21wb25lbnQgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBhcmVhU2VsZWN0b3I6IEFyZWFTZWxlY3RvciwgcmVnaW9uc01hbmFnZXI6IFJlZ2lvbnNNYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyUGlwZWxpbmU6IEZpbHRlclBpcGVsaW5lKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBhcmVhU2VsZWN0b3I/OiBBcmVhU2VsZWN0b3IsIHJlZ2lvbnNNYW5hZ2VyPzogUmVnaW9uc01hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJQaXBlbGluZT86IEZpbHRlclBpcGVsaW5lKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIFNWRyBFbGVtZW50XHJcbiAgICAgICAgdGhpcy5jb250ZW50Q2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXNFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JTVkcgPSB0aGlzLmNyZWF0ZVNWR0VsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5lZGl0b3JEaXYgPSBjb250YWluZXI7XHJcblxyXG4gICAgICAgIHRoaXMuZWRpdG9yRGl2LmNsYXNzTGlzdC5hZGQoXCJDYW52YXNUb29sc0VkaXRvclwiKTtcclxuICAgICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQodGhpcy5jb250ZW50Q2FudmFzKTtcclxuICAgICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQodGhpcy5lZGl0b3JTVkcpO1xyXG5cclxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBpbnRlcm5hbHMgb24gd2luZG93IHJlc2l6ZVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKHRoaXMuZWRpdG9yRGl2Lm9mZnNldFdpZHRoLCB0aGlzLmVkaXRvckRpdi5vZmZzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEluaXQgcmVnaW9uc01hbmFnZXJcclxuICAgICAgICBjb25zdCBybUNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25DaGFuZ2U6IG51bGwsXHJcbiAgICAgICAgICAgIG9uTWFuaXB1bGF0aW9uQmVnaW46IChyZWdpb24/OiBSZWdpb25Db21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJlYVNlbGVjdG9yLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbk1hbmlwdWxhdGlvbkJlZ2luID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4ocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25NYW5pcHVsYXRpb25FbmQ6IChyZWdpb24/OiBSZWdpb25Db21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJlYVNlbGVjdG9yLnNob3coKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbk1hbmlwdWxhdGlvbkVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1hbmlwdWxhdGlvbkVuZChyZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlZ2lvblNlbGVjdGVkOiAoaWQ6IHN0cmluZywgbXVsdGlzZWxlY3Rpb246IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlZ2lvblNlbGVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVnaW9uU2VsZWN0ZWQoaWQsIG11bHRpc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWdpb25Nb3ZlOiAoaWQ6IHN0cmluZywgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVnaW9uTW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlZ2lvbk1vdmUoaWQsIHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlZ2lvbk1vdmVCZWdpbjogKGlkOiBzdHJpbmcsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlZ2lvbk1vdmVCZWdpbiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlZ2lvbk1vdmVCZWdpbihpZCwgcmVnaW9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uUmVnaW9uTW92ZUVuZDogKGlkOiBzdHJpbmcsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlZ2lvbk1vdmVFbmQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZWdpb25Nb3ZlRW5kKGlkLCByZWdpb25EYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWdpb25EZWxldGU6IChpZDogc3RyaW5nLCByZWdpb25EYXRhOiBSZWdpb25EYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25SZWdpb25EZWxldGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZWdpb25EZWxldGUoaWQsIHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChyZWdpb25zTWFuYWdlciAhPT0gbnVsbCAmJiByZWdpb25zTWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uc01hbmFnZXIgPSByZWdpb25zTWFuYWdlcjtcclxuICAgICAgICAgICAgcmVnaW9uc01hbmFnZXIuY2FsbGJhY2tzID0gcm1DYWxsYmFja3M7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb25zTWFuYWdlciA9IG5ldyBSZWdpb25zTWFuYWdlcih0aGlzLmVkaXRvclNWRywgcm1DYWxsYmFja3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdCBhcmVhU2VsZXRvclxyXG4gICAgICAgIGNvbnN0IGFzQ2FsbGJhY2tzID0ge1xyXG4gICAgICAgICAgICBvblNlbGVjdGlvbkJlZ2luOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUk1Gcm96ZW4gPSB0aGlzLnJlZ2lvbnNNYW5hZ2VyLmlzRnJvemVuO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpb25zTWFuYWdlci5mcmVlemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25TZWxlY3Rpb25CZWdpbiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNlbGVjdGlvbkJlZ2luKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uRW5kOiAocmVnaW9uRGF0YTogUmVnaW9uRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUk1Gcm96ZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvbnNNYW5hZ2VyLnVuZnJlZXplKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uU2VsZWN0aW9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2VsZWN0aW9uRW5kKHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFyZWFTZWxlY3RvciAhPT0gbnVsbCAmJiBhcmVhU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFyZWFTZWxlY3RvciA9IGFyZWFTZWxlY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5hcmVhU2VsZWN0b3IuY2FsbGJhY2tzID0gYXNDYWxsYmFja3M7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hcmVhU2VsZWN0b3IgPSBuZXcgQXJlYVNlbGVjdG9yKHRoaXMuZWRpdG9yU1ZHLCBhc0NhbGxiYWNrcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0IGZpbHRlclBpcGVsaW5lXHJcbiAgICAgICAgaWYgKGZpbHRlclBpcGVsaW5lICE9PSB1bmRlZmluZWQgJiYgZmlsdGVyUGlwZWxpbmUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJQaXBlbGluZSA9IGZpbHRlclBpcGVsaW5lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyUGlwZWxpbmUgPSBuZXcgRmlsdGVyUGlwZWxpbmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkanVzdCBlZGl0b3Igc2l6ZVxyXG4gICAgICAgIHRoaXMucmVzaXplKGNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29udGFpbmVyLm9mZnNldEhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBwcm94eSB0byByZWdpb25zTWFuYWdlciwgYXJlYVNlbGVjdG9yIGFuZCBmaWx0ZXJQaXBlbGluZTtcclxuICAgICAgICB0aGlzLm1lcmdlZEFQSSA9IG5ldyBQcm94eSh0aGlzLCB7XHJcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHA6IGFueTtcclxuICAgICAgICAgICAgICAgIGxldCB0OiBhbnk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBwID0gdFtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCBpbiB0YXJnZXQucmVnaW9uc01hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gdGFyZ2V0LlJNO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSB0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wIGluIHRhcmdldC5hcmVhU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gdGFyZ2V0LkFTO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSB0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wIGluIHRhcmdldC5maWx0ZXJQaXBlbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0YXJnZXQuRlA7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcC5hcHBseSh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSBhcyBhbnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRvb2xiYXIgaW4gc3BlY2lmaWVkIGRpdi1jb250YWluZXJcclxuICAgICAqIEBwYXJhbSBjb250YWluZXIgLSBUaGUgZGl2LWNvbnRhaW5lciBmb3IgdGhlIHRvb2xiYXIuXHJcbiAgICAgKiBAcGFyYW0gdG9vbGJhclNldCAtIEljb25zIHNldCBmb3IgdGhlIHRvb2xiYXIuXHJcbiAgICAgKiBAcGFyYW0gaWNvbnNQYXRoIC0gUGF0aCB0byB0aGUgdG9vbGJhciBpY29ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFRvb2xiYXIoY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgdG9vbGJhclNldDogVG9vbGJhckljb25EZXNjcmlwdGlvbltdLCBpY29uc1BhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuY3JlYXRlU1ZHRWxlbWVudCgpO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcclxuXHJcbiAgICAgICAgdGhpcy50b29sYmFyID0gbmV3IFRvb2xiYXIoc3ZnKTtcclxuXHJcbiAgICAgICAgaWYgKHRvb2xiYXJTZXQgPT09IG51bGwgfHwgdG9vbGJhclNldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRvb2xiYXJTZXQgPSBFZGl0b3IuRnVsbFRvb2xiYXJTZXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYWN0aXZlU2VsZWN0b3I6IHN0cmluZztcclxuICAgICAgICB0b29sYmFyU2V0LmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gVG9vbGJhckl0ZW1UeXBlLlNFUEFSQVRPUikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmFkZFNlcGFyYXRvcigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbGJhckl0ZW06IElUb29sYmFySWNvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGl0ZW0uYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGljb25Vcmw6IGljb25zUGF0aCArIGl0ZW0uaWNvbkZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogaXRlbS50b29sdGlwLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleWNvZGU6IGl0ZW0ua2V5Y29kZSxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXRlbS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW0uaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25GbiA9IChhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmFjdGlvbkNhbGxiYWNrKGFjdGlvbiwgdGhpcy5yZWdpb25zTWFuYWdlciwgdGhpcy5hcmVhU2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBUb29sYmFySXRlbVR5cGUuU0VMRUNUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIuYWRkU2VsZWN0b3IodG9vbGJhckl0ZW0sIGFjdGlvbkZuKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5hY3RpdmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTZWxlY3RvciA9IGl0ZW0uYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBUb29sYmFySXRlbVR5cGUuU1dJVENIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sYmFyLmFkZFN3aXRjaCh0b29sYmFySXRlbSwgYWN0aW9uRm4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIuc2V0U3dpdGNoKGl0ZW0uYWN0aW9uLCBpdGVtLmFjdGl2YXRlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBUb29sYmFySXRlbVR5cGUuVFJJR0dFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhci5hZGRUcmlnZ2VyKHRvb2xiYXJJdGVtLCBhY3Rpb25Gbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy50b29sYmFyLnNlbGVjdChhY3RpdmVTZWxlY3Rvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjb250ZW50IHNvdXJjZSBmb3IgdGhlIGVkaXRvci5cclxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBDb250ZW50IHNvdXJjZS5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBQcm9taXNlYCByZXNvbHZlZCB3aGVuIGNvbnRlbnQgaXMgZHJhd24gYW5kIEVkaXRvciBpcyByZXNpemVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgYWRkQ29udGVudFNvdXJjZShzb3VyY2U6IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBidWZmQ252cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGJ1ZmZDbnZzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VXaWR0aCA9IHNvdXJjZS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VIZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVdpZHRoID0gc291cmNlLnZpZGVvV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlSGVpZ2h0ID0gc291cmNlLnZpZGVvSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnVmZkNudnMud2lkdGggPSB0aGlzLnNvdXJjZVdpZHRoO1xyXG4gICAgICAgIGJ1ZmZDbnZzLmhlaWdodCA9IHRoaXMuc291cmNlSGVpZ2h0O1xyXG5cclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzb3VyY2UsIDAsIDAsIGJ1ZmZDbnZzLndpZHRoLCBidWZmQ252cy5oZWlnaHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJQaXBlbGluZS5hcHBseVRvQ2FudmFzKGJ1ZmZDbnZzKS50aGVuKChiY252cykgPT4ge1xyXG4gICAgICAgICAgICAvLyBDb3B5IGJ1ZmZlciB0byB0aGUgY2FudmFzIG9uIHNjcmVlblxyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRDYW52YXMud2lkdGggPSBiY252cy53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50Q2FudmFzLmhlaWdodCA9IGJjbnZzLmhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgaW1nQ29udGV4dCA9IHRoaXMuY29udGVudENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgIGltZ0NvbnRleHQuZHJhd0ltYWdlKGJjbnZzLCAwLCAwLCBiY252cy53aWR0aCwgYmNudnMuaGVpZ2h0KTtcclxuICAgICAgICB9KS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gcmVzaXplIHRoZSBlZGl0b3Igc2l6ZSB0byBhZGp1c3QgdG8gdGhlIG5ldyBjb250ZW50IHNpemVcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5lZGl0b3JEaXYub2Zmc2V0V2lkdGgsIHRoaXMuZWRpdG9yRGl2Lm9mZnNldEhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgZWRpdG9yIHRvIG5ldyB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gICAgICogQHJlbWFya3MgLSBVc2UgaWYgdGhlIGBhdXRvUmVzaXplYCBpcyBgZmFsc2VgLlxyXG4gICAgICogQHBhcmFtIGNvbnRhaW5lcldpZHRoIC0gVGhlIG5ldyBjb250YWluZXIgd2lkdGguXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVySGVpZ2h0IC0gVGhlIG5ldyBjb250YWluZXIgaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKGNvbnRhaW5lcldpZHRoOiBudW1iZXIsIGNvbnRhaW5lckhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5mcmFtZVdpZHRoID0gY29udGFpbmVyV2lkdGg7XHJcbiAgICAgICAgdGhpcy5mcmFtZUhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcclxuXHJcbiAgICAgICAgY29uc3QgaW1nUmF0aW8gPSB0aGlzLmNvbnRlbnRDYW52YXMud2lkdGggLyB0aGlzLmNvbnRlbnRDYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJhdGlvID0gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgIGxldCBocGFkZGluZyA9IDA7XHJcbiAgICAgICAgbGV0IHZwYWRkaW5nID0gMDtcclxuXHJcbiAgICAgICAgaWYgKGltZ1JhdGlvID4gY29udGFpbmVyUmF0aW8pIHtcclxuICAgICAgICAgICAgdnBhZGRpbmcgPSAoY29udGFpbmVySGVpZ2h0IC0gY29udGFpbmVyV2lkdGggLyBpbWdSYXRpbykgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5oZWlnaHQgPSBgY2FsYygxMDAlIC0gJHt2cGFkZGluZyAqIDJ9cHgpYDtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUud2lkdGggPSBcIlwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhwYWRkaW5nID0gKGNvbnRhaW5lcldpZHRoIC0gY29udGFpbmVySGVpZ2h0ICogaW1nUmF0aW8pIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUud2lkdGggPSBgY2FsYygxMDAlIC0gJHtocGFkZGluZyAqIDJ9cHgpYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLnBhZGRpbmcgPSBgJHt2cGFkZGluZ31weCAke2hwYWRkaW5nfXB4YDtcclxuXHJcbiAgICAgICAgdGhpcy5mcmFtZVdpZHRoID0gdGhpcy5lZGl0b3JTVkcuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdGhpcy5mcmFtZUhlaWdodCA9IHRoaXMuZWRpdG9yU1ZHLmNsaWVudEhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhU2VsZWN0b3IucmVzaXplKHRoaXMuZnJhbWVXaWR0aCwgdGhpcy5mcmFtZUhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5yZWdpb25zTWFuYWdlci5yZXNpemUodGhpcy5mcmFtZVdpZHRoLCB0aGlzLmZyYW1lSGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0IHJlZmVyZW5jZSB0byB0aGUgYFJlZ2lvbnNNYW5hZ2VyYCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgUk0oKTogUmVnaW9uc01hbmFnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbnNNYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnQgcmVmZXJlbmNlIHRvIHRoZSBgQXJlYVNlbGVjdG9yYCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgQVMoKTogQXJlYVNlbGVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcmVhU2VsZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG9ydCByZWZlcmVuY2UgdG8gdGhlIGBGaWx0ZXJQaXBlbGluZWAgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEZQKCk6IEZpbHRlclBpcGVsaW5lIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJQaXBlbGluZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlcyB0aGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBmcm9tIGZyYW1lIHRvIHNvdXJjZSBzaXplLlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VXaWR0aCAtIFtPcHRpb25hbF0gVGhlIHNvdXJjZSB3aWR0aC5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VIZWlnaHQgLSBbT3B0aW9uYWxdIFRoZSBzb3VyY2UgaGVpZ2h0LlxyXG4gICAgICogQHJldHVybnMgUmVzaXplZCBgUmVnaW9uRGF0YWAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGVSZWdpb25Ub1NvdXJjZVNpemUocmVnaW9uRGF0YTogUmVnaW9uRGF0YSwgc291cmNlV2lkdGg/OiBudW1iZXIsIHNvdXJjZUhlaWdodD86IG51bWJlcik6IFJlZ2lvbkRhdGEge1xyXG4gICAgICAgIGNvbnN0IHN3ID0gKHNvdXJjZVdpZHRoICE9PSB1bmRlZmluZWQpID8gc291cmNlV2lkdGggOiB0aGlzLnNvdXJjZVdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHNoID0gKHNvdXJjZUhlaWdodCAhPT0gdW5kZWZpbmVkKSA/IHNvdXJjZUhlaWdodCA6IHRoaXMuc291cmNlSGVpZ2h0O1xyXG5cclxuICAgICAgICBjb25zdCB4ZiA9IHN3IC8gdGhpcy5mcmFtZVdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHlmID0gc2ggLyB0aGlzLmZyYW1lSGVpZ2h0O1xyXG5cclxuICAgICAgICBjb25zdCByZCA9IHJlZ2lvbkRhdGEuY29weSgpO1xyXG4gICAgICAgIHJkLnNjYWxlKHhmLCB5Zik7XHJcbiAgICAgICAgcmV0dXJuIHJkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IGZyb20gc291cmNlIHRvIGZyYW1lIHNpemUuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHNvdXJjZVdpZHRoIC0gW09wdGlvbmFsXSBUaGUgc291cmNlIHdpZHRoLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZUhlaWdodCAtIFtPcHRpb25hbF0gVGhlIHNvdXJjZSBoZWlnaHQuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNpemVkIGBSZWdpb25EYXRhYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2FsZVJlZ2lvblRvRnJhbWVTaXplKHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHNvdXJjZVdpZHRoPzogbnVtYmVyLCBzb3VyY2VIZWlnaHQ/OiBudW1iZXIpOiBSZWdpb25EYXRhIHtcclxuICAgICAgICBjb25zdCBzdyA9IChzb3VyY2VXaWR0aCAhPT0gdW5kZWZpbmVkKSA/IHNvdXJjZVdpZHRoIDogdGhpcy5zb3VyY2VXaWR0aDtcclxuICAgICAgICBjb25zdCBzaCA9IChzb3VyY2VIZWlnaHQgIT09IHVuZGVmaW5lZCkgPyBzb3VyY2VIZWlnaHQgOiB0aGlzLnNvdXJjZUhlaWdodDtcclxuXHJcbiAgICAgICAgY29uc3QgeGYgPSB0aGlzLmZyYW1lV2lkdGggLyBzdztcclxuICAgICAgICBjb25zdCB5ZiA9IHRoaXMuZnJhbWVIZWlnaHQgLyBzaDtcclxuXHJcbiAgICAgICAgY29uc3QgcmQgPSByZWdpb25EYXRhLmNvcHkoKTtcclxuICAgICAgICByZC5zY2FsZSh4ZiwgeWYpO1xyXG4gICAgICAgIHJldHVybiByZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGhlbHBlciB0byBjcmVhdGUgYSBuZXcgU1ZHIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlU1ZHRWxlbWVudCgpOiBTVkdTVkdFbGVtZW50IHtcclxuICAgICAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcclxuICAgICAgICBzdmcuaW5uZXJIVE1MID0gRWRpdG9yLlNWR0RlZnNUZW1wbGF0ZTtcclxuICAgICAgICByZXR1cm4gc3ZnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgaGVscGVyIHRvIGNyZWF0ZSBhIG5ldyBIVE1MQ2FudmFzIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlQ2FudmFzRWxlbWVudCgpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBGaWx0ZXIgZnVuY3Rpb24gSW50ZXJmYWNlLiBUcmFuc2Zvcm1hcyBwcm92aWRlZCBjYW52YXMgZWxlbWVudCBpbnRvIGEgbmV3IGBQcm9taXNlYFxyXG4gKiB0aGF0IHJldHVybnMgc29tZSBuZXcgY2FudmFzIGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBGaWx0ZXJGdW5jdGlvbiA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PjtcclxuXHJcbi8qKlxyXG4gKiBJbnZlcnRpb24gZmlsdGVyLlxyXG4gKiBAcGFyYW0gY2FudmFzIC0gU291cmNlIEhUTUxDYW52YXMgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBJbnZlcnRGaWx0ZXIoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFByb21pc2U8SFRNTENhbnZhc0VsZW1lbnQ+IHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICBjb25zdCBidWZmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIGJ1ZmYud2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICBidWZmLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgZGF0YVtpXSA9IDI1NSAtIGRhdGFbaV07ICAgICAvLyByZWRcclxuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdOyAvLyBncmVlblxyXG4gICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07IC8vIGJsdWVcclxuICAgIH1cclxuXHJcbiAgICBidWZmLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8SFRNTENhbnZhc0VsZW1lbnQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZShidWZmKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogR3JheXNjYWxlIGZpbHRlci5cclxuICogQHBhcmFtIGNhbnZhcyAtIFNvdXJjZSBIVE1MQ2FudmFzIGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gR3JheXNjYWxlRmlsdGVyKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PiB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgY29uc3QgYnVmZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICBidWZmLndpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgYnVmZi5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgIGNvbnN0IGdyYXkgPSAwLjIxMjYgKiBkYXRhW2ldICsgMC43MTUyICogZGF0YVtpICsgMV0gKyAwLjA3MjIgKiBkYXRhW2kgKyAyXTtcclxuICAgICAgICBkYXRhW2ldID0gZ3JheTsgICAgICAvLyByZWRcclxuICAgICAgICBkYXRhW2kgKyAxXSA9IGdyYXk7ICAgICAgLy8gZ3JlZW5cclxuICAgICAgICBkYXRhW2kgKyAyXSA9IGdyYXk7ICAgICAgLy8gYmx1ZVxyXG4gICAgfVxyXG5cclxuICAgIGJ1ZmYuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxIVE1MQ2FudmFzRWxlbWVudD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlKGJ1ZmYpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBlcmltZW50YWwgYmx1ciBkaWZmZXJlbmNlIGZpbHRlci5cclxuICogQHBhcmFtIGZhY3RvciAtIEJsdXJpbmcgZmFjdG9yIChpbiBwaXhlbHMpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJEaWZmRmlsdGVyKGZhY3RvcjogbnVtYmVyKTogRmlsdGVyRnVuY3Rpb24ge1xyXG4gICAgLy8gaHR0cDovL2Jsb2cuaXZhbmsubmV0L2Zhc3Rlc3QtZ2F1c3NpYW4tYmx1ci5odG1sXHJcbiAgICBmdW5jdGlvbiBib3hlc0ZvckdhdXNzKHNpZ21hOiBudW1iZXIsIG46IG51bWJlcik6IG51bWJlcltdIHtcclxuICAgICAgICBjb25zdCB3SWRlYWwgPSBNYXRoLnNxcnQoKDEyICogc2lnbWEgKiBzaWdtYSAvIG4pICsgMSk7ICAvLyBJZGVhbCBhdmVyYWdpbmcgZmlsdGVyIHdpZHRoXHJcbiAgICAgICAgbGV0IHdsID0gTWF0aC5mbG9vcih3SWRlYWwpO1xyXG4gICAgICAgIGlmICh3bCAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgd2wtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd3UgPSB3bCArIDI7XHJcblxyXG4gICAgICAgIGNvbnN0IG1JZGVhbCA9ICgxMiAqIHNpZ21hICogc2lnbWEgLSBuICogd2wgKiB3bCAtIDQgKiBuICogd2wgLSAzICogbikgLyAoLTQgKiB3bCAtIDQpO1xyXG4gICAgICAgIGNvbnN0IG0gPSBNYXRoLnJvdW5kKG1JZGVhbCk7XHJcbiAgICAgICAgLy8gdmFyIHNpZ21hQWN0dWFsID0gTWF0aC5zcXJ0KCAobSp3bCp3bCArIChuLW0pKnd1Knd1IC0gbikvMTIgKTtcclxuICAgICAgICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgc2l6ZXMucHVzaChpIDwgbSA/IHdsIDogd3UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2l6ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2F1c3NCbHVyXzQoc2NsOiBVaW50OENsYW1wZWRBcnJheSwgdGNsOiBVaW50OENsYW1wZWRBcnJheSwgdzogbnVtYmVyLCBoOiBudW1iZXIsIHI6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IGJ4cyA9IGJveGVzRm9yR2F1c3MociwgMyk7XHJcbiAgICAgICAgYm94Qmx1cl80IChzY2wsIHRjbCwgdywgaCwgKGJ4c1swXSAtIDEpIC8gMik7XHJcbiAgICAgICAgYm94Qmx1cl80ICh0Y2wsIHNjbCwgdywgaCwgKGJ4c1sxXSAtIDEpIC8gMik7XHJcbiAgICAgICAgYm94Qmx1cl80IChzY2wsIHRjbCwgdywgaCwgKGJ4c1syXSAtIDEpIC8gMik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBib3hCbHVyXzQoc2NsOiBVaW50OENsYW1wZWRBcnJheSwgdGNsOiBVaW50OENsYW1wZWRBcnJheSwgdzogbnVtYmVyLCBoOiBudW1iZXIsIHI6IG51bWJlcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRjbFtpXSA9IHNjbFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYm94Qmx1ckhfNCh0Y2wsIHNjbCwgdywgaCwgcik7XHJcbiAgICAgICAgYm94Qmx1clRfNChzY2wsIHRjbCwgdywgaCwgcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBib3hCbHVySF80KHNjbDogVWludDhDbGFtcGVkQXJyYXksIHRjbDogVWludDhDbGFtcGVkQXJyYXksIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBpYXJyID0gMSAvIChyICsgciArIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB0aSA9IGkgKiB3O1xyXG4gICAgICAgICAgICBsZXQgbGkgPSB0aTtcclxuICAgICAgICAgICAgbGV0IHJpID0gdGkgKyByO1xyXG4gICAgICAgICAgICBjb25zdCBmdiA9IHNjbFt0aV07XHJcbiAgICAgICAgICAgIGNvbnN0IGx2ID0gc2NsW3RpICsgdyAtIDFdO1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gKHIgKyAxKSAqIGZ2O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFsICs9IHNjbFt0aSArIGpdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwICA7IGogPD0gciA7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFsICs9IHNjbFtyaSsrXSAtIGZ2O1xyXG4gICAgICAgICAgICAgICAgdGNsW3RpKytdID0gTWF0aC5yb3VuZCh2YWwgKiBpYXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gciArIDE7IGogPCB3IC0gcjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgKz0gc2NsW3JpKytdIC0gc2NsW2xpKytdO1xyXG4gICAgICAgICAgICAgICAgdGNsW3RpKytdID0gTWF0aC5yb3VuZCh2YWwgKiBpYXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gdyAtIHI7IGogPCB3OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBsdiAtIHNjbFtsaSsrXTtcclxuICAgICAgICAgICAgICAgIHRjbFt0aSsrXSA9IE1hdGgucm91bmQodmFsICogaWFycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBib3hCbHVyVF80KHNjbDogVWludDhDbGFtcGVkQXJyYXksIHRjbDogVWludDhDbGFtcGVkQXJyYXksIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBpYXJyID0gMSAvIChyICsgciArIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB0aSA9IGk7XHJcbiAgICAgICAgICAgIGxldCBsaSA9IHRpO1xyXG4gICAgICAgICAgICBsZXQgcmkgPSB0aSArIHIgKiB3O1xyXG4gICAgICAgICAgICBjb25zdCBmdiA9IHNjbFt0aV07XHJcbiAgICAgICAgICAgIGNvbnN0IGx2ID0gc2NsW3RpICsgdyAqIChoIC0gMSldO1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gKHIgKyAxKSAqIGZ2O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFsICs9IHNjbFt0aSArIGogKiB3XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSByOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBzY2xbcmldIC0gZnY7XHJcbiAgICAgICAgICAgICAgICB0Y2xbdGldID0gTWF0aC5yb3VuZCh2YWwgKiBpYXJyKTtcclxuICAgICAgICAgICAgICAgIHJpICs9IHc7XHJcbiAgICAgICAgICAgICAgICB0aSArPSB3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSByICsgMTsgaiA8IGggLSByOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBzY2xbcmldIC0gc2NsW2xpXTtcclxuICAgICAgICAgICAgICAgIHRjbFt0aV0gPSBNYXRoLnJvdW5kKHZhbCAqIGlhcnIpO1xyXG4gICAgICAgICAgICAgICAgbGkgKz0gdztcclxuICAgICAgICAgICAgICAgIHJpICs9IHc7XHJcbiAgICAgICAgICAgICAgICB0aSArPSB3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBoIC0gcjsgaiA8IGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFsICs9IGx2IC0gc2NsW2xpXTtcclxuICAgICAgICAgICAgICAgIHRjbFt0aV0gPSBNYXRoLnJvdW5kKHZhbCAqIGlhcnIpO1xyXG4gICAgICAgICAgICAgICAgbGkgKz0gdztcclxuICAgICAgICAgICAgICAgIHRpICs9IHc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3QgYnVmZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgYnVmZi53aWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgICBidWZmLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGJsdWREYXRhID0gYnVmZi5nZXRDb250ZXh0KFwiMmRcIikuY3JlYXRlSW1hZ2VEYXRhKGJ1ZmYud2lkdGgsIGJ1ZmYuaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBpZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGJkYXRhID0gYmx1ZERhdGEuZGF0YTtcclxuXHJcbiAgICAgICAgY29uc3QgcGl4ZWxzTnVtYmVyID0gY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDtcclxuICAgICAgICBjb25zdCBkYXRhUiA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwaXhlbHNOdW1iZXIpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFHID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsc051bWJlcik7XHJcbiAgICAgICAgY29uc3QgZGF0YUIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkocGl4ZWxzTnVtYmVyKTtcclxuICAgICAgICBjb25zdCBkYXRhQSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwaXhlbHNOdW1iZXIpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsc051bWJlcjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFSW2ldID0gaWRhdGFbNCAqIGldO1xyXG4gICAgICAgICAgICBkYXRhR1tpXSA9IGlkYXRhWzQgKiBpICsgMV07XHJcbiAgICAgICAgICAgIGRhdGFCW2ldID0gaWRhdGFbNCAqIGkgKyAyXTtcclxuICAgICAgICAgICAgZGF0YUFbaV0gPSBpZGF0YVs0ICogaSArIDNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYmx1clIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkocGl4ZWxzTnVtYmVyKTtcclxuICAgICAgICBjb25zdCBibHVyRyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwaXhlbHNOdW1iZXIpO1xyXG4gICAgICAgIGNvbnN0IGJsdXJCID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsc051bWJlcik7XHJcbiAgICAgICAgY29uc3QgYmx1clIyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsc051bWJlcik7XHJcbiAgICAgICAgY29uc3QgYmx1ckcyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsc051bWJlcik7XHJcbiAgICAgICAgY29uc3QgYmx1ckIyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsc051bWJlcik7XHJcbiAgICAgICAgLy8gbGV0IGJsdXJBID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBpeGVsc051bWJlcik7XHJcblxyXG4gICAgICAgIGNvbnN0IGhhbGZGYWN0b3IgPSBmYWN0b3IgLyAyO1xyXG4gICAgICAgIGdhdXNzQmx1cl80KGRhdGFSLCBibHVyUiwgYnVmZi53aWR0aCwgYnVmZi5oZWlnaHQsIGhhbGZGYWN0b3IpO1xyXG4gICAgICAgIGdhdXNzQmx1cl80KGRhdGFHLCBibHVyRywgYnVmZi53aWR0aCwgYnVmZi5oZWlnaHQsIGhhbGZGYWN0b3IpO1xyXG4gICAgICAgIGdhdXNzQmx1cl80KGRhdGFCLCBibHVyQiwgYnVmZi53aWR0aCwgYnVmZi5oZWlnaHQsIGhhbGZGYWN0b3IpO1xyXG4gICAgICAgIGdhdXNzQmx1cl80KGRhdGFSLCBibHVyUjIsIGJ1ZmYud2lkdGgsIGJ1ZmYuaGVpZ2h0LCBmYWN0b3IpO1xyXG4gICAgICAgIGdhdXNzQmx1cl80KGRhdGFHLCBibHVyRzIsIGJ1ZmYud2lkdGgsIGJ1ZmYuaGVpZ2h0LCBmYWN0b3IpO1xyXG4gICAgICAgIGdhdXNzQmx1cl80KGRhdGFCLCBibHVyQjIsIGJ1ZmYud2lkdGgsIGJ1ZmYuaGVpZ2h0LCBmYWN0b3IpO1xyXG5cclxuICAgICAgICBjb25zdCBhbHBoYVN0ZXAgPSAxMjcgLyBmYWN0b3I7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGl4ZWxzTnVtYmVyOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZHIgPSBNYXRoLmFicyhibHVyUjJbaV0gLSBibHVyUltpXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRnID0gTWF0aC5hYnMoYmx1ckcyW2ldIC0gYmx1ckdbaV0pO1xyXG4gICAgICAgICAgICBjb25zdCBkYiA9IE1hdGguYWJzKGJsdXJCMltpXSAtIGJsdXJCW2ldKTtcclxuICAgICAgICAgICAgLy8gY29uc3QgZCA9IDAuMjEyNiAqIGRyICsgMC43MTUyICogZGcgKyAwLjA3MjIgKiBkYjtcclxuICAgICAgICAgICAgY29uc3QgZCA9IDAuMjM1OCAqIGRyICsgMC4wNzAwICogZGcgKyAwLjY3NDIgKiBkYjtcclxuXHJcbiAgICAgICAgICAgIC8qIGxldCBkciA9IE1hdGguYWJzKGJsdXJSMltpXSAtIGlkYXRhWzQgKiBpICsgMF0pO1xyXG4gICAgICAgICAgICBsZXQgZGcgPSBNYXRoLmFicyhibHVyRzJbaV0gLSBpZGF0YVs0ICogaSArIDFdKTtcclxuICAgICAgICAgICAgbGV0IGRiID0gTWF0aC5hYnMoYmx1ckIyW2ldIC0gaWRhdGFbNCAqIGkgKyAyXSk7ICovXHJcbiAgICAgICAgICAgIC8vIGxldCBkID0gMjU1IC0gTWF0aC5taW4oTWF0aC5yb3VuZChNYXRoLm1heChkciArIGRnICsgZGIgLSAxNiwgMCkvOCkgKiAxNiwgMjU1KTtcclxuXHJcbiAgICAgICAgICAgIC8qIGJkYXRhWzQgKiBpICsgMF0gPSBkO1xyXG4gICAgICAgICAgICBiZGF0YVs0ICogaSArIDFdID0gZDtcclxuICAgICAgICAgICAgYmRhdGFbNCAqIGkgKyAyXSA9IGQ7ICovXHJcblxyXG4gICAgICAgICAgICAvKiBiZGF0YVs0ICogaSArIDBdID0gKGQgPCBmYWN0b3IpID8gTWF0aC5yb3VuZChpZGF0YVs0ICogaSArIDBdIC8gZmFjdG9yKSAqIGZhY3RvciA6IGlkYXRhWzQgKiBpICsgMF07XHJcbiAgICAgICAgICAgIGJkYXRhWzQgKiBpICsgMV0gPSAoZCA8IGZhY3RvcikgPyBNYXRoLnJvdW5kKGlkYXRhWzQgKiBpICsgMV0gLyBmYWN0b3IpICogZmFjdG9yIDogaWRhdGFbNCAqIGkgKyAxXTtcclxuICAgICAgICAgICAgYmRhdGFbNCAqIGkgKyAyXSA9IChkIDwgZmFjdG9yKSA/IE1hdGgucm91bmQoaWRhdGFbNCAqIGkgKyAyXSAvIGZhY3RvcikgKiBmYWN0b3IgOiBpZGF0YVs0ICogaSArIDJdOyAqL1xyXG5cclxuICAgICAgICAgICAgLyogYmRhdGFbNCAqIGkgKyAwXSA9IChkciA+PSAwLjIxMjYgKiBmYWN0b3IpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGF0YVs0ICogaSArIDBdIDogIE1hdGgucm91bmQoaWRhdGFbNCAqIGkgKyAwXSAvIGZhY3RvcikgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGJkYXRhWzQgKiBpICsgMV0gPSAoZGcgPj0gMC43MTUyICogZmFjdG9yKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRhdGFbNCAqIGkgKyAxXSA6ICBNYXRoLnJvdW5kKGlkYXRhWzQgKiBpICsgMV0gLyBmYWN0b3IpICogZmFjdG9yO1xyXG4gICAgICAgICAgICBiZGF0YVs0ICogaSArIDJdID0gKGRiID49IDAuMDcyMiAqIGZhY3RvcikgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYXRhWzQgKiBpICsgMl0gOiAgTWF0aC5yb3VuZChpZGF0YVs0ICogaSArIDJdIC8gZmFjdG9yKSAqIGZhY3RvcjsgKi9cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSBNYXRoLnJvdW5kKDAuMjM1OCAqIGlkYXRhWzQgKiBpICsgMF0gKyAwLjA3MDAgKiBpZGF0YVs0ICogaSArIDFdICsgMC42NzQyICogaWRhdGFbNCAqIGkgKyAyXSk7XHJcblxyXG4gICAgICAgICAgICBiZGF0YVs0ICogaSArIDBdID0gKGRyID49IDAuMjM1OCAqIGhhbGZGYWN0b3IpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGF0YVs0ICogaSArIDBdIDogIE1hdGgucm91bmQoZyAvIGZhY3RvcikgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGJkYXRhWzQgKiBpICsgMV0gPSAoZGcgPj0gMC4wNzAwICogaGFsZkZhY3RvcikgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkYXRhWzQgKiBpICsgMV0gOiAgTWF0aC5yb3VuZChnIC8gZmFjdG9yKSAqIGZhY3RvcjtcclxuICAgICAgICAgICAgYmRhdGFbNCAqIGkgKyAyXSA9IChkYiA+PSAwLjY3NDIgKiBoYWxmRmFjdG9yKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRhdGFbNCAqIGkgKyAyXSA6ICBNYXRoLnJvdW5kKGcgLyBmYWN0b3IpICogZmFjdG9yO1xyXG5cclxuICAgICAgICAgICAgLyogYmRhdGFbNCAqIGkgKyAwXSA9IE1hdGgucm91bmQoaWRhdGFbNCAqIGkgKyAwXSAvIDgpICogODtcclxuICAgICAgICAgICAgYmRhdGFbNCAqIGkgKyAxXSA9IE1hdGgucm91bmQoaWRhdGFbNCAqIGkgKyAxXSAvIDgpICogODtcclxuICAgICAgICAgICAgYmRhdGFbNCAqIGkgKyAyXSA9IE1hdGgucm91bmQoaWRhdGFbNCAqIGkgKyAyXSAvIDgpICogODsgKi9cclxuICAgICAgICAgICAgYmRhdGFbNCAqIGkgKyAzXSA9IChkID49IGZhY3RvcikgPyAyNTUgOiAwICsgTWF0aC5yb3VuZChkICogYWxwaGFTdGVwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJ1ZmYuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShibHVkRGF0YSwgMCwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxIVE1MQ2FudmFzRWxlbWVudD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShidWZmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCcmlnaHRuZXNzIGZpbHRlci5cclxuICogQHBhcmFtIGJyaWdodG5lc3MgLSBUaGUgYnJpZ2h0bmVzcyB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDI1NV0gdG8gYmUgYWRkZWQgdG8gcGl4ZWxzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEJyaWdodG5lc3NGaWx0ZXIoYnJpZ2h0bmVzczogbnVtYmVyKTogRmlsdGVyRnVuY3Rpb24ge1xyXG4gICAgcmV0dXJuIChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgY29uc3QgYnVmZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgYnVmZi53aWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgICBidWZmLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDBdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGF0YVtpICsgMF0gKyBicmlnaHRuZXNzLCAyNTUpKTtcclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkYXRhW2kgKyAxXSArIGJyaWdodG5lc3MsIDI1NSkpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRhdGFbaSArIDJdICsgYnJpZ2h0bmVzcywgMjU1KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBidWZmLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGJ1ZmYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnRyYXN0IGZpbHRlci5cclxuICogQHBhcmFtIGNvbnRyYXN0IC0gVGhlIGNvbnRyYXN0IGZhY3RvciBpbiB0aGUgcmFuZ2UgWy0yNTUsIDI1NV0gdG8gYmUgYXBwbGllZCB0byBwaXhlbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQ29udHJhc3RGaWx0ZXIoY29udHJhc3Q6IG51bWJlcik6IEZpbHRlckZ1bmN0aW9uIHtcclxuICAgIHJldHVybiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIGJ1ZmYud2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICAgICAgYnVmZi5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgY29uc3QgZmFjdG9yID0gKDI1OSAqIChjb250cmFzdCArIDI1NSkpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgZGF0YVtpICsgMF0gPSBmYWN0b3IgKiAoZGF0YVtpXSAtIDEyOCkgKyAxMjg7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZmFjdG9yICogKGRhdGFbaSArIDFdIC0gMTI4KSArIDEyODtcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBmYWN0b3IgKiAoZGF0YVtpICsgMl0gLSAxMjgpICsgMTI4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnVmZi5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxIVE1MQ2FudmFzRWxlbWVudD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShidWZmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYXR1cmF0aW9uIGZpbHRlclxyXG4gKiBAcGFyYW0gc2F0dXJhdGlvbiAtIFRoZSBzYXR1cmF0aW9uIGZhY3RvciBpbiB0aGUgcmFuZ2UgWzAsIDI1NV0gdG8gYmUgYXBwbGllZCB0byBwaXhlbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gU2F0dXJhdGlvbkZpbHRlcihzYXR1cmF0aW9uOiBudW1iZXIpOiBGaWx0ZXJGdW5jdGlvbiB7XHJcbiAgICByZXR1cm4gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICBjb25zdCBidWZmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICBidWZmLndpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgIGJ1ZmYuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuXHJcbiAgICAgICAgY29uc3QgcyA9IHNhdHVyYXRpb24gLyAyNTU7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgY29uc3QgciA9IGRhdGFbaSArIDBdO1xyXG4gICAgICAgICAgICBjb25zdCBnID0gZGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSBkYXRhW2kgKyAyXTtcclxuICAgICAgICAgICAgY29uc3QgZ3IgPSAwLjIxMyAgKiByICsgMC43MTUgKiBnICsgMC4wNzIgKiBiO1xyXG4gICAgICAgICAgICBjb25zdCBuciA9IGdyICsgcyAqICgrIDAuNzg3ICogciAtIDAuNzE1ICogZyAtIDAuMDcyICogYik7XHJcbiAgICAgICAgICAgIGNvbnN0IG5nID0gZ3IgKyBzICogKC0gMC4yMTMgKiByICsgMC4yODUgKiBnIC0gMC4wNzIgKiBiKTtcclxuICAgICAgICAgICAgY29uc3QgbmIgPSBnciArIHMgKiAoLSAwLjIxMyAqIHIgLSAwLjcxNSAqIGcgKyAwLjkyOCAqIGIpO1xyXG5cclxuICAgICAgICAgICAgZGF0YVtpXSA9ICBNYXRoLnJvdW5kKG5yKTsgICAgIC8vIHJlZFxyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9ICBNYXRoLnJvdW5kKG5nKTsgICAgIC8vIGdyZWVuXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gIE1hdGgucm91bmQobmIpOyAgICAgIC8vIGJsdWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJ1ZmYuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8SFRNTENhbnZhc0VsZW1lbnQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYnVmZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKiAgICAgY29udm9sdXRlRmlsdGVyKGNhbnZhcywgd2VpZ2h0cywgb3BhcXVlKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xyXG4gICAgICAgIHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZS8yKTtcclxuICAgICAgICB2YXIgc3JjID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgdmFyIHN3ID0gaW1hZ2VEYXRhLndpZHRoO1xyXG4gICAgICAgIHZhciBzaCA9IGltYWdlRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgLy8gcGFkIG91dHB1dCBieSB0aGUgY29udm9sdXRpb24gbWF0cml4XHJcbiAgICAgICAgdmFyIHcgPSBzdztcclxuICAgICAgICB2YXIgaCA9IHNoO1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSBuZXcgSW1hZ2VEYXRhKHcsIGgpO1xyXG5cclxuICAgICAgICB2YXIgZHN0ID0gb3V0cHV0LmRhdGE7XHJcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXHJcbiAgICAgICAgdmFyIGFscGhhRmFjID0gb3BhcXVlID8gMSA6IDA7XHJcbiAgICAgICAgZm9yICh2YXIgeT0wOyB5PGg7IHkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4PTA7IHg8dzsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3kgPSB5O1xyXG4gICAgICAgICAgICAgICAgdmFyIHN4ID0geDtcclxuICAgICAgICAgICAgICAgIHZhciBkc3RPZmYgPSAoeSp3K3gpKjQ7XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcclxuICAgICAgICAgICAgICAgIC8vIGZhbGwgdW5kZXIgdGhlIGNvbnZvbHV0aW9uIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgdmFyIHI9MCwgZz0wLCBiPTAsIGE9MDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGN5PTA7IGN5PHNpZGU7IGN5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjeD0wOyBjeDxzaWRlOyBjeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3kgPSBzeSArIGN5IC0gaGFsZlNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBzeCArIGN4IC0gaGFsZlNpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IChzY3kqc3crc2N4KSo0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSpzaWRlK2N4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgKz0gc3JjW3NyY09mZl0gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgKz0gc3JjW3NyY09mZisxXSAqIHd0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmKzJdICogd3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhICs9IHNyY1tzcmNPZmYrM10gKiB3dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcclxuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMV0gPSBnO1xyXG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZisyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzNdID0gYSArIGFscGhhRmFjKigyNTUtYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgYEZpbHRlclBpcGVsaW5lYCBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBhIHBpcGVsaW5lIG9mIGNhbnZhcyBkYXRhIHRyYW5zZm9ybWF0aW9uc1xyXG4gKiBiZWZvcmUgZGlzcGxheWluZyBpdCB0byB0aGUgdXNlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGaWx0ZXJQaXBlbGluZSB7XHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIGZpbHRlcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGlwZWxpbmU6IEZpbHRlckZ1bmN0aW9uW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEZpbHRlclBpcGVsaW5lYC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5waXBlbGluZSA9IG5ldyBBcnJheTxGaWx0ZXJGdW5jdGlvbj4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBuZXcgZmlsdGVyIGZ1bmN0aW9uIHRvIHBpcGVsaW5lLlxyXG4gICAgICogQHBhcmFtIGZpbHRlciAtIEEgbmV3IGZpbHRlciBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZEZpbHRlcihmaWx0ZXI6IEZpbHRlckZ1bmN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5waXBlbGluZS5wdXNoKGZpbHRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBhbGwgdGhlIGZpbHRlcnMgaW4gcGlwZWxpbmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjbGVhckZpbHRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5waXBlbGluZSA9IG5ldyBBcnJheTxGaWx0ZXJGdW5jdGlvbj4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGZpbHRlcnMgcGlwZWxpbmUgdG8gcHJvdmlkZWQgc291cmNlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBjYW52YXMgLSBUaGUgc291cmNlIEhUTUwgQ2FudmFzIGVsZW1lbnQuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgUHJvbWlzZWAgcmVzb2x2ZWQgd2hlbiBhbGwgZmlsdGVycyBhcmUgYXBwbHllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFwcGx5VG9DYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFByb21pc2U8SFRNTENhbnZhc0VsZW1lbnQ+IHtcclxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhbnZhcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBpcGVsaW5lLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5waXBlbGluZS5mb3JFYWNoKChmaWx0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZmlsdGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFJHQkNvbG9yIH0gZnJvbSBcIi4vUkdCQ29sb3JcIjtcclxuaW1wb3J0IHsgU1JHQkNvbG9yIH0gZnJvbSBcIi4vU1JHQkNvbG9yXCI7XHJcbmltcG9ydCB7IFhZWkNvbG9yIH0gZnJvbSBcIi4vWFlaQ29sb3JcIjtcclxuaW1wb3J0IHsgTEFCQ29sb3IgfSBmcm9tIFwiLi9MQUJDb2xvclwiO1xyXG5pbXBvcnQgeyBIU0xDb2xvciB9IGZyb20gXCIuL0hTTENvbG9yXCI7XHJcblxyXG4vKipcclxuICogQSB3cmFwcGVyIGBDb2xvcmAgY2xhc3MgdG8gcmVwcmVzZW50IHZhcmlvdXMgY29sb3IgZm9ybWF0c1xyXG4gKiBhbmQgbWFuYWdlIGNvbnZlcnNpb25zIGJldHdlZW4gdGhlbS5cclxuICogQHJlbWFya3MgVGhlIGN1cnJlbnQgd29yayBvbiBkZWZpbmluZyBjb2xvciBtYW5hZ2VtZW50IGluIHdlYiAoaW5jbHVkaW5nIGNvbnZlcnNpb24gYWxnb3JpdGhtcylcclxuICogY2FuIGJlIHRyYWNrZWQgaW4gdGhpcyBkcmFmdDogaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci9cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2xvciB7XHJcbiAgICBwdWJsaWMgZ2V0IHNSR0IoKTogU1JHQkNvbG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zcmdiQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBSR0IoKTogUkdCQ29sb3Ige1xyXG4gICAgICAgIGlmICh0aGlzLnJnYkNvbG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZ2JDb2xvciA9IHRoaXMuc3JnYkNvbG9yLnRvUkdCKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5yZ2JDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IFhZWigpOiBYWVpDb2xvciB7XHJcbiAgICAgICAgaWYgKHRoaXMueHl6Q29sb3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnh5ekNvbG9yID0gdGhpcy5SR0IudG9YWVooKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnh5ekNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgTEFCKCk6IExBQkNvbG9yIHtcclxuICAgICAgICBpZiAodGhpcy5sYWJDb2xvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFiQ29sb3IgPSB0aGlzLlhZWi50b0xBQigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBIU0woKTogSFNMQ29sb3Ige1xyXG4gICAgICAgIGlmICh0aGlzLmhzbENvbG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5oc2xDb2xvciA9IHRoaXMuc3JnYkNvbG9yLnRvSFNMKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5oc2xDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNyZ2JDb2xvcjogU1JHQkNvbG9yO1xyXG4gICAgcHJpdmF0ZSByZ2JDb2xvcjogUkdCQ29sb3I7XHJcbiAgICBwcml2YXRlIHh5ekNvbG9yOiBYWVpDb2xvcjtcclxuICAgIHByaXZhdGUgbGFiQ29sb3I6IExBQkNvbG9yO1xyXG4gICAgcHJpdmF0ZSBoc2xDb2xvcjogSFNMQ29sb3I7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3JnYjogU1JHQkNvbG9yKTtcclxuICAgIGNvbnN0cnVjdG9yKHJnYjogUkdCQ29sb3IpO1xyXG4gICAgY29uc3RydWN0b3IoaHNsOiBIU0xDb2xvcik7XHJcbiAgICBjb25zdHJ1Y3Rvcih4eXo6IFhZWkNvbG9yKTtcclxuICAgIGNvbnN0cnVjdG9yKGxhYjogTEFCQ29sb3IpO1xyXG4gICAgY29uc3RydWN0b3Ioc3JnYkNTU1N0cmluZzogc3RyaW5nKTtcclxuICAgIGNvbnN0cnVjdG9yKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpO1xyXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBjb25zdCBjID0gYXJnc1swXTtcclxuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBTUkdCQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3JnYkNvbG9yID0gYztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjIGluc3RhbmNlb2YgUkdCQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmdiQ29sb3IgPSBjO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcmdiQ29sb3IgPSBjLnRvU1JHQigpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgaW5zdGFuY2VvZiBIU0xDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oc2xDb2xvciA9IGM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNyZ2JDb2xvciA9IGMudG9TUkdCKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyBpbnN0YW5jZW9mIFhZWkNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnh5ekNvbG9yID0gYztcclxuICAgICAgICAgICAgICAgIHRoaXMucmdiQ29sb3IgPSBjLnRvUkdCKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNyZ2JDb2xvciA9IHRoaXMucmdiQ29sb3IudG9TUkdCKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyBpbnN0YW5jZW9mIExBQkNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYkNvbG9yID0gYztcclxuICAgICAgICAgICAgICAgIHRoaXMueHl6Q29sb3IgPSBjLnRvWFlaKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJnYkNvbG9yID0gdGhpcy54eXpDb2xvci50b1JHQigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcmdiQ29sb3IgPSB0aGlzLnJnYkNvbG9yLnRvU1JHQigpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNyZ2JDb2xvciA9IFNSR0JDb2xvci5QYXJzZUhleChjKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGFyZyB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgdGhlICcqKipDb2xvcicgdHlwZXMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGFyZ3NbMV0gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGFyZ3NbMl0gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3JnYkNvbG9yID0gbmV3IFNSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGFyZyB0eXBlLiBFeHBlY3RlZCAzIGFyZ3Mgb2YgdGhlICdudW1iZXInIHR5cGUuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGFyZ3MgZm9yIENvbG9yIGNvbnN0cnVjdG9yLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgU1JHQkNvbG9yIH0gZnJvbSBcIi4vU1JHQkNvbG9yXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgSFNMIGNvbG9yIHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEhTTENvbG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGh1ZSB2YWx1ZSBvZiB0aGUgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgaCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1swXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzYXR1cmF0aW9uIHZhbHVlIG9mIHRoZSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpZ2h0bmVzcyB2YWx1ZSBvZiB0aGUgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgbCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1syXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIGNvbG9yIGNvbXBvbmVudHMgYXMgW2gsIHMsIGxdLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHZhbHVlczogbnVtYmVyW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBIU0xDb2xvclxyXG4gICAgICogQHBhcmFtIGggLSBIdWUgY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwgMV0uXHJcbiAgICAgKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24gY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwgMV0uXHJcbiAgICAgKiBAcGFyYW0gbCAtIExpZ2h0bmVzcyBjb21wb25lbnQgaW4gdGhlIHJhbmdlIFswLCAxXS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaDogbnVtYmVyLCBzOiBudW1iZXIsIGw6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gW2gsIHMsIGxdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgY29weSBvZiBjb2xvciB2YWx1ZXMgaW4gYXJyYXkgZm9ybWF0IGFzIFtoLCBzLCBsXS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQXJyYXkoKTogbnVtYmVyW10ge1xyXG4gICAgICAgIC8vIGNvcHlcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMubWFwKCh2KSA9PiB2KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBjb2xvciB2YWx1ZXMgbWFwcGVkIHRvIHRoZSByYW5nZXMgdXNlZCBpbiBDU1M6XHJcbiAgICAgKiBodWUgLSBbMCwgMzYwXVxyXG4gICAgICogc2F0dXJhdGlvbiAtIFswLCAxMDBdICVcclxuICAgICAqIGxpZ2h0bmVzcyAtIFswLCAxMDBdICVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQ1NTVmFsdWVzKCk6IG51bWJlcltdIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuaCAqIDM2MCwgdGhpcy5zICogMTAwLCB0aGlzLmwgKiAxMDBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9zZXMgdGhlIENTUyBjb2xvciBzdHJpbmcgdXNpbmcgdGhlIGhzbCgpIG9yIGhzbGEoKSBmb3JtYXQuXHJcbiAgICAgKiBAcGFyYW0gYWxwaGEgLSBUaGUgYWxwaGEgdmFsdWUgZm9yIGhzbGEoKSBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0NTU1N0cmluZyhhbHBoYT86IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgW2gsIHMsIGxdID0gdGhpcy50b0NTU1ZhbHVlcygpO1xyXG5cclxuICAgICAgICBpZiAoYWxwaGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBjYXN0IHRvIFswLCAxXVxyXG4gICAgICAgICAgICBhbHBoYSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGFscGhhKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YWxwaGF9KWA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhc2Zvcm1zIGNvbG9yIHRvIHRoZSBSR0IgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TUkdCKCk6IFNSR0JDb2xvciB7XHJcbiAgICAgICAgLyogaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xyXG4gICAgICAgIEhPVyBUTyBSRVRVUk4gaHNsLnRvLnJnYihoLCBzLCBsKTpcclxuICAgICAgICAgICAgU0VMRUNUOlxyXG4gICAgICAgICAgICAgICAgbDw9MC41OiBQVVQgbCoocysxKSBJTiBtMlxyXG4gICAgICAgICAgICAgICAgRUxTRTogUFVUIGwrcy1sKnMgSU4gbTJcclxuICAgICAgICAgICAgUFVUIGwqMi1tMiBJTiBtMVxyXG4gICAgICAgICAgICBQVVQgaHVlLnRvLnJnYihtMSwgbTIsIGgrMS8zKSBJTiByXHJcbiAgICAgICAgICAgIFBVVCBodWUudG8ucmdiKG0xLCBtMiwgaCAgICApIElOIGdcclxuICAgICAgICAgICAgUFVUIGh1ZS50by5yZ2IobTEsIG0yLCBoLTEvMykgSU4gYlxyXG4gICAgICAgICAgICBSRVRVUk4gKHIsIGcsIGIpXHJcbiAgICAgICAgKi9cclxuICAgICAgICBsZXQgbTE6IG51bWJlcjtcclxuICAgICAgICBsZXQgbTI6IG51bWJlcjtcclxuICAgICAgICBjb25zdCBbaCwgcywgbF0gPSB0aGlzLnZhbHVlcztcclxuICAgICAgICBpZiAobCA8PSAwLjUpIHtcclxuICAgICAgICAgICAgbTIgPSBsICogKHMgKyAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtMiA9IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG0xID0gbCAqIDIgLSBtMjtcclxuICAgICAgICBjb25zdCByID0gdGhpcy5odWUycmdiKG0xLCBtMiwgaCArIDEgLyAzKTtcclxuICAgICAgICBjb25zdCBnID0gdGhpcy5odWUycmdiKG0xLCBtMiwgaCk7XHJcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuaHVlMnJnYihtMSwgbTIsIGggLSAxIC8gMyk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgU1JHQkNvbG9yKHIsIGcsIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciB0aGUgYHRvUkdCYCBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaHVlMnJnYihtMTogbnVtYmVyLCBtMjogbnVtYmVyLCBoOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIC8qIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cclxuICAgICAgICBIT1cgVE8gUkVUVVJOIGh1ZS50by5yZ2IobTEsIG0yLCBoKTpcclxuICAgICAgICAgICAgSUYgaDwwOiBQVVQgaCsxIElOIGhcclxuICAgICAgICAgICAgSUYgaD4xOiBQVVQgaC0xIElOIGhcclxuICAgICAgICAgICAgSUYgaCo2PDE6IFJFVFVSTiBtMSsobTItbTEpKmgqNlxyXG4gICAgICAgICAgICBJRiBoKjI8MTogUkVUVVJOIG0yXHJcbiAgICAgICAgICAgIElGIGgqMzwyOiBSRVRVUk4gbTErKG0yLW0xKSooMi8zLWgpKjZcclxuICAgICAgICAgICAgUkVUVVJOIG0xXHJcbiAgICAgICAqL1xyXG4gICAgICAgIGlmIChoIDwgMCkge1xyXG4gICAgICAgICAgICBoID0gaCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoID4gMSkge1xyXG4gICAgICAgICAgICBoID0gaCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoICogNiA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoICogMiA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaCAqIDMgPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBSR0JDb2xvciB9IGZyb20gXCIuL1JHQkNvbG9yXCI7XHJcbmltcG9ydCB7IFNSR0JDb2xvciB9IGZyb20gXCIuL1NSR0JDb2xvclwiO1xyXG5pbXBvcnQgeyBYWVpDb2xvciB9IGZyb20gXCIuL1hZWkNvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIEFCLXN1YnNwYWNlIGZvciB0aGUgTEFCIGNvbG9yIHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTGFiQ29sb3JQb2ludCB7XHJcbiAgICBhOiBudW1iZXI7XHJcbiAgICBiOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBDSUUgTEFCIGNvbG9yIHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExBQkNvbG9yIGltcGxlbWVudHMgSUxhYkNvbG9yUG9pbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGlnaHRuZXNzIHZhbHVlIG9mIHRoZSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBsKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGEtY29tcG9uZW50IG9mIHRoZSBjb2xvciAoZ3JlZW4gdG8gcmVkKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBhKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGItY29tcG9uZW50IG9mIHRoZSBjb2xvciAoYmx1ZSB0byB5ZWxsb3cpLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBjb2xvciBjb21wb25lbnRzIGFzIFtsLCBhLCBiXS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWx1ZXM6IG51bWJlcltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgQ0lFIExBQiBjb2xvci5cclxuICAgICAqIEBwYXJhbSBsIC0gTGlnaHRuZXNzIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICogQHBhcmFtIGEgLSBBLWNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICogQHBhcmFtIGIgLSBCLWNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihsOiBudW1iZXIsIGE6IG51bWJlciwgYjogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbbCwgYSwgYl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBjb2xvciBkaWZmZXJlbmNlIHVzaW5nIHRoZSBDSUU5NCBmb3JtdWxhIGFzIGRlZmluZWQgaGVyZTpcclxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbG9yX2RpZmZlcmVuY2UuXHJcbiAgICAgKiBAcmVtYXJrcyBJdCBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBDSUUgREUyMDAwIGZvcm11bGEsIGJ1dCBpdCByZXF1aXJlcyBzaWduaWZpY2FudGx5IG1vcmUgY29tcHV0YXRpb25zLlxyXG4gICAgICogRS5nLiwgY2hlY2sgdGhpcyByZXZlaXc6IGh0dHA6Ly93d3cuY29sb3Iub3JnL2V2ZW50cy9jb2xvcmltZXRyeS9NZWxnb3NhX0NJRURFMjAwMF9Xb3Jrc2hvcC1KdWx5NC5wZGYuXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgLSBBIGNvbG9yIHRvIGNvbXBhcmUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIGFuZCBwcm92aWRlZCBjb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBkaXN0YW5jZVRvKGNvbG9yOiBMQUJDb2xvcik6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgZGVsdGFMID0gdGhpcy52YWx1ZXNbMF0gLSBjb2xvci52YWx1ZXNbMF07XHJcbiAgICAgICAgY29uc3QgZGVsdGFBID0gdGhpcy52YWx1ZXNbMV0gLSBjb2xvci52YWx1ZXNbMV07XHJcbiAgICAgICAgY29uc3QgZGVsdGFCID0gdGhpcy52YWx1ZXNbMl0gLSBjb2xvci52YWx1ZXNbMl07XHJcbiAgICAgICAgY29uc3QgYzEgPSBNYXRoLnNxcnQodGhpcy52YWx1ZXNbMV0gKiB0aGlzLnZhbHVlc1sxXSArIHRoaXMudmFsdWVzWzJdICogdGhpcy52YWx1ZXNbMl0pO1xyXG4gICAgICAgIGNvbnN0IGMyID0gTWF0aC5zcXJ0KGNvbG9yLnZhbHVlc1sxXSAqIGNvbG9yLnZhbHVlc1sxXSArIGNvbG9yLnZhbHVlc1syXSAqIGNvbG9yLnZhbHVlc1syXSk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFDID0gYzEgLSBjMjtcclxuICAgICAgICBsZXQgZGVsdGFIID0gZGVsdGFBICogZGVsdGFBICsgZGVsdGFCICogZGVsdGFCIC0gZGVsdGFDICogZGVsdGFDO1xyXG4gICAgICAgIGRlbHRhSCA9IGRlbHRhSCA8IDAgPyAwIDogTWF0aC5zcXJ0KGRlbHRhSCk7XHJcbiAgICAgICAgY29uc3Qgc2MgPSAxLjAgKyAwLjA0NSAqIGMxO1xyXG4gICAgICAgIGNvbnN0IHNoID0gMS4wICsgMC4wMTUgKiBjMTtcclxuICAgICAgICBjb25zdCBkZWx0YUxLbHNsID0gZGVsdGFMIC8gKDEuMCk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFDa2NzYyA9IGRlbHRhQyAvIChzYyk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFIa2hzaCA9IGRlbHRhSCAvIChzaCk7XHJcbiAgICAgICAgY29uc3QgaSA9IGRlbHRhTEtsc2wgKiBkZWx0YUxLbHNsICsgZGVsdGFDa2NzYyAqIGRlbHRhQ2tjc2MgKyBkZWx0YUhraHNoICogZGVsdGFIa2hzaDtcclxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogTWF0aC5zcXJ0KGkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXN0YW5jZVRvXzAwKGNvbG9yOiBMQUJDb2xvcik6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgW0wxLCBhMSwgYjFdID0gdGhpcy52YWx1ZXM7XHJcbiAgICAgICAgY29uc3QgW0wyLCBhMiwgYjJdID0gY29sb3IudmFsdWVzO1xyXG5cclxuICAgICAgICBjb25zdCBrTCA9IDEuMDtcclxuICAgICAgICBjb25zdCBrQyA9IDEuMDtcclxuICAgICAgICBjb25zdCBrSCA9IDEuMDtcclxuICAgICAgICBjb25zdCBLMSA9IDAuMDQ1O1xyXG4gICAgICAgIGNvbnN0IEsyID0gMC4wMTU7XHJcblxyXG4gICAgICAgIGNvbnN0IGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwLjA7XHJcbiAgICAgICAgY29uc3QgcmFkMmRlZyA9IDE4MC4wIC8gTWF0aC5QSTtcclxuXHJcbiAgICAgICAgY29uc3QgZGVsdGFMID0gTDIgLSBMMTtcclxuICAgICAgICBjb25zdCBtaWRMID0gKEwxICsgTDIpIC8gMjtcclxuICAgICAgICBjb25zdCBDMSA9IE1hdGguc3FydChhMSAqIGExICsgYjEgKiBiMSk7XHJcbiAgICAgICAgY29uc3QgQzIgPSBNYXRoLnNxcnQoYTIgKiBhMiArIGIyICogYjIpO1xyXG4gICAgICAgIGNvbnN0IG1pZEMgPSAoQzEgKyBDMikgLyAyO1xyXG4gICAgICAgIGNvbnN0IG1pZEM3ID0gbWlkQyAqKiA3O1xyXG4gICAgICAgIGNvbnN0IG1pZEM3Um9vdCA9IE1hdGguc3FydChtaWRDNyAvIChtaWRDNyArIDI1ICoqIDcpKTtcclxuICAgICAgICBjb25zdCBhMXQgPSBhMSArIDAuNSAqIGExICogKDEgLSBtaWRDN1Jvb3QpO1xyXG4gICAgICAgIGNvbnN0IGEydCA9IGEyICsgMC41ICogYTIgKiAoMSAtIG1pZEM3Um9vdCk7XHJcbiAgICAgICAgY29uc3QgQzF0ID0gTWF0aC5zcXJ0KGExdCAqIGExdCArIGIxICogYjEpO1xyXG4gICAgICAgIGNvbnN0IEMydCA9IE1hdGguc3FydChhMnQgKiBhMnQgKyBiMiAqIGIyKTtcclxuICAgICAgICBjb25zdCBtaWRDdCA9IChDMXQgKyBDMnQpIC8gMjtcclxuICAgICAgICBjb25zdCBkZWx0YUN0ID0gQzJ0IC0gQzF0O1xyXG4gICAgICAgIGNvbnN0IGgxID0gKGIxID09PSAwICYmIGExdCA9PT0gMCkgPyAwIDogKE1hdGguYXRhbjIoYjEsIGExdCkgKiByYWQyZGVnKSAlIDM2MDtcclxuICAgICAgICBjb25zdCBoMiA9IChiMiA9PT0gMCAmJiBhMnQgPT09IDApID8gMCA6IChNYXRoLmF0YW4yKGIyLCBhMnQpICogcmFkMmRlZykgJSAzNjA7XHJcblxyXG4gICAgICAgIGxldCBkZWx0YWggPSBoMiAtIGgxO1xyXG4gICAgICAgIGNvbnN0IGFic0RlbHRhaCA9IE1hdGguYWJzKGRlbHRhaCk7XHJcbiAgICAgICAgaWYgKGgyIDw9IGgxICYmIGFic0RlbHRhaCA+IDE4MCkge1xyXG4gICAgICAgICAgICBkZWx0YWggKz0gMzYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaDIgPiBoMSAmJiBhYnNEZWx0YWggPiAxODApIHtcclxuICAgICAgICAgICAgZGVsdGFoIC09IDM2MDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRlbHRhSCA9IDIgKiBNYXRoLnNxcnQoQzF0ICogQzJ0KSAqIE1hdGguc2luKDAuNSAqIGRlbHRhaCAqIGRlZzJyYWQpO1xyXG4gICAgICAgIGxldCBIID0gKGgxICsgaDIpIC8gMjtcclxuICAgICAgICBpZiAoYWJzRGVsdGFoID4gMTgwICYmIGgxICsgaDIgPCAzNjApIHtcclxuICAgICAgICAgICAgSCArPSAxODA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhYnNEZWx0YWggPiAxODAgJiYgaDEgKyBoMiA+PSAzNjApIHtcclxuICAgICAgICAgICAgSCAtPSAxODA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBUID0gMSAtIDAuMTcgKiBNYXRoLmNvcygoSCAtIDMwKSAqIGRlZzJyYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgKyAwLjI0ICogTWF0aC5jb3MoKDIgKiBIKSAqIGRlZzJyYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgKyAwLjMyICogTWF0aC5jb3MoKDMgKiBIICsgNikgKiBkZWcycmFkKVxyXG4gICAgICAgICAgICAgICAgICAgIC0gMC4yMCAqIE1hdGguY29zKCg0ICogSCAtIDYzKSAqIGRlZzJyYWQpO1xyXG5cclxuICAgICAgICBjb25zdCBTTCA9IDEgKyAoSzIgKiAobWlkTCAtIDUwKSkgLyAoTWF0aC5zcXJ0KDIwICsgKG1pZEwgLSA1MCkgKiAobWlkTCAtIDUwKSkpO1xyXG4gICAgICAgIGNvbnN0IFNDID0gMSArIEsxICogbWlkQ3Q7XHJcbiAgICAgICAgY29uc3QgU0ggPSAxICsgSzIgKiBtaWRDdCAqIFQ7XHJcbiAgICAgICAgY29uc3QgUlQgPSAtIDIgKiBtaWRDN1Jvb3QgKiBNYXRoLnNpbigoNjAgKiBNYXRoLmV4cCgtICgoSCAtIDI3NSkgLyAyNSkgKiAoKEggLSAyNzUpIC8gMjUpKSkgKiBkZWcycmFkKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguc3FydCgoZGVsdGFMIC8gKGtMICogU0wpKSAqKiAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoZGVsdGFDdCAvIChrQyAqIFNDKSkgKiogMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgKGRlbHRhSCAvIChrSCAqIFNIKSkgKiogMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgUlQgKiAoZGVsdGFDdCAvIChrQyAqIFNDKSkgKiAoZGVsdGFIIC8gKGtIICogU0gpKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIHRvIGE9Yj0wIGluIHRoZSBBQi1zdWJzcGFjZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc3RhbmNlVG9HcmF5KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgY29weSBvZiBjb2xvciB2YWx1ZXMgaW4gYXJyYXkgZm9ybWF0IGFzIFtsLCBhLCBiXS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQXJyYXkoKTogbnVtYmVyW10ge1xyXG4gICAgICAgIC8vIGNvcHlcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMubWFwKCh2KSA9PiB2KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXNmb3JtcyBjb2xvciB0byB0aGUgWFlaIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvWFlaKCk6IFhZWkNvbG9yIHtcclxuICAgICAgICBsZXQgeSA9ICh0aGlzLmwgKiAxMDAgKyAxNikgLyAxMTY7XHJcbiAgICAgICAgbGV0IHggPSB0aGlzLmEgLyA1ICsgeTtcclxuICAgICAgICBsZXQgeiA9IHkgLSB0aGlzLmIgLyAyO1xyXG5cclxuICAgICAgICBbeCwgeSwgel0gPSBbeCwgeSwgel0ubWFwKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHYzID0gdiAqIHYgKiB2O1xyXG4gICAgICAgICAgICByZXR1cm4gKHYzID4gMC4wMDg4NTY0NTEpID8gdjMgOiAodiAtIDE2IC8gMTE2KSAvIDcuNzg3MDM3O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFhZWkNvbG9yKHggKiBYWVpDb2xvci5ENjUueCwgeSAqIFhZWkNvbG9yLkQ2NS55LCB6ICogWFlaQ29sb3IuRDY1LnopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhc2Zvcm1zIGNvbG9yIHRvIHRoZSBSR0IgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9SR0IoKTogUkdCQ29sb3Ige1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvWFlaKCkudG9SR0IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXNmb3JtcyBjb2xvciB0byB0aGUgc1JHQiBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1NSR0IoKTogU1JHQkNvbG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1hZWigpLnRvUkdCKCkudG9TUkdCKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgTEFCQ29sb3IsIElMYWJDb2xvclBvaW50IH0gZnJvbSBcIi4vTEFCQ29sb3JcIjtcclxuaW1wb3J0IHsgU1JHQkNvbG9yIH0gZnJvbSBcIi4vU1JHQkNvbG9yXCI7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcIi4vQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBQYWxldHRlIHNldHRpbmdzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJUGFsZXR0ZVNldHRpbmdzIHtcclxuICAgIGxpZ2h0bmVzczogbnVtYmVyO1xyXG4gICAgbGlnaHRuZXNzVmFyaWF0aW9uOiBudW1iZXI7XHJcbiAgICBtaW5HcmF5bmVzczogbnVtYmVyO1xyXG4gICAgbWF4R3JheW5lc3M6IG51bWJlcjtcclxuICAgIGdyYW51bGFyaXR5OiBudW1iZXI7XHJcbiAgICBhYlJhbmdlOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYFBhbGV0dGVgIGNsYXNzIHRvIGdlbmVyYXRlIGEgcGFsZXR0ZSB3aXRoIHNwZWNpZmllZCBzZXR0aW5nc1xyXG4gKiBhbmQgZXh0cmFjdCBhIHN1YnNldCBhcyBjb2xvciBzd2F0Y2hlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQYWxldHRlIHtcclxuICAgIHByaXZhdGUgZ2FtdXRDbHVzdGVyOiBDb2xvcltdO1xyXG5cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVDbHVzdGVyUHJvbWlzZTogUHJvbWlzZTxDb2xvcltdPjtcclxuXHJcbiAgICBwcml2YXRlIHNldHRpbmdzOiBJUGFsZXR0ZVNldHRpbmdzO1xyXG5cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHBhbGV0dGUgd2l0aCBwcm92aWRlZCBzZXR0aW5ncyAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJUGFsZXR0ZVNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgbGlnaHRuZXNzOiAoc2V0dGluZ3MubGlnaHRuZXNzID09PSB1bmRlZmluZWQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgMC42NSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHNldHRpbmdzLmxpZ2h0bmVzcykpLFxyXG4gICAgICAgICAgICBsaWdodG5lc3NWYXJpYXRpb246IChzZXR0aW5ncy5saWdodG5lc3NWYXJpYXRpb24gPT09IHVuZGVmaW5lZCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc2V0dGluZ3MubGlnaHRuZXNzVmFyaWF0aW9uKSksXHJcbiAgICAgICAgICAgIG1pbkdyYXluZXNzOiAoc2V0dGluZ3MubWluR3JheW5lc3MgPT09IHVuZGVmaW5lZCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc2V0dGluZ3MubWluR3JheW5lc3MpKSxcclxuICAgICAgICAgICAgbWF4R3JheW5lc3M6IChzZXR0aW5ncy5tYXhHcmF5bmVzcyA9PT0gdW5kZWZpbmVkKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDIgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyLCBzZXR0aW5ncy5tYXhHcmF5bmVzcykpLFxyXG4gICAgICAgICAgICBncmFudWxhcml0eTogKHNldHRpbmdzLmdyYW51bGFyaXR5ID09PSB1bmRlZmluZWQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgNTAgOiBNYXRoLm1heCgxMCwgc2V0dGluZ3MuZ3JhbnVsYXJpdHkpLFxyXG4gICAgICAgICAgICBhYlJhbmdlOiAoc2V0dGluZ3MuYWJSYW5nZSA9PT0gdW5kZWZpbmVkKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEuMyA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIsIHNldHRpbmdzLmFiUmFuZ2UpKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmdlbmVyYXRlQ2x1c3RlclByb21pc2UgPSB0aGlzLmdlbmVyYXRlR2FtdXRDbHVzdGVyQXN5bmMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdpdGggR2FtdXQgcG9pbnRzIHJlc29sdmVkIHdoZW4gYWxsIHBvaW50cyBhcmUgY2FsY3VsYXRlZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdhbXV0KCk6IFByb21pc2U8Q29sb3JbXT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmdhbXV0Q2x1c3RlciAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZ2FtdXRDbHVzdGVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZSh0aGlzLmdhbXV0Q2x1c3RlcikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ2x1c3RlclByb21pc2UudGhlbigoY2x1c3RlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW11dENsdXN0ZXIgPSBjbHVzdGVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzZXQgb2Ygc3dhdGNoZXMgd2l0aGluIHRoZSBwYWxldHRlJ3MgZ2FtdXQuXHJcbiAgICAgKiBAcGFyYW0gY29sb3JzQ291bnQgLSBUaGUgbnVtYmVyIG9mIGNvbG9ycyB0byBiZSBnZW5lcmF0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzd2F0Y2hlcyhjb2xvcnNDb3VudDogbnVtYmVyKTogUHJvbWlzZTxDb2xvcltdPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FtdXQoKS50aGVuKChjbHVzdGVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN3YXRjaGVzID0gbmV3IEFycmF5PENvbG9yPigpO1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGNsdXN0ZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgc3dhdGNoZXMucHVzaChjbHVzdGVyW2ZpcnN0XSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9yc0NvdW50IC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzd2F0Y2hlcy5wdXNoKHRoaXMuZmluZE5leHRDb2xvcihzd2F0Y2hlcywgY2x1c3RlcikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3dhdGNoZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmRzIHByb3ZpZGVkIHNldCBvZiBzd2F0Y2hlcyB3aXRoaW4gdGhlIHBhbGV0dGUncyBnYW11dC5cclxuICAgICAqIEBwYXJhbSBzd2F0Y2hlcyAtIFRoZSBvcmlnaW5hbCBzZXQgb2Ygc3dhdGNoZXMuXHJcbiAgICAgKiBAcGFyYW0gY29sb3JzQ291bnQgLSBUaGUgbnVtYmVyIG9mIG5ldyBjb2xvcnMgdG8gYmUgZ2VuZXJhdGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXN5bmMgbW9yZShzd2F0Y2hlczogQ29sb3JbXSwgY29sb3JzQ291bnQ6IG51bWJlcik6IFByb21pc2U8Q29sb3JbXT4ge1xyXG4gICAgICAgIGlmIChzd2F0Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdhbXV0KCkudGhlbigoY2x1c3RlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3dhdGNoZXMgPSBuZXcgQXJyYXk8Q29sb3I+KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxTd2F0Y2hlcyA9IHN3YXRjaGVzLm1hcCgoc3cpID0+IHN3KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sb3JzQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN3YXRjaCA9IHRoaXMuZmluZE5leHRDb2xvcihhbGxTd2F0Y2hlcywgY2x1c3Rlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU3dhdGNoZXMucHVzaChzd2F0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N3YXRjaGVzLnB1c2goc3dhdGNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTd2F0Y2hlcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3dhdGNoZXMoY29sb3JzQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGl2ZWx5IGdlbmVyYXRlcyBuZXcgc3dhdGNoZXMgd2l0aGluIHRoZSBwYWxldHRlJ3MgZ2FtdXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyogc3dhdGNoSXRlcmF0b3IoKTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPENvbG9yPiB7XHJcbiAgICAgICAgY29uc3QgZ2FtdXQgPSBhd2FpdCB0aGlzLmdhbXV0KCk7XHJcbiAgICAgICAgY29uc3QgZmlyc3RJbmRleDogbnVtYmVyID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogZ2FtdXQubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBmaXJzdENvbG9yOiBDb2xvciA9IGdhbXV0W2ZpcnN0SW5kZXhdO1xyXG5cclxuICAgICAgICB5aWVsZCBmaXJzdENvbG9yO1xyXG5cclxuICAgICAgICBjb25zdCBzd2F0Y2hlczogQ29sb3JbXSA9IFtmaXJzdENvbG9yXTtcclxuICAgICAgICBsZXQgbGFzdENvbG9yID0gZmlyc3RDb2xvcjtcclxuICAgICAgICBsZXQgZGlzdGFuY2UgPSAxLjA7XHJcbiAgICAgICAgd2hpbGUgKChkaXN0YW5jZSkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDb2xvciA9IHRoaXMuZmluZE5leHRDb2xvcihzd2F0Y2hlcywgZ2FtdXQpO1xyXG4gICAgICAgICAgICBzd2F0Y2hlcy5wdXNoKG5leHRDb2xvcik7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlID0gbmV4dENvbG9yLkxBQi5kaXN0YW5jZVRvXzAwKGxhc3RDb2xvci5MQUIpO1xyXG4gICAgICAgICAgICBsYXN0Q29sb3IgPSBuZXh0Q29sb3I7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIG5leHRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBuZXh0IGNvbG9yIHRvIGV4cGFuZCB0aGUgc3dhdGNoZXMgc2V0IHdpdGhpbiB0aGUgcGFsZXR0ZSdzIGdhbXV0LlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgd2l0aCBtYXhpbXVtIGRpc3RhbmNlIHRvIGFsbCB0aGUgY29sb3JzIGluIHN3YXRjaGVzLlxyXG4gICAgICogQHBhcmFtIHN3YXRjaGVzIC0gVGhlIG9yaWdpbmFsIHNldCBvZiBzd2F0Y2hlcy5cclxuICAgICAqIEBwYXJhbSBjbHVzdGVyIC0gVGhlIGNsdXN0ZXIgdG8gbG9vayB3aXRoLWluLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmROZXh0Q29sb3Ioc3dhdGNoZXM6IENvbG9yW10sIGNsdXN0ZXI6IENvbG9yW10pOiBDb2xvciB7XHJcbiAgICAgICAgbGV0IGNhbmRpZGF0ZTogQ29sb3IgPSBjbHVzdGVyWzBdO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZVNROiBudW1iZXIgPSAwO1xyXG5cclxuICAgICAgICBjbHVzdGVyLmZvckVhY2goKGNvbG9yUG9pbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VzID0gc3dhdGNoZXMubWFwKChzd2F0Y2hQb2ludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yUG9pbnQuTEFCLmRpc3RhbmNlVG9fMDAoc3dhdGNoUG9pbnQuTEFCKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbkRpc3RhbmNlU1EgPSBNYXRoLm1pbiguLi5kaXN0YW5jZXMpO1xyXG4gICAgICAgICAgICBpZiAobWluRGlzdGFuY2VTUSA+IG1heERpc3RhbmNlU1EpIHtcclxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNvbG9yUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZVNRID0gbWluRGlzdGFuY2VTUTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JhcHMgdGhlIGBnZW5lcmF0ZUdhbXV0Q2x1c3RlcmAgbWV0aG9kIGludG8gYSBQcm9taXNlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlR2FtdXRDbHVzdGVyQXN5bmMoKTogUHJvbWlzZTxDb2xvcltdPiB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPENvbG9yW10+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtdXRDbHVzdGVyID0gdGhpcy5nZW5lcmF0ZUdhbXV0Q2x1c3RlcigpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuZ2FtdXRDbHVzdGVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIGdhbXV0IGNsdXN0ZXIgb2YgcGFpcmVkIGNvbG9ycyBpbiBDSUVMQUIgKExBQikgYW5kIFJHQixcclxuICAgICAqIGZpbHRlcmVkIGJ5IGNvbG9yIHBvaW50cyB2YWxpZCBpbiBSR0Igc3BhY2UgYW5kIGdyYXluZXNzIGNvbnN0cmFpbnNcclxuICAgICAqICh3aXRoaW5nIHRoZSByYW5nZSBvZiBbYG1pbkdyYWluZXNzYCwgYG1heEdyYXluZXNzYF0pLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGF1Z21lbnRzIHRoZSBgZ2VuZXJhdGVQb2ludHNDbHVzdGVyYCBtZXRob2Qgd2l0aCBsaWdodG5lc3Mgc2V0dGluZ3MsXHJcbiAgICAgKiBwdXR0aW5nIGxpZ2h0bmVzcyBlcXVhbCB0byBhIHJhbmRvbSB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlXHJcbiAgICAgKiBbYGxpZ2h0bmVzc2AgLSBgbGlnaHRuZXNzVmFyaWF0aW9uYC8yLCBgbGlnaHRuZXNzYCArIGBsaWdodG5lc3NWYXJpYXRpb25gLzJdLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlR2FtdXRDbHVzdGVyKCk6IENvbG9yW10ge1xyXG4gICAgICAgIGxldCBjbHVzdGVyID0gdGhpcy5nZW5lcmF0ZVBvaW50c0NsdXN0ZXIodGhpcy5zZXR0aW5ncy5ncmFudWxhcml0eSk7XHJcbiAgICAgICAgY2x1c3RlciA9IGNsdXN0ZXIuZmlsdGVyKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpc3RhbmNlVG9HcmF5KHApO1xyXG4gICAgICAgICAgICByZXR1cm4gZCA+PSB0aGlzLnNldHRpbmdzLm1pbkdyYXluZXNzICYmIGQgPD0gdGhpcy5zZXR0aW5ncy5tYXhHcmF5bmVzcztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY29sb3JTcGFjZSA9IG5ldyBBcnJheTxDb2xvcj4oKTtcclxuXHJcbiAgICAgICAgY2x1c3Rlci5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBsaWdodG5lc3MgPSB0aGlzLnNldHRpbmdzLmxpZ2h0bmVzcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubGlnaHRuZXNzVmFyaWF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGlnaHRuZXNzICs9IHRoaXMuc2V0dGluZ3MubGlnaHRuZXNzVmFyaWF0aW9uICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xyXG4gICAgICAgICAgICAgICAgbGlnaHRuZXNzID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbGlnaHRuZXNzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmNvbG9yID0gbmV3IExBQkNvbG9yKGxpZ2h0bmVzcywgcC5hLCBwLmIpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihsYWJjb2xvcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sb3Iuc1JHQi5pc1ZhbGlkQ29sb3IoKSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3JTcGFjZS5wdXNoKGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb2xvclNwYWNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gY29sb3IgcG9pbnQgdG8gYSB6ZXJvLXBvaW50IChgYSA9IGIgPSAwYCkuXHJcbiAgICAgKiBAcGFyYW0gcCAtIE9yaWdpbiBwb2ludC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkaXN0YW5jZVRvR3JheShwOiBJTGFiQ29sb3JQb2ludCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQocC5hICogcC5hICsgcC5iICogcC5iKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgZ3JpZCBvZiBjb2xvciBwb2ludHMgaW4gQUItc3Vic3BhY2UsIGNlbnRlcmVkIGF0IGBhID0gYiA9IDBgIGFuZFxyXG4gICAgICogdGhlIGdyaWQgc2l6ZSBbLWBhYlJhZ2VgLCArYGFiUmFuZ2VgXSBpbiBlYWNoIGRpbWVuc2lvbi5cclxuICAgICAqIEBwYXJhbSBncmFudWxhcml0eSAtIE51bWJlciBvZiBncmlkIHN0ZXBzIGluIGVhY2ggZGltZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlUG9pbnRzQ2x1c3RlcihncmFudWxhcml0eTogbnVtYmVyKTogSUxhYkNvbG9yUG9pbnRbXSB7XHJcbiAgICAgICAgZ3JhbnVsYXJpdHkgPSBNYXRoLnJvdW5kKGdyYW51bGFyaXR5KTtcclxuICAgICAgICBjb25zdCBjbHVzdGVyID0gbmV3IEFycmF5PElMYWJDb2xvclBvaW50PihncmFudWxhcml0eSAqIGdyYW51bGFyaXR5KTtcclxuXHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLnNldHRpbmdzLmFiUmFuZ2U7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhbnVsYXJpdHk7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyYW51bGFyaXR5OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXJbaSAqIGdyYW51bGFyaXR5ICsgal0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYTogcmFuZ2UgKiAyICogaSAvIChncmFudWxhcml0eSAtIDEpIC0gcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYjogcmFuZ2UgKiAyICogaiAvIChncmFudWxhcml0eSAtIDEpIC0gcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2x1c3RlcjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBYWVpDb2xvciB9IGZyb20gXCIuL1hZWkNvbG9yXCI7XHJcbmltcG9ydCB7IExBQkNvbG9yIH0gZnJvbSBcIi4vTEFCQ29sb3JcIjtcclxuaW1wb3J0IHsgU1JHQkNvbG9yIH0gZnJvbSBcIi4vU1JHQkNvbG9yXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgUkdCIGNvbG9yIHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJHQkNvbG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlZC1jb21wb25lbnQgb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JlZW4tY29tcG9uZW50IG9mIHRoZSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBnKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJsdWUtY29tcG9uZW50IG9mIHRoZSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBiKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzWzJdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgY29sb3IgY29tcG9uZW50cyBhcyBbciwgZywgYl0uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdmFsdWVzOiBudW1iZXJbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IFJHQkNvbG9yXHJcbiAgICAgKiBAcGFyYW0gciAtIFJlZCBjb21wb25lbnQgaW4gdGhlIHJhbmdlIFswLCAxXS5cclxuICAgICAqIEBwYXJhbSBnIC0gR3JlZW4gY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwgMV0uXHJcbiAgICAgKiBAcGFyYW0gYiAtIEJsdWUgY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwgMV0uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnZhbHVlcyA9IFtyLCBnLCBiXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgY29sb3IgdmFsdWVzIGluIGFycmF5IGZvcm1hdCBhcyBbciwgZywgYl0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0FycmF5KCk6IG51bWJlcltdIHtcclxuICAgICAgICAvLyBjb3B5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLm1hcCgodikgPT4gdik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFzZm9ybXMgY29sb3IgdG8gdGhlIFhZWiBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1hZWigpOiBYWVpDb2xvciB7XHJcbiAgICAgICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy52YWx1ZXM7XHJcbiAgICAgICAgY29uc3QgeCA9IDAuNDEyNCAqIHIgKyAwLjM1NzYgKiBnICsgMC4xODA1ICogYjtcclxuICAgICAgICBjb25zdCB5ID0gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xyXG4gICAgICAgIGNvbnN0IHogPSAwLjAxOTMgKiByICsgMC4xMTkyICogZyArIDAuOTUwNSAqIGI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBYWVpDb2xvcih4LCB5LCB6KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXNmb3JtcyBjb2xvciB0byB0aGUgc1JHQiB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1NSR0IoKTogU1JHQkNvbG9yIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlcy5tYXAoKHYpID0+IHtcclxuICAgICAgICAgICAgaWYgKHYgPCAwLjAwMzEzMDgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxMi45MiAqIHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMS4wNTUgKiBNYXRoLnBvdyh2LCAxIC8gMi40KSAtIDAuMDU1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgU1JHQkNvbG9yKHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhc2Zvcm1zIGNvbG9yIHRvIHRoZSBDSUUgTEFCIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvTEFCKCk6IExBQkNvbG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1hZWigpLnRvTEFCKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSFNMQ29sb3IgfSBmcm9tIFwiLi9IU0xDb2xvclwiO1xyXG5pbXBvcnQgeyBYWVpDb2xvciB9IGZyb20gXCIuL1hZWkNvbG9yXCI7XHJcbmltcG9ydCB7IExBQkNvbG9yIH0gZnJvbSBcIi4vTEFCQ29sb3JcIjtcclxuaW1wb3J0IHsgUkdCQ29sb3IgfSBmcm9tIFwiLi9SR0JDb2xvclwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHNSR0IgY29sb3Igc3BhY2UuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU1JHQkNvbG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBoZXgtc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSR0IgY29sb3IuXHJcbiAgICAgKiBAcGFyYW0gaGV4IC0gQ29sb3Igc3RyaW5nIGluIHRoZSBmb3JtYXQgXCIjUkdCXCIgKCNSR0JBKSBvciBcIiNSUkdHQkJcIiAoI1JSR0dCQkFBKS5cclxuICAgICAqIEByZW1hcmtzIEFscGhhIHZhbHVlIChpZiBwcmVzZW50KSBpcyBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBhcnNlSGV4KGhleDogc3RyaW5nKTogU1JHQkNvbG9yIHtcclxuICAgICAgICBjb25zdCBpc1ZhbGlkQ29sb3IgPSAvIyhbYS1mMC05XXszLDR9KXsxLDJ9XFxiL2kudGVzdChoZXgpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZENvbG9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDU1MgUkdCIGNvbG9yOiAke2hleH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IGc6IG51bWJlcjtcclxuICAgICAgICBsZXQgYjogbnVtYmVyO1xyXG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA3IHx8IGhleC5sZW5ndGggPT09IDkpIHtcclxuICAgICAgICAgICAgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMSwgMyksIDE2KSAvIDI1NTtcclxuICAgICAgICAgICAgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMywgNSksIDE2KSAvIDI1NTtcclxuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNSwgNyksIDE2KSAvIDI1NTtcclxuICAgICAgICB9IGVsc2UgaWYgKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNSkge1xyXG4gICAgICAgICAgICByID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgxKSwgMTYpIC8gMTY7XHJcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChoZXguY2hhckF0KDIpLCAxNikgLyAxNjtcclxuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGhleC5jaGFyQXQoMyksIDE2KSAvIDE2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBTUkdCQ29sb3IociwgZywgYik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVkLWNvbXBvbmVudCBvZiB0aGUgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcigpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1swXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBncmVlbi1jb21wb25lbnQgb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGcoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmx1ZS1jb21wb25lbnQgb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBjb2xvciBjb21wb25lbnRzIGFzIFtyLCBnLCBiXS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWx1ZXM6IG51bWJlcltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgUkdCQ29sb3JcclxuICAgICAqIEBwYXJhbSByIC0gUmVkIGNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICogQHBhcmFtIGcgLSBHcmVlbiBjb21wb25lbnQgaW4gdGhlIHJhbmdlIFswLCAxXS5cclxuICAgICAqIEBwYXJhbSBiIC0gQmx1ZSBjb21wb25lbnQgaW4gdGhlIHJhbmdlIFswLCAxXS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gW3IsIGcsIGJdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb2xvciB2YWx1ZXMgYXJlIGluIHRoZSByYW5nZSBbMCwgMV0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc1ZhbGlkQ29sb3IoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnIgPj0gMCkgJiYgKHRoaXMuciA8PSAxKSAmJlxyXG4gICAgICAgICAgICAgICAodGhpcy5nID49IDApICYmICh0aGlzLmcgPD0gMSkgJiZcclxuICAgICAgICAgICAgICAgKHRoaXMuYiA+PSAwKSAmJiAodGhpcy5iIDw9IDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1bmNhdGVzIHRoZSBjb2xvciB2YWx1ZXMgdG8gdGhlIHJhbmdlIFswLCAxXS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRydW5jYXRlKCk6IFNSR0JDb2xvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTUkdCQ29sb3IoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgdGhpcy5yKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB0aGlzLmcpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHRoaXMuYikpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgY29sb3IgdmFsdWVzIGluIGFycmF5IGZvcm1hdCBhcyBbciwgZywgYl0uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0FycmF5KCk6IG51bWJlcltdIHtcclxuICAgICAgICAvLyBjb3B5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLm1hcCgodikgPT4gdik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wb3NlcyB0aGUgQ1NTIGNvbG9yIHN0cmluZyB1c2luZyB0aGUgcmdiKCkgb3IgcmdiYSgpIGZvcm1hdC5cclxuICAgICAqIEBwYXJhbSBhbHBoYSAtIFRoZSBhbHBoYSB2YWx1ZSBmb3IgcmdiYSgpIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvQ1NTU3RyaW5nKGFscGhhPzogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvMjU1KCk7XHJcbiAgICAgICAgaWYgKGFscGhhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gY2FzdCB0byBbMCwgMV1cclxuICAgICAgICAgICAgYWxwaGEgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBhbHBoYSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthbHBoYX0pYDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYHJnYigke3J9LCAke2d9LCAke2J9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcG9zZXMgdGhlIENTUyBjb2xvciBzdHJpbmcgdXNpbmcgdGhlIFwiI1JSR0dCQlwiIG9yIFwiI1JSR0dCQkFBXCIgZm9ybWF0LlxyXG4gICAgICogQHBhcmFtIGFscGhhIC0gVGhlIGFscGhhIHZhbHVlIGZvciB0aGUgI1JSR0dCQkFBIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvSGV4KGFscGhhPzogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBbciwgZywgYl0gPSB0aGlzLnRvRkYoKTtcclxuICAgICAgICBpZiAoYWxwaGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBjYXN0IHRvIFswLCAxXVxyXG4gICAgICAgICAgICBhbHBoYSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGFscGhhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFscGhhRkYgPSBNYXRoLnJvdW5kKGFscGhhICogMjU1KS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIHJldHVybiBgIyR7cn0ke2d9JHtifSR7YWxwaGFGRn1gO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgIyR7cn0ke2d9JHtifWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhc2Zvcm1zIGNvbG9yIHRvIHRoZSBIU0wgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9IU0woKTogSFNMQ29sb3Ige1xyXG4gICAgICAgIGNvbnN0IFtyLCBnLCBiXSA9IHRoaXMudmFsdWVzO1xyXG4gICAgICAgIGNvbnN0IG1heDogbnVtYmVyID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICAgICAgY29uc3QgbWluOiBudW1iZXIgPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgICAgICBsZXQgaDogbnVtYmVyO1xyXG4gICAgICAgIGxldCBzOiBudW1iZXI7XHJcbiAgICAgICAgY29uc3QgbDogbnVtYmVyID0gKG1heCArIG1pbikgLyAyO1xyXG5cclxuICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcclxuICAgICAgICAgIGggPSAwO1xyXG4gICAgICAgICAgcyA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgcyA9IChsID4gMC41KSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGggPSAoYiAtIHIpIC8gZCArIDI7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoIC89IDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSFNMQ29sb3IoaCwgcywgbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFzZm9ybXMgY29sb3IgdG8gdGhlIFhZWiBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1hZWigpOiBYWVpDb2xvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKS50b1hZWigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBzUkdCLWNvbG9yIHZhbHVlcyBpbnRvIGxpbmVhciBSR0IgZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1JHQigpOiBSR0JDb2xvciB7XHJcbiAgICAgICAgY29uc3QgW3IsIGcsIGJdID0gdGhpcy52YWx1ZXMubWFwKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2IDwgMC4wNDA0NSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgLyAxMi45MjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKHYgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSR0JDb2xvcihyLCBnLCBiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXNmb3JtcyBjb2xvciB0byB0aGUgQ0lFIExBQiBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0xBQigpOiBMQUJDb2xvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKS50b1hZWigpLnRvTEFCKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gbWFwIGNvbG9yIHZhbHVlcyBpbnRvIFswLCAyNTVdIHJhbmdlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRvMjU1KCk6IG51bWJlcltdIHtcclxuICAgICAgICBjb25zdCByZ2IgPSB0aGlzLnRydW5jYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJnYi52YWx1ZXMubWFwKCh2KSA9PiBNYXRoLnJvdW5kKDI1NSAqIHYpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBtYXAgY29sb3IgdmFsdWVzIGludG8gaGV4LWZvcm1hdCBcIkZGXCIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG9GRigpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gdGhpcy50cnVuY2F0ZSgpO1xyXG4gICAgICAgIHJldHVybiByZ2IudmFsdWVzLm1hcCgodikgPT4gTWF0aC5yb3VuZCgyNTUgKiB2KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSR0JDb2xvciB9IGZyb20gXCIuL1JHQkNvbG9yXCI7XHJcbmltcG9ydCB7IFNSR0JDb2xvciB9IGZyb20gXCIuL1NSR0JDb2xvclwiO1xyXG5pbXBvcnQgeyBMQUJDb2xvciB9IGZyb20gXCIuL0xBQkNvbG9yXCI7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgQ0lFIFhZWiBjb2xvciBzcGFjZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBYWVpDb2xvciB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBENjUgd2hpdGUgcG9pbnQgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEQ2NSA9IG5ldyBYWVpDb2xvcigwLjk1MDQ3LCAxLjAwMCwgMS4wODg4Myk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRDUwIHdoaXRlIHBvaW50IHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBENTAgPSBuZXcgWFlaQ29sb3IoMC45NjY3OTcsIDEuMDAwLCAwLjgyNTE4OCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgeC1jb21wb25lbnQgb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgeS1jb21wb25lbnQgb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHkoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgei1jb21wb25lbnQgb2YgdGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHooKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMl07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBjb2xvciBjb21wb25lbnRzIGFzIFt4LCB5LCB6XS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWx1ZXM6IG51bWJlcltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgWFlaIGNvbG9yLlxyXG4gICAgICogQHBhcmFtIHggLSB4LWNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICogQHBhcmFtIHkgLSB5LWNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICogQHBhcmFtIHogLSB6LWNvbXBvbmVudCBpbiB0aGUgcmFuZ2UgWzAsIDFdLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbeCwgeSwgel07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBjb3B5IG9mIGNvbG9yIHZhbHVlcyBpbiBhcnJheSBmb3JtYXQgYXMgW3gsIHksIHpdLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9BcnJheSgpOiBudW1iZXJbXSB7XHJcbiAgICAgICAgLy8gY29weVxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5tYXAoKHYpID0+IHYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhc2Zvcm1zIGNvbG9yIHRvIHRoZSBSR0IgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9SR0IoKTogUkdCQ29sb3Ige1xyXG4gICAgICAgIGNvbnN0IFt4LCB5LCB6XSA9IHRoaXMudmFsdWVzO1xyXG4gICAgICAgIGNvbnN0IHIgPSArMy4yNDA2MjU1ICogeCAtIDEuNTM3MjA4MCAqIHkgLSAwLjQ5ODYyODYgKiB6O1xyXG4gICAgICAgIGNvbnN0IGcgPSAtMC45Njg5MzA3ICogeCArIDEuODc1NzU2MSAqIHkgKyAwLjA0MTUxNzUgKiB6O1xyXG4gICAgICAgIGNvbnN0IGIgPSArMC4wNTU3MTAxICogeCAtIDAuMjA0MDIxMSAqIHkgKyAxLjA1Njk5NTkgKiB6O1xyXG4gICAgICAgIHJldHVybiBuZXcgUkdCQ29sb3IociwgZywgYik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFzZm9ybXMgY29sb3IgdG8gdGhlIHNSR0IgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9TUkdCKCk6IFNSR0JDb2xvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9SR0IoKS50b1NSR0IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXNmb3JtcyBjb2xvciB0byB0aGUgQ0lFIExBQiBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0xBQigpOiBMQUJDb2xvciB7XHJcbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCAvIFhZWkNvbG9yLkQ2NS54O1xyXG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnkgLyBYWVpDb2xvci5ENjUueTtcclxuICAgICAgICBjb25zdCB6ID0gdGhpcy56IC8gWFlaQ29sb3IuRDY1Lno7XHJcblxyXG4gICAgICAgIGNvbnN0IHh5eiA9IFt4LCB5LCB6XS5tYXAoKHYpID0+IHtcclxuICAgICAgICAgICAgaWYgKHYgPiAwLjAwODg1NjQ1MSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgKiogKDEgLyAzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA3Ljc4NzAzNyAqIHYgKyAxNiAvIDExNjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IExBQkNvbG9yKCgxMTYgKiB4eXpbMV0gLSAxNikgLyAxMDAsIDUgKiAoeHl6WzBdIC0geHl6WzFdKSwgMiAqICh4eXpbMV0gLSB4eXpbMl0pKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJQm91bmRhYmxlIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JQm91bmRhYmxlXCI7XHJcbmltcG9ydCB7IElNb3ZhYmxlIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JTW92YWJsZVwiO1xyXG5pbXBvcnQgeyBJUG9pbnQyRCB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVBvaW50MkRcIjtcclxuaW1wb3J0IHsgSVJlY3R9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVJlY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgMmQgcG9pbnQgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9pbnQyRCBpbXBsZW1lbnRzIElNb3ZhYmxlLCBJQm91bmRhYmxlPFBvaW50MkQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwb2ludCBiYXNlZCBvbiBleHRyYWN0aW5nIHNwZWNpZmljIHByb3BlcnRpZXMgZnJvbSBhbnkgcHJvdmlkZWQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEFuIGBJUG9pbnRgIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIG51bWVyaWMgcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMgQSBuZXcgYFBvaW50MkRgIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEJ1aWxkRnJvbUpTT04oZGF0YTogSVBvaW50MkQpOiBQb2ludDJEIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50MkQoZGF0YS54LCBkYXRhLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYHhgLWNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB4OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBgeWAtY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFBvaW50MkRgIG9iamVjdCBmcm9tIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0geCAtIGB4YC1jb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4gICAgICogQHBhcmFtIHkgLSBgeWAtY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeDogbnVtYmVyLCB5OiBudW1iZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvaW50MkQgb2JqZWN0IGZyb20gb3RoZXIgYElQb2ludDJEYCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBwIC0gYW4gb2JqZWN0IGltcGxlbWVudGluZyBgSVBvaW50MkRgLCB3aGljaCBsb2NhdGlvbiB3aWxsIGJlIGNvcGllZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwOiBJUG9pbnQyRCk7XHJcbiAgICBjb25zdHJ1Y3RvcihhcmcxOiBhbnksIGFyZzI/OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGFyZzIgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gYXJnMTtcclxuICAgICAgICAgICAgdGhpcy55ID0gYXJnMjtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZzEueCAhPT0gdW5kZWZpbmVkICYmIGFyZzEueSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IGFyZzEueDtcclxuICAgICAgICAgICAgdGhpcy55ID0gYXJnMS55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHBvaW50IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb25cclxuICAgICAqIEBwYXJhbSB4IC0gdGhlIG5ldyBgeGAtY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHkgLSBhIG5ldyBgeWAtY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHBvaW50IHRvIHRoZSBsb2NhdGlvbiBvZiBzcGVjaWZpZWQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBhbiBvYmplY3QgaW1wbGVtZW50aW5nIGBJUG9pbnQyRGAsIHdoaWNoIGxvY2F0aW9uIHdpbGwgYmUgdXNlZCBhcyByZWZlcmVuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1vdmUocG9pbnQ6IElQb2ludDJEKTogdm9pZDtcclxuICAgIHB1YmxpYyBtb3ZlKGFyZzE6IGFueSwgYXJnMj86IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYXJnMiA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICB0aGlzLnggPSBhcmcxO1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhcmcyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMS54ICE9PSB1bmRlZmluZWQgJiYgYXJnMS55ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gYXJnMS54O1xyXG4gICAgICAgICAgICB0aGlzLnkgPSBhcmcxLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hpZnRzIHBvaW50IGxvY2F0aW9uIHRvIHNwZWNpZmllZCBkZWx0YVxyXG4gICAgICogQHBhcmFtIGR4IC0gRGVsdGEgdG8gYmUgYWRkZWQgdG8gdGhlIGB4YC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gZHkgLSBEZWx0YSB0byBiZSBhZGRlZCB0byB0aGUgYHlgLWNvb3JkaW5hdGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNoaWZ0KGR4OiBudW1iZXIsIGR5OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnggKz0gZHg7XHJcbiAgICAgICAgdGhpcy55ICs9IGR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCBjcmVhdGVkIGZyb20gYm91bmRpbmcgdGhpcyBvbmUgdG8gdGhlIGBSZWN0YCBvYmplY3Qgcm92aWRlZFxyXG4gICAgICogQHJlbWFya3MgVGhpcyBtZXRob2QgYm91bmRzIHRoZSBwb2ludCB0byB0aGUgcmVjdCB3aXRoIGNvb3JkaW5hdGVzIGBbMCwgMF0geCBbci53aWR0aCwgci5oZWlnaHRdYC5cclxuICAgICAqIEBwYXJhbSByIC0gQSBib3VuZGluZyBib3hcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBQb2ludDJEYCBvYmplY3QsIHdpdGggY29vcmRpbmF0ZXMgYm91bmRlZCB0byB0aGUgYm94XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBib3VuZFRvUmVjdChyOiBJUmVjdCk6IFBvaW50MkQge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQyRCgodGhpcy54IDwgMCkgPyAwIDogKCh0aGlzLnggPiByLndpZHRoKSA/IHIud2lkdGggOiB0aGlzLngpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy55IDwgMCkgPyAwIDogKCh0aGlzLnkgPiByLmhlaWdodCkgPyByLmhlaWdodCA6IHRoaXMueSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICAgICAqIEBwYXJhbSBwIC0gU2Vjb25kIHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3F1YXJlRGlzdGFuY2VUb1BvaW50KHA6IFBvaW50MkQpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAodGhpcy54IC0gcC54KSAqICh0aGlzLnggLSBwLngpICsgKHRoaXMueSAtIHAueSkgKiAodGhpcy55IC0gcC55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGEgbGluZSBzZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gcDEgLSBUaGUgZmlyc3QgbGluZSBzZWdtZW50IHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcDIgLSBUaGUgc2Vjb25kIGxpbmUgc2VnbWVudCBwb2ludFxyXG4gICAgICogQHJldHVybnMgVGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNxdWFyZURpc3RhbmNlVG9MaW5lKHAxOiBQb2ludDJELCBwMjogUG9pbnQyRCk6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aDI6IG51bWJlciA9IHAxLnNxdWFyZURpc3RhbmNlVG9Qb2ludChwMik7XHJcbiAgICAgICAgbGV0IGRpc3Q6IG51bWJlcjtcclxuXHJcbiAgICAgICAgaWYgKGxpbmVMZW5ndGgyID09PSAwLjApIHtcclxuICAgICAgICAgICAgZGlzdCA9IHRoaXMuc3F1YXJlRGlzdGFuY2VUb1BvaW50KHAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gKCh0aGlzLnggLSBwMS54KSAqIChwMi54IC0gcDEueCkgKyAodGhpcy55IC0gcDEueSkgKiAocDIueSAtIHAxLnkpKSAvIGxpbmVMZW5ndGgyO1xyXG4gICAgICAgICAgICBjb25zdCBrID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQb2ludDJEKHAxLnggKyBrICogKHAyLnggLSBwMS54KSwgcDEueSArIGsgKiAocDIueSAtIHAxLnkpKTtcclxuICAgICAgICAgICAgZGlzdCA9IHRoaXMuc3F1YXJlRGlzdGFuY2VUb1BvaW50KHApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgcG9pbnRcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBQb2ludDJEYCBvYmplY3Qgd2l0aCBjb3BpZWQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvcHkoKTogUG9pbnQyRCB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludDJEKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IGluIHRoZSBmb3JtYXQgYFwie3gsIHl9XCJgLlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBgeyR7dGhpcy54LnRvU3RyaW5nKCl9LCAke3RoaXMueS50b1N0cmluZygpfX1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyBBbiBgSVBvaW50YCBvYmplY3Qgd2l0aCBgeGAgYW5kIGB5YCBudW1lcmljIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0pTT04oKTogSVBvaW50MkQge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICAgICAgeTogdGhpcy55LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSVJlY3QgfSBmcm9tIFwiLi4vSW50ZXJmYWNlL0lSZWN0XCI7XHJcbmltcG9ydCB7IElSZXNpemFibGUgfSBmcm9tIFwiLi4vSW50ZXJmYWNlL0lSZXNpemFibGVcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdCBvYmplY3RcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWN0IGltcGxlbWVudHMgSVJlc2l6YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVjdCBiYXNlZCBvbiBleHRyYWN0aW5nIHNwZWNpZmljIHByb3BlcnRpZXMgZnJvbSBhbnkgcHJvdmlkZWQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIEFuIGBJUmVjdGAgb2JqZWN0IHdpdGggYHdpZHRoYCBhbmQgYGhlaWdodGAgbnVtZXJpYyBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgUmVjdGAgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQnVpbGRGcm9tSlNPTihkYXRhOiBJUmVjdCk6IFJlY3Qge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdChkYXRhLndpZHRoLCBkYXRhLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBgd2lkdGhgIG9mIHRoZSByZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB3aWR0aDogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgaGVpZ2h0YCBvZiB0aGUgcmVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBSZWN0YCBvYmplY3Qgd2l0aCBzcGVjaWZpZWQgYHdpZHRoYCBhbmQgYGhlaWdodGBcclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIGB3aWR0aGAgb2YgdGhlIG5ldyByZWN0XHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gYGhlaWdodGAgb2YgdGhlIG5ldyByZWN0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGlzIHJlY3QgdG8gc3BlY2lmaWVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBhIG5ldyBgd2lkdGhgIGZvciB0aGUgcmVjdFxyXG4gICAgICogQHBhcmFtIGhlaWdodCAtIGEgbmV3IGBoZWlnaHRgIGZvciB0aGUgcmVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHdpZHRoID49IDAgJiYgaGVpZ2h0ID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHJlY3RcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBSZWN0YCBvYmplY3Qgd2l0aCBjb3BpZWQgZGltZW5zaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY29weSgpOiBSZWN0IHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVjdCBpbiB0aGUgZm9ybWF0IGBcIlt3aWR0aCwgaGVpZ2h0XVwiYC5cclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBgWyR7dGhpcy53aWR0aC50b1N0cmluZygpfSwgJHt0aGlzLmhlaWdodC50b1N0cmluZygpfV1gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlY3RcclxuICAgICAqIEByZXR1cm5zIEFuIGBJUmVjdGAgb2JqZWN0IHdpdGggYHdpZHRoYCBhbmQgYGhlaWdodGAgbnVtZXJpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9KU09OKCk6IElSZWN0IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IElNb3ZhYmxlIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JTW92YWJsZVwiO1xyXG5pbXBvcnQgeyBJUmVnaW9uRGF0YSB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVJlZ2lvbkRhdGFcIjtcclxuaW1wb3J0IHsgSVJlc2l6YWJsZSB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVJlc2l6YWJsZVwiO1xyXG5pbXBvcnQgeyBJUmVjdCB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVJlY3RcIjtcclxuaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuL1JlY3RcIjtcclxuaW1wb3J0IHsgSVBvaW50MkQgfSBmcm9tIFwiLi4vSW50ZXJmYWNlL0lQb2ludDJEXCI7XHJcblxyXG4vKipcclxuICogRGVmaW5lcyBzdXBwb3J0ZWQgcmVnaW9uIHR5cGVzLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gUmVnaW9uRGF0YVR5cGUge1BvaW50ID0gXCJwb2ludFwiLCBSZWN0ID0gXCJyZWN0XCIsIFBvbHlsaW5lID0gXCJwb2x5bGluZVwiLCBQb2x5Z29uID0gXCJwb2x5Z29uXCJ9XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyByZWdpb24gbWV0YS1kYXRhLCBpbmNsdWRpbmcgcG9zaXRpb24sIHNpemUsIHBvaW50cyBhbmQgdHlwZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlZ2lvbkRhdGEgaW1wbGVtZW50cyBJUmVnaW9uRGF0YSwgSU1vdmFibGUsIElSZXNpemFibGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBSZWdpb25EYXRhYCBvYmplY3Qgd2l0aCBgcG9pbnRgLXR5cGUgYXQgcHJvdmlkZWQgYHhgLCBgeWAgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB4IC0gYHhgLWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5IC0gYHlgLWNvb3JkaW5hdGVcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBSZWdpb25EYXRhYCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBCdWlsZFBvaW50UmVnaW9uRGF0YSh4OiBudW1iZXIsIHk6IG51bWJlcik6IFJlZ2lvbkRhdGEge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVnaW9uRGF0YSh4LCB5LCAwLCAwLCBbbmV3IFBvaW50MkQoeCwgeSldLCBSZWdpb25EYXRhVHlwZS5Qb2ludCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBSZWdpb25EYXRhYCBvYmplY3Qgd2l0aCBgcmVjdGAtdHlwZSBhdCBwcm92aWRlZCBgeGAsIGB5YFxyXG4gICAgICogY29vcmRpbmF0ZXMgYW5kIG9mIHByb3ZpZGVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgXHJcbiAgICAgKiBAcGFyYW0geCAtIGB4YC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geSAtIGB5YC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBgd2lkdGhgIG9mIHRoZSByZWN0XHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gYGhlaWdodGAgb2YgdGhlIHJlY3RcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBSZWdpb25EYXRhYCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBCdWlsZFJlY3RSZWdpb25EYXRhKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFJlZ2lvbkRhdGEge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVnaW9uRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgICAgICBbbmV3IFBvaW50MkQoeCwgeSksIG5ldyBQb2ludDJEKHggKyB3aWR0aCwgeSksXHJcbiAgICAgICAgICAgICBuZXcgUG9pbnQyRCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpLCBuZXcgUG9pbnQyRCh4LCB5ICsgaGVpZ2h0KV0sIFJlZ2lvbkRhdGFUeXBlLlJlY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgUmVnaW9uRGF0YWAgb2JqZWN0IGJhc2VkIG9uIGV4dHJhY3Rpbmcgc3BlY2lmaWMgcHJvcGVydGllcyBmcm9tIGFueSBwcm92aWRlZCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gQW4gYElSZWdpb25EYXRhYCBvYmplY3Qgd2l0aCBgeGAsIGB5YCwgYHdpZHRoYCwgYGhlaWdodGAsIGBwb2ludHNgIGFuZCBgdHlwZWAgcHJvcGVydGllc1xyXG4gICAgICogQHJldHVybnMgQSBuZXcgYFJlZ2lvbkRhdGFgIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEJ1aWxkRnJvbUpzb24oZGF0YTogSVJlZ2lvbkRhdGEpOiBSZWdpb25EYXRhIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZ2lvbkRhdGEoZGF0YS54LCBkYXRhLnksIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnBvaW50cy5tYXAoKHApID0+IG5ldyBQb2ludDJEKHAueCwgcC55KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBgeGAtY29vcmRpbmF0ZSBvZiB0aGUgcmVnaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcm5lci54O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYHhgLWNvb3JkaW5hdGUgb2YgdGhlIHJlZ2lvbi4gKlJlZ2lvbiBwb2ludHMgcG9zaXRpb24gd2lsbCBiZSByZWNhbGN1bGF0ZWQqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgeCh4OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLm1vdmUoeCwgdGhpcy55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGB5YC1jb29yZGluYXRlIG9mIHRoZSByZWdpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB5KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBgeWAtY29vcmRpbmF0ZSBvZiB0aGUgcmVnaW9uLiAqUmVnaW9uIHBvaW50cyBwb3NpdGlvbiB3aWxsIGJlIHJlY2FsY3VsYXRlZCpcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCB5KHk6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMubW92ZSh0aGlzLngsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYHdpZHRoYCBvZiB0aGUgcmVnaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgd2lkdGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25SZWN0LndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYHdpZHRoYCBvZiB0aGUgcmVnaW9uLiAqUmVnaW9uIHBvaW50cyBwb3NpdGlvbiB3aWxsIGJlIHJlY2FsY3VsYXRlZCpcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCB3aWR0aCh3aWR0aDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGBoZWlnaHRgIG9mIHRoZSByZWdpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBoZWlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25SZWN0LmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGBoZWlnaHRgIG9mIHRoZSByZWdpb24uICpSZWdpb24gcG9pbnRzIHBvc2l0aW9uIHdpbGwgYmUgcmVjYWxjdWxhdGVkKlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IGhlaWdodChoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHRoZSByZWdpb24uICpQb2ludCBoYXMgYXJlYSA9IDEuMCwgZm9yIG90aGVyIHR5cGVzIGl0IGlzIGB3aWR0aCAqIGhlaWdodGAqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYXJlYSgpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBhcmVhOiBudW1iZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lvblR5cGUgPT09IFJlZ2lvbkRhdGFUeXBlLlBvaW50KSB7XHJcbiAgICAgICAgICAgIGFyZWEgPSAxLjA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXJlYSA9IHRoaXMucmVnaW9uUmVjdC53aWR0aCAqIHRoaXMucmVnaW9uUmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmVhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYm91bmRpbmcgYm94IHNpemUgb2YgdGhlIHJlZ2lvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvdW5kUmVjdCgpOiBSZWN0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25SZWN0LmNvcHkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJvdW5kaW5nIGJveCBzaXplIG9mIHRoZSByZWdpb24uICpSZWdpb24gd2lsbCBiZSByZXNpemVkIGF1dG9tYXRpY2FsbHkqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgYm91bmRSZWN0KHJlY3Q6IFJlY3QpIHtcclxuICAgICAgICB0aGlzLnJlc2l6ZShyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhcnJheSBvZiByZWdpb24gcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHBvaW50cygpOiBQb2ludDJEW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lvblBvaW50cy5tYXAoKHApID0+IHAuY29weSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFycmF5IG9mIHJlZ2lvbiBwb2ludHMuICpSZWdpb24gd2lsbCBiZSByZXNpemVkIGFuZCByZXBvc2l0aW9uZWQgYXV0b21hdGljYWxseSpcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBwb2ludHMocG9pbnRzOiBQb2ludDJEW10pIHtcclxuICAgICAgICB0aGlzLnNldFBvaW50cyhwb2ludHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdHlwZSBvZiB0aGUgcmVnaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdHlwZSgpOiBSZWdpb25EYXRhVHlwZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9uVHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29ybmVyOiBQb2ludDJEO1xyXG4gICAgcHJvdGVjdGVkIHJlZ2lvblJlY3Q6IFJlY3Q7XHJcbiAgICBwcm90ZWN0ZWQgcmVnaW9uUG9pbnRzOiBQb2ludDJEW107XHJcbiAgICBwcm90ZWN0ZWQgcmVnaW9uVHlwZTogUmVnaW9uRGF0YVR5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBSZWdpb25EYXRhYCBvYmplY3RcclxuICAgICAqIEBwYXJhbSB4IC0gYHhgLWNvb3JkaW5hdGUgb2YgdGhlIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIHkgLSBgeWAtY29vcmRpbmF0ZSBvZiB0aGUgcmVnaW9uXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBgd2lkdGhgIG9mIHRoZSByZWdpb25cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBgaGVpZ2h0YCBvZiB0aGUgcmVnaW9uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIC0gQ29sbGVjdGlvbiBvZiBpbnRlcm5hbCByZWdpb24gcG9pbnRzXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAtIGB0eXBlYCBvZiB0aGUgcmVnaW9uIGZyb20gZW51bSBgUmVnaW9uRGF0YVR5cGVgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgcG9pbnRzPzogUG9pbnQyRFtdLCB0eXBlPzogUmVnaW9uRGF0YVR5cGUpIHtcclxuICAgICAgICB0aGlzLmNvcm5lciA9IG5ldyBQb2ludDJEKHgsIHkpO1xyXG4gICAgICAgIHRoaXMucmVnaW9uUmVjdCA9IG5ldyBSZWN0KHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvblBvaW50cyA9IChwb2ludHMgIT09IHVuZGVmaW5lZCAmJiBwb2ludHMgIT09IG51bGwpID8gcG9pbnRzIDogbmV3IEFycmF5PFBvaW50MkQ+KCk7XHJcbiAgICAgICAgdGhpcy5yZWdpb25UeXBlID0gKHR5cGUgIT09IHVuZGVmaW5lZCkgPyB0eXBlIDogUmVnaW9uRGF0YVR5cGUuUG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgcmVnaW9uIHRvIHRoZSBwb3NpdGlvbiBvZiBhbiBgSVBvaW50MkRgIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHBvaW50IC0gYElQb2ludDJEYCBvYmplY3QgdG8gdXNlIGFzIHBvc2l0aW9uIHNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZShwb2ludDogSVBvaW50MkQpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgcmVnaW9uIHRvIHNwZWNpZmllZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHggLSBOZXcgYHhgLWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB5IC0gTmV3IGB5YC1jb29yZGluYXRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtb3ZlKHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZDtcclxuICAgIHB1YmxpYyBtb3ZlKGFyZzE6IGFueSwgYXJnMj86IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG9sZHggPSB0aGlzLng7XHJcbiAgICAgICAgY29uc3Qgb2xkeSA9IHRoaXMueTtcclxuICAgICAgICB0aGlzLmNvcm5lci5tb3ZlKGFyZzEsIGFyZzIpO1xyXG5cclxuICAgICAgICBjb25zdCBkeCA9IHRoaXMueCAtIG9sZHg7XHJcbiAgICAgICAgY29uc3QgZHkgPSB0aGlzLnkgLSBvbGR5O1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvblBvaW50cy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHAuc2hpZnQoZHgsIGR5KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgcmVnaW9ucyB0byBzcGVjaWZpZWQgZGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHdpZHRoIC0gTmV3IGB3aWR0aGAgb2YgdGhlIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIGhlaWdodCAtIE5ldyBgaGVpZ2h0YCBvZiB0aGUgcmVnaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCBzeCA9IHdpZHRoIC8gdGhpcy53aWR0aDtcclxuICAgICAgICBjb25zdCBzeSA9IGhlaWdodCAvIHRoaXMuaGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvblJlY3QucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvblBvaW50cy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB4ID0gKHAueCAtIHRoaXMueCkgKiBzeCArIHRoaXMueDtcclxuICAgICAgICAgICAgY29uc3QgcHkgPSAocC55IC0gdGhpcy55KSAqIHN5ICsgdGhpcy55O1xyXG4gICAgICAgICAgICBwLm1vdmUocHgsIHB5KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGBwb2ludGAgYXQgc3BlY2lmaWVkIGBpbmRleGBcclxuICAgICAqIEBwYXJhbSBwb2ludCAtIE5ldyBgcG9pbnRgIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBgaW5kZXhgIG9mIHRoZSBwb2ludCBpbiBpbnRlcm5hbCBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb2ludChwb2ludDogSVBvaW50MkQsIGluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMucmVnaW9uUG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lvblBvaW50c1tpbmRleF0gPSBuZXcgUG9pbnQyRChwb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgcmVnaW9uIHBvc2l0aW9uIGFuZCBzaXplXHJcbiAgICAgICAgbGV0IHhtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCB4bWF4ID0gMDtcclxuICAgICAgICBsZXQgeW1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IHltYXggPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvblBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocG9pbnQueCA+IHhtYXgpIHtcclxuICAgICAgICAgICAgICAgIHhtYXggPSBwb2ludC54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgeG1pbikge1xyXG4gICAgICAgICAgICAgICAgeG1pbiA9IHBvaW50Lng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50LnkgPiB5bWF4KSB7XHJcbiAgICAgICAgICAgICAgICB5bWF4ID0gcG9pbnQueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnQueSA8IHltaW4pIHtcclxuICAgICAgICAgICAgICAgIHltaW4gPSBwb2ludC55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29ybmVyLm1vdmUoeG1pbiwgeW1pbik7XHJcbiAgICAgICAgdGhpcy5yZWdpb25SZWN0LnJlc2l6ZSh4bWF4IC0geG1pbiwgeW1heCAtIHltaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgY29sbGVjdGlvbiBvZiBpbnRlcm5hbCBwb2ludHNcclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBgSVBvaW50MkRbXWAgY29sbGVjdGlvbiBmb3IgdGhlIHJlZ2lvbiB0byBzZXJ2ZSBhcyB0aGUgc291cmNlIGZvciB0aGVcclxuICAgICAqIGludGVybmFsICpjb3B5KiBpbiB0aGUgYHBvaW50c2AgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UG9pbnRzKHBvaW50czogSVBvaW50MkRbXSkge1xyXG4gICAgICAgIGxldCB4bWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgeG1heCA9IDA7XHJcbiAgICAgICAgbGV0IHltaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCB5bWF4ID0gMDtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHJlZ2lvbiBwb3NpdGlvbiBhbmQgc2l6ZVxyXG4gICAgICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocG9pbnQueCA+IHhtYXgpIHtcclxuICAgICAgICAgICAgICAgIHhtYXggPSBwb2ludC54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgeG1pbikge1xyXG4gICAgICAgICAgICAgICAgeG1pbiA9IHBvaW50Lng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50LnkgPiB5bWF4KSB7XHJcbiAgICAgICAgICAgICAgICB5bWF4ID0gcG9pbnQueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnQueSA8IHltaW4pIHtcclxuICAgICAgICAgICAgICAgIHltaW4gPSBwb2ludC55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVnaW9uUG9pbnRzID0gcG9pbnRzLm1hcCgocCkgPT4gbmV3IFBvaW50MkQocCkpO1xyXG4gICAgICAgIHRoaXMuY29ybmVyLm1vdmUoeG1pbiwgeW1pbik7XHJcbiAgICAgICAgdGhpcy5yZWdpb25SZWN0LnJlc2l6ZSh4bWF4IC0geG1pbiwgeW1heCAtIHltaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdHMgdGhpcyByZWdpb24gcHJvcGVydGllcyBmcm9tIGFub3RoZXIgYElSZWdpb25EYXRhYCBvYmplY3RcclxuICAgICAqIEBwYXJhbSByZWdpb25EYXRhIC0gQW4gYElSZWdpb25EYXRhYCBvYmplY3QgdG8gc2VydmUgYXMgdGhlIHNvdXJjZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdEZyb20ocmVnaW9uRGF0YTogSVJlZ2lvbkRhdGEpIHtcclxuICAgICAgICB0aGlzLmNvcm5lciA9IG5ldyBQb2ludDJEKHJlZ2lvbkRhdGEueCwgcmVnaW9uRGF0YS55KTtcclxuICAgICAgICB0aGlzLnJlZ2lvblJlY3QgPSBuZXcgUmVjdChyZWdpb25EYXRhLndpZHRoLCByZWdpb25EYXRhLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5yZWdpb25Qb2ludHMgPSByZWdpb25EYXRhLnBvaW50cy5tYXAoKHApID0+IG5ldyBQb2ludDJEKHAueCwgcC55KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGBSZWdpb25EYXRhYCBvYmplY3Qgd2l0aCBhbGwgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMgYm91bmRlZCB0byBzcGVjaWZpZWQgYm94XHJcbiAgICAgKiBAcGFyYW0gcmVjdCAtIFRoZSBgSVJlY3RgIGJveCwgd2hpY2ggYHdpZHRoYCBhbmQgYGhlaWdodGAgd2lsbCBiZSB1c2VkIGZvciBib3VuZGluZ1xyXG4gICAgICogQHJldHVybnMgQSBuZXcgYFJlZ2lvbkRhdGFgIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYm91bmRUb1JlY3QocmVjdDogSVJlY3QpOiBSZWdpb25EYXRhIHtcclxuICAgICAgICBjb25zdCBickNvcm5lciA9IChuZXcgUG9pbnQyRCh0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCkpLmJvdW5kVG9SZWN0KHJlY3QpO1xyXG4gICAgICAgIGNvbnN0IHRsQ29ybmVyID0gdGhpcy5jb3JuZXIuYm91bmRUb1JlY3QocmVjdCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gYnJDb3JuZXIueCAtIHRsQ29ybmVyLng7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gYnJDb3JuZXIueSAtIHRsQ29ybmVyLnk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUmVnaW9uRGF0YSh0bENvcm5lci54LCB0bENvcm5lci55LCB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lvblBvaW50cy5tYXAoKHApID0+IHAuYm91bmRUb1JlY3QocmVjdCkpLCB0aGlzLnJlZ2lvblR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGUgcmVnaW9uIGNvb3JkaW5hdGVzLCBwb2ludHMgYW5kIHNpemUgYnkgYHhmYWN0b3JgIGFuZCBgeWZhY3RvcmBcclxuICAgICAqIEBwYXJhbSB4ZmFjdG9yIC0gSG9yaXpvbnRhbCBzY2FsaW5nIGZhY3RvclxyXG4gICAgICogQHBhcmFtIHlmYWN0b3IgLSBWZXJ0aWNhbCBzY2FsaW5nIGZhY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoeGZhY3RvcjogbnVtYmVyLCB5ZmFjdG9yOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZSByZWdpb24gY29vcmRpbmF0ZXMsIHBvaW50cyBhbmQgc2l6ZSBieSBgZmFjdG9yYFxyXG4gICAgICogQHBhcmFtIGZhY3RvciAtIEhvcml6b250YWwgJiB2ZXJ0aWNhbCBzY2FsaW5nIGZhY3RvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NhbGUoZmFjdG9yOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgcHVibGljIHNjYWxlKGYxOiBudW1iZXIsIGYyPzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgeGYgPSBmMTtcclxuICAgICAgICBjb25zdCB5ZiA9IChmMiAhPT0gdW5kZWZpbmVkKSA/IGYyIDogZjE7XHJcblxyXG4gICAgICAgIHRoaXMuY29ybmVyID0gbmV3IFBvaW50MkQodGhpcy54ICogeGYsIHRoaXMueSAqIHlmKTtcclxuICAgICAgICB0aGlzLnJlZ2lvblJlY3QgPSBuZXcgUmVjdCh0aGlzLndpZHRoICogeGYsIHRoaXMuaGVpZ2h0ICogeWYpO1xyXG4gICAgICAgIHRoaXMucmVnaW9uUG9pbnRzID0gIHRoaXMucmVnaW9uUG9pbnRzLm1hcCgocCkgPT4gbmV3IFBvaW50MkQocC54ICogeGYsIHAueSAqIHlmKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHJlZ2lvbiBkYXRhXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgUmVnaW9uRGF0YWAgb2JqZWN0IHdpdGggY29waWVkIHByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvcHkoKTogUmVnaW9uRGF0YSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdpb25EYXRhKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25Qb2ludHMubWFwKChwKSA9PiBwLmNvcHkoKSksIHRoaXMucmVnaW9uVHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWdpb24gaW4gdGhlIGZvcm1hdFxyXG4gICAgICogYFwie3gsIHl9IHggW3dpZHRoLCBoZWlnaHRdOiB7e3gxLCB5MX0sIC4uLiwge3huLCB5bn19XCJgLlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29ybmVyLnRvU3RyaW5nKCl9IHggJHt0aGlzLmJvdW5kUmVjdC50b1N0cmluZygpfTogeyR7dGhpcy5yZWdpb25Qb2ludHMudG9TdHJpbmcoKX19YDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWdpb25cclxuICAgICAqIEByZXR1cm5zIEFuIGBJUmVnaW9uRGF0YWAgb2JqZWN0IHdpdGggcHJvcGVydGllcyBvbmx5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9KU09OKCk6IElSZWdpb25EYXRhIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMueSxcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5yZWdpb25Qb2ludHMubWFwKChwb2ludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogcG9pbnQueCwgeTogcG9pbnQueSB9O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdHlwZTogdGhpcy5yZWdpb25UeXBlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSVRhZyB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVRhZ1wiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuLi9Db3JlL0NvbG9ycy9Db2xvclwiO1xyXG5pbXBvcnQgeyBIU0xDb2xvciB9IGZyb20gXCIuL0NvbG9ycy9IU0xDb2xvclwiO1xyXG5pbXBvcnQgeyBMQUJDb2xvciB9IGZyb20gXCIuL0NvbG9ycy9MQUJDb2xvclwiO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgbWV0YS1kYXRhIGZvciBhIHRhZ1xyXG4gKiBAcmVtYXJrc1xyXG4gKiAxLiBUbyByZXByZXNlbnQgdGhlIGNvbG9yIFRhZyBjbGFzcyB1c2VzIG9ubHkgdGhlIGh1ZSBjb21wb25lbnRcclxuICogYW5kIGdlbmVyYXRlcyBhIG51bWJlciBvZiBjb2xvciB2YXJpYXRpb25zIGJhc2VkIG9uIHRoYXQgdmFsdWUuXHJcbiAqIDIuIFRoZSBgVGFnYCBvYmplY3QgaXMgKmltbXV0YWJsZSosIGFsbCBwdWJsaWMgcHJvcGVydGllcyBhcmUgcmVhZG9ubHkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGFnIGltcGxlbWVudHMgSVRhZyB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGFnIGJhc2VkIG9uIGV4dHJhY3Rpbmcgc3BlY2lmaWMgcHJvcGVydGllcyBmcm9tIGFueSBwcm92aWRlZCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gQW4gYElUYWdgIG9iamVjdCB3aXRoIGBuYW1lYCwgYGNvbG9ySHVlYCBhbmQgYGlkYCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGFnYCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBCdWlsZEZyb21KU09OKGRhdGE6IElUYWcpOiBUYWcge1xyXG4gICAgICAgIGlmIChkYXRhLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWcoZGF0YS5uYW1lLCBuZXcgQ29sb3IoZGF0YS5jb2xvciksIChkYXRhLmlkID09PSB1bmRlZmluZWQpID8gXCJcIiA6IGRhdGEuaWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb2xvckh1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFnKGRhdGEubmFtZSwgbmV3IENvbG9yKG5ldyBIU0xDb2xvcigoZGF0YS5jb2xvckh1ZSAlIDM2MCkgLyAzNjAuMCwgMSwgMC41KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhLmlkID09PSB1bmRlZmluZWQpID8gXCJcIiA6IGRhdGEuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHRoZSBodWUgY29tcG9uZW50IGZyb20gYSBwcm92aWRlZCBDU1MgY29sb3Igc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgLSBBIENTUy1jb2xvciBpbiBcIiNSUkdHQkJcIiBvciBcIiNSR0JcIiBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgaHVlIHZhbHVlIGZvciBwcm92aWRlZCBjb2xvclxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBDb2xvciBjbGFzcyBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEh1ZUZyb21Db2xvcihjb2xvcjogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCBjID0gbmV3IENvbG9yKGNvbG9yKTtcclxuICAgICAgICByZXR1cm4gYy5IU0wuaCAqIDM2MDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRhZ05hbWU6IHN0cmluZztcclxuICAgIHByaXZhdGUgdGFnSUQ6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBodWUtdmFsdWUgb2YgdGhlIHRhZydzIGNvbG9yLiAqUmVhZG9ubHkqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29sb3JIdWUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvck9iai5IU0wuaCAqIDM2MDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0YWcncyBjb2xvciBpbiBoZXggZm9ybWF0LiAqUmVhZG9ubHkqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29sb3IoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvck9iai5zUkdCLnRvSGV4KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYG5hbWVgIG9mIHRoZSB0YWcuICpSZWFkb25seSpcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgaWRgIG9mIHRoZSB0YWcuICpSZWFkb25seSpcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0lEO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdGFnQ29sb3JQdXJlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHJpdmF0ZSB0YWdDb2xvckFjY2VudDogc3RyaW5nID0gXCJcIjtcclxuICAgIHByaXZhdGUgdGFnQ29sb3JIaWdobGlnaHQ6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwcml2YXRlIHRhZ0NvbG9yU2hhZG93OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHJpdmF0ZSB0YWdDb2xvck5vQ29sb3I6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwcml2YXRlIHRhZ0NvbG9yRGFyazogc3RyaW5nID0gXCJcIjtcclxuXHJcbiAgICBwcml2YXRlIGNvbG9yT2JqOiBDb2xvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHB1cmUgY29sb3IgdmFyaWF0aW9uIG9mIHRoZSB0YWcncyBjb2xvclxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIGhzbChILCAxMDAlLCA1MCUpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29sb3JQdXJlKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMudGFnQ29sb3JQdXJlID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnQ29sb3JQdXJlID0gdGhpcy5jb2xvck9iai5zUkdCLnRvSGV4KCk7XHJcbiAgICAgICAgICAgIC8vIE9MRDogYGhzbCgke3RoaXMudGFnSHVlLnRvU3RyaW5nKCl9LCAxMDAlLCA1MCUpYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnQ29sb3JQdXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYWNjZW50IGNvbG9yIHZhcmlhdGlvbiBvZiB0aGUgdGFnJ3MgY29sb3IuXHJcbiAgICAgKiBBY2NlbnQgPSBhbG1vc3QgcHVyZSwgYWxwaGEgPSAwLjguXHJcbiAgICAgKiBAcmV0dXJucyBIZXggc3RyaW5nIGZvciB0aGUgY29sb3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjb2xvckFjY2VudCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0NvbG9yQWNjZW50ID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnQ29sb3JBY2NlbnQgPSB0aGlzLmNvbG9yT2JqLnNSR0IudG9IZXgoMC44KTtcclxuICAgICAgICAgICAgLy8gT0xEOiBgaHNsYSgke3RoaXMudGFnSHVlLnRvU3RyaW5nKCl9LCAxMDAlLCA1MCUsIDAuNSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50YWdDb2xvckFjY2VudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhpZ2hsaWdodCBjb2xvciB2YXJpYXRpb24gb2YgdGhlIHRhZydzIGNvbG9yLlxyXG4gICAgICogSGlnaGxpZ2h0ID0gZ3JheWVkIHB1cmUsIGFscGhhID0gMC40XHJcbiAgICAgKiBAcmV0dXJucyBIZXggc3RyaW5nIGZvciB0aGUgY29sb3JcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBjb2xvckhpZ2hsaWdodCgpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0NvbG9ySGlnaGxpZ2h0ID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYiA9IHRoaXMuY29sb3JPYmouTEFCLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgY29uc3QgaGlnaGxpZ2h0ID0gbmV3IExBQkNvbG9yKGxhYlswXSAqIDAuNywgbGFiWzFdICogMC43LCBsYWJbMl0gKiAwLjcpO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ0NvbG9ySGlnaGxpZ2h0ID0gaGlnaGxpZ2h0LnRvU1JHQigpLnRydW5jYXRlKCkudG9IZXgoMC40KTtcclxuICAgICAgICAgICAgLy8gT0xEOiBgaHNsYSgke3RoaXMudGFnSHVlLnRvU3RyaW5nKCl9LCA4MCUsIDQwJSwgMC4zKWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0NvbG9ySGlnaGxpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2hhZG93IGNvbG9yIHZhcmlhdGlvbiBvZiB0aGUgdGFnJ3MgY29sb3JcclxuICAgICAqIFNoYWRvdyA9IGdyYXllZCBwdXJlLCBhbHBoYSA9IDAuMlxyXG4gICAgICogQHJldHVybnMgSGV4IHN0cmluZyBmb3IgdGhlIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29sb3JTaGFkb3coKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodGhpcy50YWdDb2xvclNoYWRvdyA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBjb25zdCBsYWIgPSB0aGlzLmNvbG9yT2JqLkxBQi50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvdyA9IG5ldyBMQUJDb2xvcihsYWJbMF0gKiAwLjYsIGxhYlsxXSAqIDAuNiwgbGFiWzJdICogMC42KTtcclxuICAgICAgICAgICAgdGhpcy50YWdDb2xvclNoYWRvdyA9IHNoYWRvdy50b1NSR0IoKS50cnVuY2F0ZSgpLnRvSGV4KDAuMik7XHJcbiAgICAgICAgICAgIC8vIE9MRDogYGhzbGEoJHt0aGlzLnRhZ0h1ZS50b1N0cmluZygpfSwgNTAlLCAzMCUsIDAuMilgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50YWdDb2xvclNoYWRvdztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhcmsgY29sb3IgdmFyaWF0aW9uIG9mIHRoZSB0YWcncyBjb2xvci5cclxuICAgICAqIERhcmsgPSBwdXJlIHdpdGggZGVjcmVhc2VkIGxpZ2h0bmVzcyBhbmQgZ3JheWVkLlxyXG4gICAgICogQHJldHVybnMgSGV4IHN0cmluZyBmb3IgdGhlIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgY29sb3JEYXJrKCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMudGFnQ29sb3JEYXJrID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYiA9IHRoaXMuY29sb3JPYmouTEFCLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgY29uc3QgZGFyayA9IG5ldyBMQUJDb2xvcihsYWJbMF0gKiAwLjUsIGxhYlsxXSAqIDAuNSwgbGFiWzJdICogMC41KTtcclxuICAgICAgICAgICAgdGhpcy50YWdDb2xvckRhcmsgPSBkYXJrLnRvU1JHQigpLnRydW5jYXRlKCkudG9IZXgoMC44KTtcclxuICAgICAgICAgICAgLy8gT0xEOiBgaHNsYSgke3RoaXMudGFnSHVlLnRvU3RyaW5nKCl9LCA1MCUsIDMwJSwgMC44KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0NvbG9yRGFyaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZ1bGx5IHRyYW5zcGFyZW50IGNvbG9yIHZhcmlhdGlvbiBvZiB0aGUgdGFnJ3MgY29sb3JcclxuICAgICAqIEByZXR1cm5zIEhleCBzdHJpbmcgZm9yIHRoZSBjb2xvclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGNvbG9yTm9Db2xvcigpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0NvbG9yTm9Db2xvciA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICB0aGlzLnRhZ0NvbG9yTm9Db2xvciA9IGByZ2JhKDAsIDAsIDAsIDAuMClgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50YWdDb2xvck5vQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUYWdgIG9iamVjdCB3aXRoIHNwZWNpZmllZCBgbmFtZWAsIGBjb2xvckh1ZWAgYW5kIGBpZGBcclxuICAgICAqIEBwYXJhbSBuYW1lIC0gYG5hbWVgIG9mIHRoZSBuZXcgdGFnXHJcbiAgICAgKiBAcGFyYW0gY29sb3JIdWUgLSBgY29sb3JIdWVgIG9mIHRoZSBuZXcgdGFnXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBgaWRgIG9mIHRoZSBuZXcgdGFnIChvcHRpb25hbCwgYnkgZGVmYXVsdCBpcyBcIlwiKVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgQ29sb3JgIGNsYXNzIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgY29sb3JIdWU6IG51bWJlciwgaWQ/OiBzdHJpbmcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUYWdgIG9iamVjdCB3aXRoIHNwZWNpZmllZCBgbmFtZWAsIGh1ZSB2YWx1ZSBvZiBgY3NzQ29sb3JgIGFuZCBgaWRgXHJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIGBuYW1lYCBvZiB0aGUgbmV3IHRhZ1xyXG4gICAgICogQHBhcmFtIGNzc0NvbG9yIC0gQ1NTIGNvbG9yIChlLmcuICNGRjAzQTMpIGZvciB0aGUgbmV3IHRhZywgKm9ubHkgaHVlIHZhbHVlIG9mIHRoZSBjb2xvciB3aWxsIGJlIHVzZWQqXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBgaWRgIG9mIHRoZSBuZXcgdGFnIChvcHRpb25hbCwgYnkgZGVmYXVsdCBpcyBcIlwiKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIGNzc0NvbG9yOiBzdHJpbmcsIGlkPzogc3RyaW5nKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGFnYCBvYmplY3Qgd2l0aCBzcGVjaWZpZWQgYG5hbWVgLCBodWUgdmFsdWUgb2YgYGNzc0NvbG9yYCBhbmQgYGlkYFxyXG4gICAgICogQHBhcmFtIG5hbWUgLSBgbmFtZWAgb2YgdGhlIG5ldyB0YWdcclxuICAgICAqIEBwYXJhbSBjb2xvciAtIFRoZSBgQ29sb3JgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBpZCAtIGBpZGAgb2YgdGhlIG5ldyB0YWcgKG9wdGlvbmFsLCBieSBkZWZhdWx0IGlzIFwiXCIpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgY29sb3I6IENvbG9yLCBpZD86IHN0cmluZyk7XHJcblxyXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBjb2xvcjogbnVtYmVyfHN0cmluZ3xDb2xvciwgaWQ6IHN0cmluZyA9IFwiXCIpIHtcclxuICAgICAgICB0aGlzLnRhZ05hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JPYmogPSBuZXcgQ29sb3IobmV3IEhTTENvbG9yKChjb2xvciAlIDM2MCkgLyAzNjAuMCwgMSwgMC41KSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvck9iaiA9IG5ldyBDb2xvcihjb2xvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvciBpbnN0YW5jZW9mIENvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JPYmogPSBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50YWdJRCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB0YWdcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBUYWdgIG9iamVjdCB3aXRoIGNvcGllZCBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5KCk6IFRhZyB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUYWcodGhpcy50YWdOYW1lLCB0aGlzLmNvbG9yT2JqLCB0aGlzLnRhZ0lEKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0YWdcclxuICAgICAqIEByZXR1cm5zIEFuIGBJVGFnYCBvYmplY3Qgd2l0aCBgbmFtZWAsIGBjb2xvckh1ZWAgYW5kIGBpZGAgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdG9KU09OKCk6IElUYWcge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMudGFnTmFtZSxcclxuICAgICAgICAgICAgY29sb3JIdWU6IHRoaXMuY29sb3JIdWUsXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yT2JqLnNSR0IudG9IZXgoKSxcclxuICAgICAgICAgICAgaWQ6IHRoaXMudGFnSUQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUYWcgfSBmcm9tIFwiLi9UYWdcIjtcclxuaW1wb3J0IHsgSVRhZ3NEZXNjcmlwdG9yIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JVGFnc0Rlc2NyaXB0b3JcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY29tcG9zaXRpb24gb2YgcmVnaW9uIHRhZ3NcclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYWdzRGVzY3JpcHRvciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRhZ0Rlc2NyaXB0b3JgIG9iamVjdCBiYXNlZCBvbiBleHRyYWN0aW5nIHNwZWNpZmljIHByb3BlcnRpZXMgZnJvbSBhbnkgcHJvdmlkZWQgb2JqZWN0XHJcbiAgICAgKiBAcmVtYXJrcyBUaGUgYFRhZ0Rlc2NyaXB0b3JgIG9iamVjdCBpcyAqaW1tdXRhYmxlKi4gQWxsIHB1YmxpYyBwcm9wZXJ0aWVzIHJldHVybiBjb3BpZXMgb2Ygb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSBkYXRhIC0gQW4gYElUYWdEZXNjcmlwdG9yYCBvYmplY3Qgd2l0aCB0aGUgYHByaW1hcnlgIGFuZCBgc2Vjb25kYXJ5YFxyXG4gICAgICogcHJvcGVydGllcyBpbXBsZW1lbnRpbmcgYElUYWdgIGFuZCBgSVRhZ1tdYCBpbnRlcmZhY2VzXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBgVGFnRGVzY3JpcHRvcmAgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQnVpbGRGcm9tSlNPTihkYXRhOiBJVGFnc0Rlc2NyaXB0b3IpOiBUYWdzRGVzY3JpcHRvciB7XHJcbiAgICAgICAgbGV0IHAgPSBudWxsO1xyXG4gICAgICAgIGlmIChkYXRhLnByaW1hcnkgIT09IG51bGwgJiYgZGF0YS5wcmltYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcCA9IFRhZy5CdWlsZEZyb21KU09OKGRhdGEucHJpbWFyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHMgPSAoZGF0YS5zZWNvbmRhcnkgPT09IHVuZGVmaW5lZCkgPyBbXSA6IGRhdGEuc2Vjb25kYXJ5Lm1hcCgodGFnKSA9PiBUYWcuQnVpbGRGcm9tSlNPTih0YWcpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdzRGVzY3JpcHRvcihwLCBzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFsbFRhZ3M6IFRhZ1tdO1xyXG4gICAgcHJpdmF0ZSBwcmltYXJ5VGFnOiBUYWc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0YWdzIChubyBvcmRlciBndWFyYW50ZWVkKS4gKlJlYWRvbmx5KlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGFsbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hbGxUYWdzLm1hcCgodGFnKSA9PiB0YWcuY29weSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByaW1hcnkgdGFnLiAqUmVhZG9ubHkqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgcHJpbWFyeSgpOiBUYWcge1xyXG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlUYWcgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeVRhZy5jb3B5KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgc2Vjb25kYXJ5IHRhZ3MgKG5vIG9yZGVyIGd1YXJhbnRlZWQpLiAqUmVhZG9ubHkqXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgc2Vjb25kYXJ5KCk6IFRhZ1tdIHtcclxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5VGFnICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbC5maWx0ZXIoKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0YWcubmFtZSAhPT0gdGhpcy5wcmltYXJ5Lm5hbWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyAgZW1wdHlgVGFnRGVzY3JpcHRvcmAgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCk7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRhZ0Rlc2NyaXB0b3JgIG9iamVjdCB3aXRoIHNwZWNpZmllZCB0YWdzXHJcbiAgICAgKiBAcGFyYW0gdGFncyAtIEEgdGFncyBhcnJheSB3aXRoIHRoZSBgdGFnc1swXWAgdXNlZCBhcyBgcHJpbWFyeVRhZ2BcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFnczogVGFnW10pO1xyXG4gICAgY29uc3RydWN0b3IocHJpbWFyeVRhZzogVGFnLCBzZWNvbmRhcnlUYWdzOiBUYWdbXSk7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRhZ0Rlc2NyaXB0b3JgIG9iamVjdCB3aXRoIHNwZWNpZmllZCB0YWdzXHJcbiAgICAgKiBAcGFyYW0gcHJpbWFyeVRhZyAtIFByaW1hcnkgYFRhZ2AgZm9yIHRoZSBkZXNjcmlwdG9yXHJcbiAgICAgKiBAcGFyYW0gc2Vjb25kYXJ5VGFncyAtIEFuIGFycmF5IG9mIHNlY29uZGFyeSB0YWdzIChvcHRpb25hbClcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXJnMT86IFRhZ3xUYWdbXSwgYXJnMjogVGFnW10gPSBbXSkge1xyXG4gICAgICAgIC8vIGVtcHR5IFRhZ3NEZXNjcmlwdG9yXHJcbiAgICAgICAgaWYgKGFyZzEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlUYWcgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmFsbFRhZ3MgPSBbXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBUYWcpIHtcclxuICAgICAgICAgICAgLy8gYXJnMSA9IHByaW1hcnlUYWcsIGFyZzIgPSBzZWNvbmRhcnlUYWdcclxuICAgICAgICAgICAgaWYgKGFyZzIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxUYWdzID0gbmV3IEFycmF5PFRhZz4oYXJnMSwgLi4uYXJnMik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsbFRhZ3MgPSBbYXJnMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnID0gYXJnMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBhcmcxID0gdGFncywgaWdub3JlIGFyZzJcclxuICAgICAgICAgICAgdGhpcy5hbGxUYWdzID0gYXJnMS5tYXAoKHRhZykgPT4gdGFnLmNvcHkoKSk7XHJcbiAgICAgICAgICAgIGlmIChhcmcxLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZyA9IGFyZzFbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByaW1hcnlUYWcgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcmcxID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGFyZzEgPSBudWxsIHwgdW5kZWZpbmVkLCBpZ25vcmVcclxuICAgICAgICAgICAgaWYgKGFyZzIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxUYWdzID0gYXJnMi5tYXAoKHRhZykgPT4gdGFnLmNvcHkoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsbFRhZ3MgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlUYWcgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHRhZ3Mgd2l0aCBwcmltYXJ5IHRhZyBmaXJzdCAoaWYgcHJlc2VudClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeVRhZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5wcmltYXJ5VGFnLm5hbWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeS5mb3JFYWNoKCh0YWcpID0+IHtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIiwgXCIgKyB0YWcubmFtZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnkuZm9yRWFjaCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIsIFwiICsgdGFnLm5hbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDIsIHN0ci5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYElUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IHdpdGggYHByaW1hcnlgIGFuZCBgc2Vjb25kYXJ5YCBwcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b0pTT04oKTogSVRhZ3NEZXNjcmlwdG9yIHtcclxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5VGFnICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiB0aGlzLnByaW1hcnlUYWcudG9KU09OKCksXHJcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnk6IHRoaXMuc2Vjb25kYXJ5Lm1hcCgodGFnKSA9PiB0YWcudG9KU09OKCkpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwcmltYXJ5OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5OiB0aGlzLnNlY29uZGFyeS5tYXAoKHRhZykgPT4gdGFnLnRvSlNPTigpKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuaW1wb3J0IHsgUmVnaW9uQ29tcG9uZW50IH0gZnJvbSBcIi4uL1JlZ2lvbi9Db21wb25lbnQvUmVnaW9uQ29tcG9uZW50XCI7XHJcblxyXG4vKipcclxuICogRGVmaW5lcyBjYWxsYmFja3MgZm9yIHJlZ2lvbiBtYW5pcHVsYXRpb24gZXZlbnRzLlxyXG4gKiBAcmVtYXJrcyBVc2VkIHRvIHN5bmMgdGhlIGludGVybmFsIHN0YXRlIHdpdGggdGhlIGBBcmVhU2VsZWN0b3JgLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgUmVnaW9uTWFuaXB1bGF0aW9uRnVuY3Rpb24gPSAoVUlFbGVtZW50PzogUmVnaW9uQ29tcG9uZW50KSA9PiB2b2lkO1xyXG5cclxuLyoqXHJcbiAqIERlZmluZXMgc3VwcG9ydGVkIGV2ZW50cyB0eXBlcyBmb3IgcmVnaW9ucy5cclxuICovXHJcbmV4cG9ydCBlbnVtIENoYW5nZUV2ZW50VHlwZSB7IE1PVkVFTkQsIE1PVklORywgTU9WRUJFR0lOLCBTRUxFQ1RJT05UT0dHTEUgfVxyXG5cclxuLyoqXHJcbiAqIERlZmluZXMgY2FsbGJhY2tzIGZvciByZWdpb25zIHN0YXRlIGNoYW5nZSBldmVudHMuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBSZWdpb25DaGFuZ2VGdW5jdGlvbiA9IChyZWdpb246IFJlZ2lvbkNvbXBvbmVudCwgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlPzogQ2hhbmdlRXZlbnRUeXBlLCBtdWx0aVNlbGVjdGlvbj86IGJvb2xlYW4pID0+IHZvaWQ7XHJcblxyXG4vKipcclxuICogRGVmaW5lcyBhIGNvbGxlY3Rpb24gb2YgZXZlbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgYFJlZ2lvbmAgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElSZWdpb25DYWxsYmFja3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gc29tZSBtYW5pcHVsYXRpb24gd2l0aCB0aGUgcmVnaW9uIGJlZ2FuLlxyXG4gICAgICovXHJcbiAgICBvbk1hbmlwdWxhdGlvbkJlZ2luOiBSZWdpb25NYW5pcHVsYXRpb25GdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBzb21lIG1hbmlwdWxhdGlvbiB3aXRoIHRoZSByZWdpb24gZW5kZWQuXHJcbiAgICAgKi9cclxuICAgIG9uTWFuaXB1bGF0aW9uRW5kOiBSZWdpb25NYW5pcHVsYXRpb25GdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiByZWdpb24gc3RhdGUgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgb25DaGFuZ2U6IFJlZ2lvbkNoYW5nZUZ1bmN0aW9uO1xyXG59XHJcbiIsImltcG9ydCB7IElSZWN0IH0gZnJvbSBcIi4vSVJlY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBFbnVtIHRvIGRlZmluZSBjdXJyZW50IHNlbGVjdGlvIG1vZGVcclxuICovXHJcbmV4cG9ydCBlbnVtIFNlbGVjdGlvbk1vZGUgeyBOT05FLCBQT0lOVCwgUkVDVCwgQ09QWVJFQ1QsIFBPTFlMSU5FLCBQT0xZR09OIH1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIG9wdGlvbnMgdG8gc2V0dXAgYW4gc2VsZWN0b3IgaW4gYEFyZWFTZWxlY3RvcmAuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTZWxlY3RvclNldHRpbmdzIHtcclxuICAgIG1vZGU6IFNlbGVjdGlvbk1vZGU7XHJcbiAgICB0ZW1wbGF0ZT86IElSZWN0O1xyXG59XHJcbiIsImltcG9ydCB7IFBvaW50MkQgfSBmcm9tIFwiLi4vLi4vQ29yZS9Qb2ludDJEXCI7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWdpb25EYXRhXCI7XHJcblxyXG5pbXBvcnQgeyBJRXZlbnREZXNjcmlwdG9yIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JRXZlbnREZXNjcmlwdG9yXCI7XHJcbmltcG9ydCB7IENoYW5nZUV2ZW50VHlwZSwgSVJlZ2lvbkNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgUmVnaW9uQ29tcG9uZW50IH0gZnJvbSBcIi4vUmVnaW9uQ29tcG9uZW50XCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgdmlzdWFsIGNvbXBvbmVudCB1c2VkIGludGVybmFsbCB0byBkcmF3IGFuY2hvciBwb2ludHMgdGhhdCBhbGxvd1xyXG4gKiByZWdpb24gcG9pbnRzIG1vdmluZyBhbmQgdGhpcyBjb21wb25lbnQgcmVzaXppbmcuXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQW5jaG9yc0NvbXBvbmVudCBleHRlbmRzIFJlZ2lvbkNvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgcmFkaXVzIGZvciBhbmNob3IgcG9pdG5zLiBDYW4gYmUgcmVkZWZpbmVkIHRocm91Z2ggQ1NTIHN0eWxlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBERUZBVUxUX0FOQ0hPUl9SQURJVVMgPSAzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYWlsdCByYWRpdXMgZm9yIHRoZSBnaG9zdCBhbmNob3IsIHVzZWQgYWN0aXZhdGUgZHJhZ2dpbmcuIENhbiBiZSByZWRlZmluZWQgdGhyb3VnaCBDU1Mgc3R5bGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfR0hPU1RfQU5DSE9SX1JBRElVUyA9IDc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXJyYXkgb2YgYW5jaG9ycy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFuY2hvcnM6IFNuYXAuRWxlbWVudFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyb3VwaW5nIGVsZW1lbnQgZm9yIGFuY2hvcnMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhbmNob3JzTm9kZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdob3N0QW5jaG9yOiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgY3VycmVudGx5IGFjdGl2ZSBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhY3RpdmVBbmNob3JJbmRleDogbnVtYmVyID0gLTE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9yaWdpbiBwb2ludCBvbiBkcmFnZ2luZy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGRyYWdPcmlnaW46IFBvaW50MkQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBBbmNob3JzQ29tcG9uZW50YCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIHBhcGVyUmVjdCAtIFRoZSBwYXJlbnQgYm91bmRpbmcgYm94IGZvciBjcmVhdGVkIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSByZWdpb25EYXRhIC0gVGhlIGBSZWdpb25EYXRhYCBvYmplY3Qgc2hhcmVkIGFjcm9zcyBjb21wb25lbnRzLiBVc2VkIGFsc28gZm9yIGluaXRpYWwgc2V0dXAuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIC0gVGhlIGV4dGVybmFsIGNhbGxiYWNrcyBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0ID0gbnVsbCwgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSwgY2FsbGJhY2tzOiBJUmVnaW9uQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIHBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBwYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwiYW5jaG9yc0xheWVyXCIpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yc05vZGUgPSBwYXBlci5nKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRBbmNob3JzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2hvc3RBbmNob3IgPSB0aGlzLmNyZWF0ZUFuY2hvcihwYXBlciwgMCwgMCwgXCJnaG9zdFwiLCBBbmNob3JzQ29tcG9uZW50LkRFRkFVTFRfR0hPU1RfQU5DSE9SX1JBRElVUyk7XHJcbiAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hdHRyKHtcclxuICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCIsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5hbmNob3JzTm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmdob3N0QW5jaG9yKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzOiBJRXZlbnREZXNjcmlwdG9yW10gPSBbXHJcbiAgICAgICAgICAgIHsgZXZlbnQ6IFwicG9pbnRlcmVudGVyXCIsIGxpc3RlbmVyOiB0aGlzLm9uR2hvc3RQb2ludGVyRW50ZXIsIGJhc2U6IHRoaXMuZ2hvc3RBbmNob3Iubm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJsZWF2ZVwiLCBsaXN0ZW5lcjogdGhpcy5vbkdob3N0UG9pbnRlckxlYXZlLCBiYXNlOiB0aGlzLmdob3N0QW5jaG9yLm5vZGUsIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJwb2ludGVyZG93blwiLCBsaXN0ZW5lcjogdGhpcy5vbkdob3N0UG9pbnRlckRvd24sIGJhc2U6IHRoaXMuZ2hvc3RBbmNob3Iubm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJ1cFwiLCBsaXN0ZW5lcjogdGhpcy5vbkdob3N0UG9pbnRlclVwLCBiYXNlOiB0aGlzLmdob3N0QW5jaG9yLm5vZGUsIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJwb2ludGVybW92ZVwiLCBsaXN0ZW5lcjogdGhpcy5vbkdob3N0UG9pbnRlck1vdmUsIGJhc2U6IHRoaXMuZ2hvc3RBbmNob3Iubm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHMobGlzdGVuZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIHZpc3VhbCBvbiB0aGUgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lvbkRhdGEucG9pbnRzICE9PSBudWxsICYmIHRoaXMucmVnaW9uRGF0YS5wb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGF0YS5wb2ludHMuZm9yRWFjaCgocCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvcnNbaW5kZXhdLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogcC54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeTogcC55LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzIHRoZSBjb21wb25lbnQgdG8gdGhlIGZyb3plbiBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGZyZWV6ZSgpIHtcclxuICAgICAgICBzdXBlci5mcmVlemUoKTtcclxuICAgICAgICB0aGlzLmdob3N0QW5jaG9yLnVuZHJhZygpO1xyXG4gICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25FbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9uIGFuY2hvcnMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZEFuY2hvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZFBvaW50QW5jaG9ycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvbGxlY3Rpb24gb2YgYW5jaG9yIHBvaW50cy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGJ1aWxkUG9pbnRBbmNob3JzKCkge1xyXG4gICAgICAgIHRoaXMucmVnaW9uRGF0YS5wb2ludHMuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuY3JlYXRlQW5jaG9yKHRoaXMucGFwZXIsIHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcnMucHVzaChhbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcnNOb2RlLmFkZChhbmNob3IpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVBbmNob3JUb0V2ZW50cyhhbmNob3IsIGluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBzdWJzY3JpYmUgYW5jaG9yIHRvIGFjdGl2YXRpb24gZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBmb3Igd2lyZSB1cC5cclxuICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgYW5jaG9yIHVzZWQgdG8gZGVmaW5lIHdoaWNoIG9uZSBpcyBhY3RpdmUuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdWJzY3JpYmVBbmNob3JUb0V2ZW50cyhhbmNob3I6IFNuYXAuRWxlbWVudCwgaW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIGFuY2hvci5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRnJvemVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgZHJhZyBvcmlnaW4gcG9pbnQgdG8gY3VycmVudCBhbmNob3JcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ09yaWdpbiA9IHRoaXMucmVnaW9uRGF0YS5wb2ludHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgZ2hvc3QgYW5jaG9yIHRvIGN1cnJlbnQgYW5jaG9yIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5kcmFnT3JpZ2luLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmRyYWdPcmlnaW4ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBhbmNob3IuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIHggLSBUaGUgYHhgLWNvb3JkaW5hdGUgb2YgdGhlIGFjbmhvci5cclxuICAgICAqIEBwYXJhbSB5IC0gVGhlIGB5YC1jb29yZGluYXRlIG9mIHRoZSBhbmNob3IuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGUgLSBBZGRpdGlvbmFsIGNzcyBzdHlsZSBjbGFzcyB0byBiZSBhcHBsaWVkLlxyXG4gICAgICogQHBhcmFtIHIgLSBUaGUgcmFkaXVzIG9mIHRoZSBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVBbmNob3IocGFwZXI6IFNuYXAuUGFwZXIsIHg6IG51bWJlciwgeTogbnVtYmVyLCBzdHlsZT86IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogbnVtYmVyID0gQW5jaG9yc0NvbXBvbmVudC5ERUZBVUxUX0FOQ0hPUl9SQURJVVMpOiBTbmFwLkVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IGEgPSBwYXBlci5jaXJjbGUoeCwgeSwgcik7XHJcbiAgICAgICAgYS5hZGRDbGFzcyhcImFuY2hvclN0eWxlXCIpO1xyXG4gICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkICYmIHN0eWxlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGEuYWRkQ2xhc3Moc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZWQgdGhlIGByZWdpb25EYXRhYCBiYXNlZCBvbiB0aGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi4gU2hvdWxkIGJlIHJlZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLlxyXG4gICAgICogQHBhcmFtIHAgLSBUaGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHVwZGF0ZVJlZ2lvbihwOiBQb2ludDJEKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGZvciB0aGUgZHJhZ2JlZ2luIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYW5jaG9yRHJhZ0JlZ2luKCkge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGZvciB0aGUgZHJhZ21vdmUgZXZlbnQuIFVzZXMgYGRyYWdPcmlnaW5gIHRvIGNhbGN1bGF0ZSBuZXcgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0gZHggLSBEaWZmIGluIHRoZSBgeGAtY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSBkeSAtIERpZmYgaW4gdGhlIGB5YC1jb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHggLSBOZXcgYHhgLWNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0geSAtIE5ldyBgeWAtY29vcmRpbmF0ZS5cclxuICAgICAqIEByZW1hcmtzIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgdXBkYXRlUmVnaW9uYCBtZXRob2QgdG8gYWN0dWFsbHkgbWFrZSBhbnkgY2hhbmdlcyBpbiBkYXRhLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYW5jaG9yRHJhZ01vdmUoZHg6IG51bWJlciwgZHk6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICBsZXQgcCA9IG5ldyBQb2ludDJEKHRoaXMuZHJhZ09yaWdpbi54ICsgZHgsIHRoaXMuZHJhZ09yaWdpbi55ICsgZHkpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wYXBlclJlY3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcCA9IHAuYm91bmRUb1JlY3QodGhpcy5wYXBlclJlY3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYXR0cih7IGN4OiBwLngsIGN5OiBwLnkgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlUmVnaW9uKHApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBkcmFuZW5kIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYW5jaG9yRHJhZ0VuZCgpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hdHRyKHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJlbnRlciBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyRW50ZXIoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5naG9zdEFuY2hvci5kcmFnKFxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckRyYWdNb3ZlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yRHJhZ0JlZ2luLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yRHJhZ0VuZC5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5vbk1hbmlwdWxhdGlvbkJlZ2luKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJsZWF2ZSBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyTGVhdmUoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5naG9zdEFuY2hvci51bmRyYWcoKTtcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXggPSAtMTtcclxuICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uRW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJkb3duIGV2ZW50IGZvciB0aGUgZ2hvc3QgYW5jaG9yLlxyXG4gICAgICogQHBhcmFtIGUgLSBQb2ludGVyRXZlbnQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25HaG9zdFBvaW50ZXJEb3duKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMuZ2hvc3RBbmNob3Iubm9kZS5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XHJcbiAgICAgICAgdGhpcy5kcmFnT3JpZ2luID0gbmV3IFBvaW50MkQoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMsIHRoaXMucmVnaW9uRGF0YS5jb3B5KCksIENoYW5nZUV2ZW50VHlwZS5NT1ZFQkVHSU4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBwb2ludGVybW92ZSBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyTW92ZShlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJ1cCBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyVXAoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5naG9zdEFuY2hvci5ub2RlLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCB0aGlzLnJlZ2lvbkRhdGEuY29weSgpLCBDaGFuZ2VFdmVudFR5cGUuTU9WRUVORCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IENoYW5nZUV2ZW50VHlwZSwgSVJlZ2lvbkNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgUmVnaW9uQ29tcG9uZW50IH0gZnJvbSBcIi4vUmVnaW9uQ29tcG9uZW50XCI7XHJcbmltcG9ydCB7IElFdmVudERlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lFdmVudERlc2NyaXB0b3JcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCB2aXN1YWwgY29tcG9uZW50IHVzZWQgaW50ZXJuYWxsIGRvIGFsbG93IGRyYWdnaW5nIHRoZSB3aG9sZSByZWdpb24uXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRHJhZ0NvbXBvbmVudCBleHRlbmRzIFJlZ2lvbkNvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwaW5nIGVsZW1lbnQgZm9yIGludGVybmFsIGRyYWcgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBkcmFnTm9kZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dpbmcgc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGlzRHJhZ2dlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvcmlnaW4gcG9pbnQgb24gZHJhZ2dpbmcuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBkcmFnT3JpZ2luOiBQb2ludDJEO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRHJhZ0NvbXBvbmVudGAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIHBhcGVyUmVjdDogUmVjdCA9IG51bGwsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcykge1xyXG4gICAgICAgIHN1cGVyKHBhcGVyLCBwYXBlclJlY3QsIHJlZ2lvbkRhdGEsIGNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gcGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcImRyYWdMYXllclwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzIHRoZSBjb21wb25lbnQgdG8gdGhlIGZyb3plbiBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGZyZWV6ZSgpIHtcclxuICAgICAgICBzdXBlci5mcmVlemUoKTtcclxuICAgICAgICB0aGlzLmRyYWdOb2RlLnVuZHJhZygpO1xyXG4gICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25FbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGZvciB0aGUgZHJhZ2JlZ2luIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25EcmFnQmVnaW4oKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnT3JpZ2luID0gbmV3IFBvaW50MkQodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBkcmFnbW92ZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBkeCAtIERpZmYgaW4gdGhlIGB4YC1jb29yZGluYXRlIG9mIGRyYWdnYWJsZSBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIGR5IC0gRGlmZiBpbiB0aGUgYHlgLWNvb3JkaW5hdGUgb2YgZHJhZ2dhYmxlIGVsZW1lbnQuXHJcbiAgICAgKiBAcmVtYXJrcyBUaGlzIG1ldGhvZCBkaXJlY3RseSBjYWxscyB0aGUgYG9uQ2hhbmdlYCBjYWxsYmFjayB3cmFwcGVyLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25EcmFnTW92ZShkeDogbnVtYmVyLCBkeTogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwID0gbmV3IFBvaW50MkQodGhpcy5kcmFnT3JpZ2luLnggKyBkeCwgdGhpcy5kcmFnT3JpZ2luLnkgKyBkeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXBlclJlY3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLmJvdW5kVG9SZWN0KHRoaXMucGFwZXJSZWN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmQgPSB0aGlzLnJlZ2lvbkRhdGEuY29weSgpO1xyXG4gICAgICAgICAgICByZC5tb3ZlKHApO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMsIHJkLCBDaGFuZ2VFdmVudFR5cGUuTU9WSU5HKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIGRyYWdlbmQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvbkRyYWdFbmQoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnT3JpZ2luID0gbnVsbDtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCB0aGlzLnJlZ2lvbkRhdGEuY29weSgpLCBDaGFuZ2VFdmVudFR5cGUuTU9WRUVORCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3Vic2NpYmUgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHRvIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN1YnNjcmliZVRvRHJhZ0V2ZW50cygpIHtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnM6IElFdmVudERlc2NyaXB0b3JbXSA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwicG9pbnRlcmVudGVyXCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiB0aGlzLmRyYWdOb2RlLm5vZGUsXHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ05vZGUudW5kcmFnKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnTm9kZS5kcmFnKHRoaXMub25EcmFnTW92ZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRHJhZ0JlZ2luLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25EcmFnRW5kLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVybW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5kcmFnTm9kZS5ub2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ05vZGUudW5kcmFnKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ05vZGUuZHJhZyh0aGlzLm9uRHJhZ01vdmUuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25EcmFnQmVnaW4uYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25EcmFnRW5kLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25CZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVybGVhdmVcIixcclxuICAgICAgICAgICAgICAgIGJhc2U6IHRoaXMuZHJhZ05vZGUubm9kZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyOiAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnTm9kZS51bmRyYWcoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25FbmQoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVyZG93blwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5kcmFnTm9kZS5ub2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdOb2RlLm5vZGUuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG11bHRpc2VsZWN0aW9uID0gZS5jdHJsS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodGhpcywgdGhpcy5yZWdpb25EYXRhLmNvcHkoKSwgQ2hhbmdlRXZlbnRUeXBlLk1PVkVCRUdJTiwgbXVsdGlzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBcInBvaW50ZXJ1cFwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5kcmFnTm9kZS5ub2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6ICAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnTm9kZS5ub2RlLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXVsdGlzZWxlY3Rpb24gPSBlLmN0cmxLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCB0aGlzLnJlZ2lvbkRhdGEuY29weSgpLCBDaGFuZ2VFdmVudFR5cGUuU0VMRUNUSU9OVE9HR0xFLCBtdWx0aXNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYnlwYXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKGxpc3RlbmVycyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IElFdmVudERlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lFdmVudERlc2NyaXB0b3JcIjtcclxuaW1wb3J0IHsgSUZyZWV6YWJsZSB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSUZyZWV6YWJsZVwiO1xyXG5pbXBvcnQgeyBJSGlkZWFibGUgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lIaWRlYWRibGVcIjtcclxuaW1wb3J0IHsgSU1vdmFibGUgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lNb3ZhYmxlXCI7XHJcbmltcG9ydCB7IElSZXNpemFibGUgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lSZXNpemFibGVcIjtcclxuaW1wb3J0IHsgSVJlZ2lvbkNhbGxiYWNrcywgQ2hhbmdlRXZlbnRUeXBlIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcbmltcG9ydCB7IElQb2ludDJEIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUG9pbnQyRFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IHZpc2lhbCBjb21wb25lbnQgdG8gZGVmaW5lIGEgY29tcG9uZW50IG9mIHJlZ2lvbiBwcmVzZW50YXRpb24gVUkuXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVnaW9uQ29tcG9uZW50IGltcGxlbWVudHMgSUhpZGVhYmxlLCBJUmVzaXphYmxlLCBJTW92YWJsZSwgSUZyZWV6YWJsZSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgU25hcC5FbGVtZW50YCBvYmplY3Qgb2YgdGhlIGNvbXBvbmVudCB0byBiZSB1c2VkIGluIERPTSB0cmVlIGNvbXBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbm9kZTogU25hcC5FbGVtZW50O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBkZXNjcmliaW5nIGN1cnJlbnQgcmVnaW9uIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVnaW9uRGF0YTogUmVnaW9uRGF0YTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgdGhlIGNvbXBvbmVudCBpcyB2aXNpYmxlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaXNWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgaWYgdGhlIGNvbXBvbmVudCBpcyBpbiBhIGZyb3plbiBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzRnJvemVuOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGlmIHRoZSBjb21wb25lbnQgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc1NlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcGVyOiBTbmFwLlBhcGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBzaXplIG9mIHBhcmVudCBob3N0LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGFwZXJSZWN0OiBSZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB4YC1jb29yZGluYXRlIG9mIHRoZSBjb21wb25lbnQuIERlZmluZWQgdGhyb3VnaCB0aGUgYHJlZ2lvbmFEYXRhYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9uRGF0YS54O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB5YC1jb29yZGluYXRlIG9mIHRoZSBjb21wb25lbnQuIERlZmluZWQgdGhyb3VnaCB0aGUgYHJlZ2lvbmFEYXRhYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCB5KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9uRGF0YS55O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB3aWR0aGAgb2YgdGhlIGNvbXBvbmVudC4gRGVmaW5lZCB0aHJvdWdoIHRoZSBgcmVnaW9uYURhdGFgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHdpZHRoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaW9uRGF0YS5ib3VuZFJlY3Qud2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYGhlaWdodGAgb2YgdGhlIGNvbXBvbmVudC4gRGVmaW5lZCB0aHJvdWdoIHRoZSBgcmVnaW9uYURhdGFgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lvbkRhdGEuYm91bmRSZWN0LmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgYXJlYWAgb2YgdGhlIGNvbXBvbmVudC4gRGVmaW5lZCB0aHJvdWdoIHRoZSBgcmVnaW9uYURhdGFgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGFyZWEoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25EYXRhLmFyZWE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYGJvdW5kUmVjdGAgb2YgdGhlIGNvbXBvbmVudC4gRGVmaW5lZCB0aHJvdWdoIHRoZSBgcmVnaW9uYURhdGFgLlxyXG4gICAgICogQHJlbWFya3MgUmV0dXJucyB0aGUgYFJlY3RgIG9iamVjdCBvZiB0aGUgc2FtZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBhcyB0aGUgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGJvdW5kUmVjdCgpOiBSZWN0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpb25EYXRhLmJvdW5kUmVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3M7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFVJIGNvbXBvbmVudCAocGFydCBvZiB0aGUgcmVnaW9uKS5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXI7XHJcbiAgICAgICAgdGhpcy5wYXBlclJlY3QgPSBwYXBlclJlY3Q7XHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhID0gcmVnaW9uRGF0YTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICBvbk1hbmlwdWxhdGlvbkJlZ2luOiBudWxsLFxyXG4gICAgICAgICAgICBvbk1hbmlwdWxhdGlvbkVuZDogbnVsbCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoY2FsbGJhY2tzICE9PSBudWxsICYmIGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3Mub25NYW5pcHVsYXRpb25CZWdpbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkJlZ2luID0gY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uQmVnaW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkVuZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkVuZCA9IGNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkVuZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkNoYW5nZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzIHRoZSBjb21wb25lbnQgcHJlc2VudHN0aW9uIHRvIHRoZSBoaWRkZW4gc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoaWRlKCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5ub2RlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzIHRoZSBjb21wb25lbnQgcHJlc2VudGF0aW9uIHRvIHRoZSB2aXNpYmlsZSBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLm5vZGUuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0cyB0aGUgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2VsZWN0KCkge1xyXG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwic2VsZWN0ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnNlbGVjZXRzIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1bnNlbGVjdCgpIHtcclxuICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzIHRoZSBjb21wb25lbnQgdG8gdGhlIGZyb3plbiBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLmlzRnJvemVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzIHRoZSBjb21wb25lbnQgdG8gdGhlIHVuZnJvemVuIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdW5mcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGNvbXBvbmVudCB0byBzcGVjaWZpZWQgbG9jYXRpb25cclxuICAgICAqIEBwYXJhbSBwb2ludCAtIFRoZSBuZXcgY29tcG9uZW50IGxvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZShwb2ludDogSVBvaW50MkQpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGNvbXBvbmVudCB0byBzcGVjaWZpZWQgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcGFyYW0geCAtIFRoZSBuZXcgYHhgLWNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0geSAtIFRoZSBuZXcgYHlgLWNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtb3ZlKHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgbW92ZShhcmcxOiBhbnksIGFyZzI/OiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJlZ2lvbkRhdGEubW92ZShhcmcxLCBhcmcyKTtcclxuICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyB0aGUgdmlzdWFsIG9mIHRoZSBjb21wb25lbnQuIFNob3VsZCBiZSByZWRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHJlZHJhdygpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgY29tcG9uZW50IHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgYHdpZHRoYCBmb3IgdGhlIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGBoZWlnaHRgIGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgYm91bmRpbmcgYm94IGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG5ldyBgd2lkdGhgIG9mIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyBgaGVpZ2h0YCBvZiB0aGUgYm91bmRpbmcgYm94LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplUGFwZXIod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnBhcGVyUmVjdC5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd3JhcHBlciBhcm91bmQgZXh0ZXJuYWwgYG9uQ2hhbmdlYCBjYWxsYmFjay4gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGxiYWNrIGlzIGRlZmluZWQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gUmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHRvIGJlIHBhc3NlZC5cclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS5cclxuICAgICAqIEBwYXJhbSBtdWx0aVNlbGVjdGlvbiAtIFRoZSBmbGFnIGZvciBtdWx0aXBsZSByZWdpb25zIHNlbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uQ2hhbmdlKHJlZ2lvbjogUmVnaW9uQ29tcG9uZW50LCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBldmVudFR5cGU/OiBDaGFuZ2VFdmVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlTZWxlY3Rpb24/OiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uQ2hhbmdlICE9PSBudWxsICYmIHRoaXMuY2FsbGJhY2tzLm9uQ2hhbmdlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25DaGFuZ2UocmVnaW9uLCByZWdpb25EYXRhLCBldmVudFR5cGUsIG11bHRpU2VsZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd3JhcHBlciBhcm91bmQgZXh0ZXJuYWwgYG9uTWFuaXB1bGF0aW9uQmVnaW5gIGNhbGxiYWNrLiBDaGVja3Mgd2hldGhlciB0aGUgY2FsbGJhY2sgaXMgZGVmaW5lZC5cclxuICAgICAqIEBwYXJhbSByZWdpb24gLSBSZWZlcmVuY2UgdG8gdGhlIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uTWFuaXB1bGF0aW9uQmVnaW4ocmVnaW9uPzogUmVnaW9uQ29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uQmVnaW4gIT09IG51bGwgJiYgdGhpcy5jYWxsYmFja3Mub25NYW5pcHVsYXRpb25CZWdpbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uQmVnaW4ocmVnaW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd3JhcHBlciBhcm91bmQgZXh0ZXJuYWwgYG9uTWFudXB1bGF0aW9uRW5kYCBjYWxsYmFjay4gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGxiYWNrIGlzIGRlZmluZWQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gUmVmZXJlbmNlIHRvIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvbk1hbmlwdWxhdGlvbkVuZChyZWdpb24/OiBSZWdpb25Db21wb25lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja3Mub25NYW5pcHVsYXRpb25FbmQgIT09IG51bGwgJiYgdGhpcy5jYWxsYmFja3Mub25NYW5pcHVsYXRpb25FbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkVuZChyZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcnViZXMgdGhlIGNvbXBvbmVudCBlbGVtZW50cyBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgZXZlbnQgZGVzY3JpcHRvcnMuIEJpbmRzIHRvIHRoZSBgdGhpc2Agb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVycyAtIFRoZSBjb2xsZWN0aW9uIG9mIGV2ZW50IGRlc2NyaXB0b3JzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlVG9FdmVudHMobGlzdGVuZXJzOiBJRXZlbnREZXNjcmlwdG9yW10pIHtcclxuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLmJhc2UuYWRkRXZlbnRMaXN0ZW5lcihlLmV2ZW50LCB0aGlzLm1ha2VGcmVlemFibGUoZS5saXN0ZW5lci5iaW5kKHRoaXMpLCBlLmJ5cGFzcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gbWFrZSBldmVudCBsaXN0ZW5lcnMgZnJvb3plbiBpZiB0aGUgY29tcG9uZW50IHN0YXRlIGlzIGZyb3plbi5cclxuICAgICAqIEBwYXJhbSBmIC0gRnVuY3Rpb24gdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSBieXBhc3MgLSBBIGZsYWcgd2hldGhlciBldmVudCBzaG91bGQgYnlwYXNzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbWFrZUZyZWV6YWJsZShmOiAoYXJnczogUG9pbnRlckV2ZW50IHwgS2V5Ym9hcmRFdmVudCkgPT4gdm9pZCwgYnlwYXNzOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gKGFyZ3M6IFBvaW50ZXJFdmVudCB8IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRnJvemVuIHx8IGJ5cGFzcykge1xyXG4gICAgICAgICAgICAgICAgZihhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuaW1wb3J0IHsgVGFnc0Rlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vQ29yZS9UYWdzRGVzY3JpcHRvclwiO1xyXG5cclxuaW1wb3J0IHsgSVRhZ3NVcGRhdGVPcHRpb25zIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JVGFnc1VwZGF0ZU9wdGlvbnNcIjtcclxuXHJcbmltcG9ydCB7IFJlZ2lvbkNvbXBvbmVudCB9IGZyb20gXCIuL1JlZ2lvbkNvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IHZpc3VhbCBjb21wb25lbnQgdXNlZCBpbnRlcm5hbGwgZG8gZHJhdyB0YWdzIGRhdGEgZm9yIHJlZ2lvbnMuXHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGFnc0NvbXBvbmVudCBleHRlbmRzIFJlZ2lvbkNvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZWZlcmVuY2UgdG8gcmVnaW9uJ3MgYFRhZ3NEZXNjcmlwdG9yYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YWdzOiBUYWdzRGVzY3JpcHRvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBncm91cGluZyBlbGVtZW50IGZvciBwcmltYXJ5IHRhZy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHByaW1hcnlUYWdOb2RlOiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JvdXBpbmcgZWxlbWVudCBmb3Igc2Vjb25kYXJ5IHRhZ3MuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZWNvbmRhcnlUYWdzTm9kZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFycmF5IG9mIHNlY29uZGFyeSB0YWdzIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2Vjb25kYXJ5VGFnczogU25hcC5FbGVtZW50W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmlxdWUgY3NzIHN0eWxlIGlkIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3R5bGVJZDogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBzdHlsZXNoZWV0IGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdHlsZVNoZWV0OiBDU1NTdHlsZVNoZWV0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXR0aW5ncyBmb3IgcmVkcmF3aW5nIHRhZ3MuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB0YWdzVXBkYXRlT3B0aW9uczogSVRhZ3NVcGRhdGVPcHRpb25zO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBzdHlsaW5nIHJ1bGVzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3R5bGVNYXA6IEFycmF5PHsgcnVsZTogc3RyaW5nLCBzdHlsZTogc3RyaW5nIH0+ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWdodCBzdHlsaW5nIHJ1bGVzIHVzZWQgd2hlbiBgc2hvd1JlZ2lvbkJhY2tncm91bmRgIGlzIHNldCB0byBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3R5bGVMaWdodE1hcDogQXJyYXk8eyBydWxlOiBzdHJpbmcsIHN0eWxlOiBzdHJpbmcgfT4gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRhZ3NDb21wb25lbnRgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIGBUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IHByZXNlbnRpbmcgY29sb3JzIGFuZCBuYW1lcyBmb3IgcmVnaW9uIHRhZ3MuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVJZCAtIFRoZSB1bmlxdWUgY3NzIHN0eWxlIGlkIGZvciByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVTaGVldCAtIFRoZSByZWdlcmVuY2UgdG8gdGhlIHN0eWxlc2hlZXQgb2JqZWN0IGZvciBydWxlcyBpbnNlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdGFnc1VwZGF0ZU9wdGlvbnMgLSBUaGUgc2V0dGluZ3MgZm9yIHJlZHJhd2luZyB0YWdzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0LCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzOiBUYWdzRGVzY3JpcHRvcixcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0cmluZywgc3R5bGVTaGVldDogQ1NTU3R5bGVTaGVldCwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBudWxsKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdHlsZUlkID0gc3R5bGVJZDtcclxuICAgICAgICB0aGlzLnN0eWxlU2hlZXQgPSBzdHlsZVNoZWV0O1xyXG5cclxuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xyXG4gICAgICAgIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMgPSB0YWdzVXBkYXRlT3B0aW9ucztcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlID0gcGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcInRhZ3NMYXllclwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29tcG9uZW50IHdpdGggbmV3IGBUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IGFuZCBuZXcgZHJhd2luZyBzZXR0aW5ncy5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIG5ldyBgVGFnc0Rlc2NyaXB0b3JgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG5ldyBkcmF3aW5nIHNldHRpbmdzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlVGFncyh0YWdzOiBUYWdzRGVzY3JpcHRvciwgb3B0aW9ucz86IElUYWdzVXBkYXRlT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XHJcbiAgICAgICAgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyA9IG9wdGlvbnM7XHJcblxyXG4gICAgICAgIHRoaXMucmVidWlsZFRhZ0xhYmVscygpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJTdHlsZU1hcHMoKTtcclxuICAgICAgICB0aGlzLmluaXRTdHlsZU1hcHModGFncyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3dCYWNrZ3JvdW5kID0gKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnNob3dSZWdpb25CYWNrZ3JvdW5kIDogdHJ1ZTtcclxuICAgICAgICB0aGlzLmFwcGx5U3R5bGVNYXBzKHNob3dCYWNrZ3JvdW5kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRzIHRoZSBzdHlsaW5nIHJ1bGVzIGZvciB0aGUgY29tcG9uZW50LiBTaG91bGQgYmUgcmVkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gdGFncyAtLSBUaGUgYFRhZ3NEZXNjcmlwdG9yYCBvYmplY3QgdG8gZGVmaW5lIG5ldyBzdHlsZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbml0U3R5bGVNYXBzKHRhZ3M6IFRhZ3NEZXNjcmlwdG9yKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYnVsZHMgdGhlIHRhZ3MgZWxlbWVudHMuIFNob3VsZCBiZSByZWRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYnVpbGRUYWdMYWJlbHMoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBjdXJyZW50IHN0eWxpbmcgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjbGVhclN0eWxlTWFwcygpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5zdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZVNoZWV0LmRlbGV0ZVJ1bGUoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0aGUgc3R5bGluZyBydWxlcyBpbnRvIHRoZSBgc3R5bGVTaGVldGAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHNob3dSZWdpb25CYWNrZ3JvdW5kIC0gVGhlIGZsYWcgdG8gbWFrZSBiYWNrZ3JvdW5kIHZpc2libGUgb3IgdHJhbnNwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhcHBseVN0eWxlTWFwcyhzaG93UmVnaW9uQmFja2dyb3VuZDogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgICAgICAvLyBNYXAgcHJpbWFyeSB0YWcgY29sb3JcclxuICAgICAgICBpZiAodGhpcy50YWdzICYmIHRoaXMudGFncy5wcmltYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbSA9IChzaG93UmVnaW9uQmFja2dyb3VuZCA/IHRoaXMuc3R5bGVNYXAgOiB0aGlzLnN0eWxlTGlnaHRNYXApO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByIG9mIHNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZVNoZWV0Lmluc2VydFJ1bGUoYCR7ci5ydWxlfXske3Iuc3R5bGV9fWAsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IElSZWdpb25DYWxsYmFja3MgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lSZWdpb25DYWxsYmFja3NcIjtcclxuXHJcbmltcG9ydCB7IERyYWdDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L0RyYWdDb21wb25lbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBgRHJhZ0NvbXBvbmVudGAgZm9yIHRoZSBgUG9pbnRSZWdpb25gIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERyYWdFbGVtZW50IGV4dGVuZHMgRHJhZ0NvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgKHZpc3VhbCkgcmFkaXVzIGZvciBwb2ludCBkcmFnLWNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBERUZBVUxUX0RSQUdfUkFESVVTOiBudW1iZXIgPSA2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRHJhZ0VsZW1lbnRgLlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIHBhcGVyUmVjdDogUmVjdCA9IG51bGwsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcykge1xyXG4gICAgICAgIHN1cGVyKHBhcGVyLCBwYXBlclJlY3QsIHJlZ2lvbkRhdGEsIGNhbGxiYWNrcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZHJhZ05vZGUgPSBwYXBlci5jaXJjbGUodGhpcy54LCB0aGlzLnksIERyYWdFbGVtZW50LkRFRkFVTFRfRFJBR19SQURJVVMpO1xyXG4gICAgICAgIHRoaXMuZHJhZ05vZGUuYWRkQ2xhc3MoXCJkcmFnUG9pbnRTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmRyYWdOb2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0RyYWdFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIGNvbXBvbm5lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWRyYXcoKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ05vZGUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMueSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuaW1wb3J0IHsgVGFnc0Rlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vQ29yZS9UYWdzRGVzY3JpcHRvclwiO1xyXG5cclxuaW1wb3J0IHsgSVRhZ3NVcGRhdGVPcHRpb25zIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JVGFnc1VwZGF0ZU9wdGlvbnNcIjtcclxuaW1wb3J0IHsgSVJlZ2lvbkNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgUmVnaW9uIH0gZnJvbSBcIi4uL1JlZ2lvblwiO1xyXG5pbXBvcnQgeyBEcmFnRWxlbWVudCB9IGZyb20gXCIuL0RyYWdFbGVtZW50XCI7XHJcbmltcG9ydCB7IFRhZ3NFbGVtZW50IH0gZnJvbSBcIi4vVGFnc0VsZW1lbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcG9pbnQtdHlwZSByZWdpb24gY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9pbnRSZWdpb24gZXh0ZW5kcyBSZWdpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIERyYWdFbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRyYWdOb2RlOiBEcmFnRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgVGFnc0VsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdGFnc05vZGU6IFRhZ3NFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB0b29sdGlwIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG9vbFRpcDogU25hcC5GcmFnbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBQb2ludFJlZ2lvbmAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSByZWdpb24gYGlkYCB1c2VkIHRvIGlkZW50aWZ5IHJlZ2lvbnMgaW4gYFJlZ2lvbnNNYW5hZ2VyYC5cclxuICAgICAqIEBwYXJhbSB0YWdzRGVzY3JpcHRvciAtIFRoZSBkZXNjcmlwdG9yIG9mIHJlZ2lvbiB0YWdzLlxyXG4gICAgICogQHBhcmFtIHRhZ3NVcGRhdGVPcHRpb25zIC0gVGhlIGRyYXdpbmcgb3B0aW9ucyBmb3IgdGFncy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIHBhcGVyUmVjdDogUmVjdCA9IG51bGwsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcyxcclxuICAgICAgICAgICAgICAgIGlkOiBzdHJpbmcsIHRhZ3NEZXNjcmlwdG9yOiBUYWdzRGVzY3JpcHRvciwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MsIGlkLCB0YWdzRGVzY3JpcHRvciwgdGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLmJ1aWxkT24ocGFwZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyByZWdpb24gdGFncy5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIG5ldyB0YWdzIGRlc2NyaXB0b3Igb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdGFncyBkcmF3aW5nIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVUYWdzKHRhZ3M6IFRhZ3NEZXNjcmlwdG9yLCBvcHRpb25zPzogSVRhZ3NVcGRhdGVPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlVGFncyh0YWdzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy50YWdzTm9kZS51cGRhdGVUYWdzKHRhZ3MsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubm9kZS5zZWxlY3QoXCJ0aXRsZVwiKS5ub2RlLmlubmVySFRNTCA9ICh0YWdzICE9PSBudWxsKSA/IHRhZ3MudG9TdHJpbmcoKSA6IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBVSSBvZiB0aGUgcmVnaW9uIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgZWxlbWVudCB0byBkcmF3IG9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkT24ocGFwZXI6IFNuYXAuUGFwZXIpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBwYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwicmVnaW9uU3R5bGVcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKHRoaXMuc3R5bGVJRCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgb25NYW5pcHVsYXRpb25CZWdpbjogdGhpcy5vbk1hbmlwdWxhdGlvbkJlZ2luLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIG9uTWFuaXB1bGF0aW9uRW5kOiB0aGlzLm9uTWFuaXB1bGF0aW9uRW5kLmJpbmQodGhpcyksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5kcmFnTm9kZSA9IG5ldyBEcmFnRWxlbWVudChwYXBlciwgdGhpcy5wYXBlclJlY3QsIHRoaXMucmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLnRhZ3NOb2RlID0gbmV3IFRhZ3NFbGVtZW50KHBhcGVyLCB0aGlzLnBhcGVyUmVjdCwgIHRoaXMucmVnaW9uRGF0YSwgdGhpcy50YWdzLCB0aGlzLnN0eWxlSUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlU2hlZXQsIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLnRvb2xUaXAgPSBTbmFwLnBhcnNlKGA8dGl0bGU+JHsodGhpcy50YWdzICE9PSBudWxsKSA/IHRoaXMudGFncy50b1N0cmluZygpIDogXCJcIn08L3RpdGxlPmApO1xyXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmQodGhpcy50b29sVGlwIGFzIGFueSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5kcmFnTm9kZS5ub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMudGFnc05vZGUubm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuVUkucHVzaCh0aGlzLnRhZ3NOb2RlLCB0aGlzLmRyYWdOb2RlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5pbXBvcnQgeyBUYWdzRGVzY3JpcHRvciB9IGZyb20gXCIuLi8uLi9Db3JlL1RhZ3NEZXNjcmlwdG9yXCI7XHJcblxyXG5pbXBvcnQgeyBJVGFnc1VwZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lUYWdzVXBkYXRlT3B0aW9uc1wiO1xyXG5cclxuaW1wb3J0IHsgVGFnc0NvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvVGFnc0NvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIGBUYWdzQ29tcG9uZW50YCBmb3IgdGhlIGBQb2ludFJlZ2lvbmAgY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGFnc0VsZW1lbnQgZXh0ZW5kcyBUYWdzQ29tcG9uZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCAodmlzdWFsKSByYWRpdXMgZm9yIHByaW1hcnkgdGFnIHBvaW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfUFJJTUFSWV9UQUdfUkFESVVTOiBudW1iZXIgPSAzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCAodmlzdWFsKSBzaXplIGZvciBzZWNvbmRhcnkgdGFnIGJveGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfU0VDT05EQVJZX1RBR19TSVpFOiBudW1iZXIgPSA2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCAodmlzdWFsKSB2ZXJ0aWNhbCBzaGlmdCBmb3Igc2Vjb25kYXJ5IHRhZyBib3hlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBERUZBVUxUX1NFQ09OREFSWV9UQUdfRFk6IG51bWJlciA9IDY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUYWdzRWxlbWVudGAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIHRhZ3MgLSBUaGUgYFRhZ3NEZXNjcmlwdG9yYCBvYmplY3QgcHJlc2VudGluZyBjb2xvcnMgYW5kIG5hbWVzIGZvciByZWdpb24gdGFncy5cclxuICAgICAqIEBwYXJhbSBzdHlsZUlkIC0gVGhlIHVuaXF1ZSBjc3Mgc3R5bGUgaWQgZm9yIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSBzdHlsZVNoZWV0IC0gVGhlIHJlZ2VyZW5jZSB0byB0aGUgc3R5bGVzaGVldCBvYmplY3QgZm9yIHJ1bGVzIGluc2VjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0YWdzVXBkYXRlT3B0aW9ucyAtIFRoZSBzZXR0aW5ncyBmb3IgcmVkcmF3aW5nIHRhZ3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHRhZ3M6IFRhZ3NEZXNjcmlwdG9yLCBzdHlsZUlkOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0OiBDU1NTdHlsZVNoZWV0LCB0YWdzVXBkYXRlT3B0aW9ucz86IElUYWdzVXBkYXRlT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKHBhcGVyLCBwYXBlclJlY3QsIHJlZ2lvbkRhdGEsIHRhZ3MsIHN0eWxlSWQsIHN0eWxlU2hlZXQsIHRhZ3NVcGRhdGVPcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5idWlsZE9uKHBhcGVyLCB0YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIGNvbXBvbm5lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWRyYXcoKSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IFRhZ3NFbGVtZW50LkRFRkFVTFRfU0VDT05EQVJZX1RBR19TSVpFO1xyXG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy54O1xyXG4gICAgICAgIGNvbnN0IGN5ID0gdGhpcy55IC0gc2l6ZSAtIFRhZ3NFbGVtZW50LkRFRkFVTFRfU0VDT05EQVJZX1RBR19EWTtcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZ05vZGUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBjeDogdGhpcy54LFxyXG4gICAgICAgICAgICAgICAgY3k6IHRoaXMueSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZWNvbmRhcnkgVGFnc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlUYWdzICYmIHRoaXMuc2Vjb25kYXJ5VGFncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnNlY29uZGFyeVRhZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWcgPSB0aGlzLnNlY29uZGFyeVRhZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGN4ICsgKDIgKiBpIC0gbGVuZ3RoICsgMC41KSAqIHNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWcuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN5LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0cyBzdHlsZSBtYXBzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW5pdFN0eWxlTWFwcyh0YWdzOiBUYWdzRGVzY3JpcHRvcikge1xyXG4gICAgICAgIGlmICh0YWdzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0YWdzLnByaW1hcnkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYXAgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvaW50U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yQWNjZW50fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfTpob3ZlciAgLnByaW1hcnlUYWdQb2ludFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvckhpZ2hsaWdodH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogI2ZmZjtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLnNlbGVjdGVkLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvaW50U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yQWNjZW50fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6JHt0YWdzLnByaW1hcnkuY29sb3JIaWdobGlnaHR9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUxpZ2h0TWFwID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdQb2ludFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvck5vQ29sb3J9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZToke3RhZ3MucHJpbWFyeS5jb2xvckFjY2VudH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH06aG92ZXIgIC5wcmltYXJ5VGFnUG9pbnRTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlOiR7dGFncy5wcmltYXJ5LmNvbG9yQWNjZW50fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLnNlbGVjdGVkLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvaW50U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9ySGlnaGxpZ2h0fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6JHt0YWdzLnByaW1hcnkuY29sb3JBY2NlbnR9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5zZWNvbmRhcnlUYWdTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgb3BhY2l0eTowLjI1O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5kcmFnUG9pbnRTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgb3BhY2l0eTowLjI1O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuc2VsZWN0ZWQuJHt0aGlzLnN0eWxlSWR9IC5kcmFnUG9pbnRTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgb3BhY2l0eTowLjU7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYXAgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVMaWdodE1hcCA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnUG9pbnRTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB2YXIoLS1kZWZhdWx0LWNvbG9yLXB1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS13aWR0aDogMXB4O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5kcmFnUG9pbnRTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgb3BhY2l0eTowLjI1O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuc2VsZWN0ZWQuJHt0aGlzLnN0eWxlSWR9IC5kcmFnUG9pbnRTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgb3BhY2l0eTowLjU7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhZ3Muc2Vjb25kYXJ5ICE9PSBudWxsICYmIHRhZ3Muc2Vjb25kYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhZ3Muc2Vjb25kYXJ5LmZvckVhY2goKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuc2Vjb25kYXJ5VGFnU3R5bGUuc2Vjb25kYXJ5VGFnLSR7dGFnLm5hbWV9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZy5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUxpZ2h0TWFwLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHJlY3JlYXRlIHRhZyBsYWJlbHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZWJ1aWxkVGFnTGFiZWxzKCkge1xyXG4gICAgICAgIC8vIENsZWFyIHNlY29uZGFyeSB0YWdzIC0+IHJlZHJhdyBmcm9tIHNjcmF0Y2hcclxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnNlY29uZGFyeVRhZ3MpIHtcclxuICAgICAgICAgICAgdGFnLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MgPSBbXTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgdGFncyBhc3NpZ25lZFxyXG4gICAgICAgIGlmICh0aGlzLnRhZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFncy5wcmltYXJ5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy50YWdzLnByaW1hcnkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByaW1hcnkgVGFnXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNlY29uZGFyeSBUYWdzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3Muc2Vjb25kYXJ5ICYmIHRoaXMudGFncy5zZWNvbmRhcnkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy50YWdzLnNlY29uZGFyeS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhZyA9IHRoaXMudGFncy5zZWNvbmRhcnlbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBUYWdzRWxlbWVudC5ERUZBVUxUX1NFQ09OREFSWV9UQUdfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54ICsgdGhpcy5ib3VuZFJlY3Qud2lkdGggLyAyICsgKDIgKiBpIC0gbGVuZ3RoICsgMSkgKiBzaXplIC0gc2l6ZSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIHNpemUgLSBUYWdzRWxlbWVudC5ERUZBVUxUX1NFQ09OREFSWV9UQUdfRFk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnZWwgPSB0aGlzLnBhcGVyLnJlY3QoeCwgeSwgc2l6ZSwgc2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdlbC5hZGRDbGFzcyhcInNlY29uZGFyeVRhZ1N0eWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdlbC5hZGRDbGFzcyhgc2Vjb25kYXJ5VGFnLSR7c3RhZy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3NOb2RlLmFkZCh0YWdlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzLnB1c2godGFnZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gY3JlYXRlIHRhZyBsYWJlbHNcclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gdGFncyAtIFRoZSBgVGFnc0Rlc2NyaXB0b3JgIG9iamVjdCBkZWZpbmluZyB0YWdzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkT24ocGFwZXI6IFNuYXAuUGFwZXIsIHRhZ3M6IFRhZ3NEZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnTm9kZSA9IHBhcGVyLmNpcmNsZSh0aGlzLngsIHRoaXMueSwgVGFnc0VsZW1lbnQuREVGQVVMVF9QUklNQVJZX1RBR19SQURJVVMpO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ05vZGUuYWRkQ2xhc3MoXCJwcmltYXJ5VGFnUG9pbnRTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzTm9kZSA9IHBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3NOb2RlLmFkZENsYXNzKFwic2Vjb25kYXR5VGFnc0xheWVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5VGFncyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMucHJpbWFyeVRhZ05vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5zZWNvbmRhcnlUYWdzTm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdFN0eWxlTWFwcyh0YWdzKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRhZ3ModGFncywgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IENoYW5nZUV2ZW50VHlwZSwgSVJlZ2lvbkNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgQW5jaG9yc0NvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvQW5jaG9yc0NvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIGBBbmNob3JzQ29tcG9uZW50YCBmb3IgdGhlIGBQb2x5Z29uUmVnaW9uYCBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBbmNob3JzRWxlbWVudCBleHRlbmRzIEFuY2hvcnNDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHRocmVzaG9sZCBkaXN0YW5jZSB0byBkZWZpbmUgd2hldGhlciBjdHJsLXBvaW50ZXIgY2xpY2sgaXMgb24gcG9pbnQgb3IgbGluZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBBTkNIT1JfUE9JTlRfTElORV9TV0lUQ0hfVEhSRVNIT0xEOiBudW1iZXIgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byBkZWxldGUgYSBwb2ludCBvbiBwb2ludGVyIHVwIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRlbGV0ZU9uUG9pbnRlclVwOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBmbGF0IHRvIGFkZCBhIHBvaW50IG9uIHBvaW50ZXIgdXAgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkT25Qb2ludGVyVXA6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgbnVtYmVyIG9mIGFuY2hvcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYW5jaG9yc0xlbmd0aDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBwb2x5bGluZSBvYmplY3QsIHVzZWQgdG8gdHJpZ2dlciBhZGRpbmcvZGVsZXRpbmcgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFuY2hvcnNQb2x5bGluZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgQW5jaG9yc0VsZW1lbnRgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QgPSBudWxsLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yc0xlbmd0aCA9IHJlZ2lvbkRhdGEucG9pbnRzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIGNvbXBvbm5lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWRyYXcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVnaW9uRGF0YS5wb2ludHMgIT09IG51bGwgJiYgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucmVnaW9uRGF0YS5wb2ludHM7XHJcbiAgICAgICAgICAgIC8vIHJlYnVpbGQgYW5jaG9yc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbmNob3JzTGVuZ3RoICE9PSBwb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvcnMuZm9yRWFjaCgoYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRBbmNob3JzKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvcnNMZW5ndGggPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvcnNbaW5kZXhdLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHAueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBwLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50c0RhdGEgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNEYXRhLnB1c2gocC54LCBwLnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yc1BvbHlsaW5lLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNEYXRhLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9uIGFuY2hvcnMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZEFuY2hvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZFBvbHlsaW5lQW5jaG9ycygpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRQb2ludEFuY2hvcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9mIGFuY2hvciBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZFBvbHlsaW5lQW5jaG9ycygpIHtcclxuICAgICAgICBjb25zdCBwb2ludHNEYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHBvaW50c0RhdGEucHVzaChwLngsIHAueSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5jaG9yc1BvbHlsaW5lID0gdGhpcy5wYXBlci5wb2x5bGluZShwb2ludHNEYXRhKTtcclxuICAgICAgICB0aGlzLmFuY2hvcnNQb2x5bGluZS5hZGRDbGFzcyhcImFuY2hvckxpbmVTdHlsZVwiKTtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZUxpbmVUb0V2ZW50cyh0aGlzLmFuY2hvcnNQb2x5bGluZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5jaG9yc05vZGUuYWRkKHRoaXMuYW5jaG9yc1BvbHlsaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBhbiBhbmNob3IgdG8gZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIGFuY2hvciAtIFRoZSBhbmNob3IgdG8gd2lyZSB1cCB3aXRoIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN1YnNjcmliZUxpbmVUb0V2ZW50cyhhbmNob3I6IFNuYXAuRWxlbWVudCkge1xyXG4gICAgICAgIGFuY2hvci5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zyb3plbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ09yaWdpbiA9IG5ldyBQb2ludDJEKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRPblBvaW50ZXJVcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5kcmFnT3JpZ2luLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5kcmFnT3JpZ2luLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE9uUG9pbnRlclVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZWQgdGhlIGByZWdpb25EYXRhYCBiYXNlZCBvbiB0aGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi4gU2hvdWxkIGJlIHJlZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLlxyXG4gICAgICogQHBhcmFtIHAgLSBUaGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVJlZ2lvbihwOiBQb2ludDJEKSB7XHJcbiAgICAgICAgY29uc3QgcmQgPSB0aGlzLnJlZ2lvbkRhdGEuY29weSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID49IDAgJiYgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA8IHRoaXMucmVnaW9uRGF0YS5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJkLnNldFBvaW50KHAsIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCByZCwgQ2hhbmdlRXZlbnRUeXBlLk1PVklORyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJlbnRlciBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyRW50ZXIoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZGRPblBvaW50ZXJVcCAmJiB0aGlzLmFjdGl2ZUFuY2hvckluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hZGRDbGFzcyhcImFkZFwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYWRkQ2xhc3MoXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZU9uUG9pbnRlclVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkT25Qb2ludGVyVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJhZGRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlT25Qb2ludGVyVXAgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuZHJhZyhcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JEcmFnTW92ZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckRyYWdCZWdpbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckRyYWdFbmQuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25CZWdpbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBwb2ludGVybW92ZSBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyTW92ZShlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XHJcbiAgICAgICAgICAgIGxldCBkaXN0OiBudW1iZXIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBsZXQgbmVhcmVzdFBvaW50OiBQb2ludDJEID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHAuc3F1YXJlRGlzdGFuY2VUb1BvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChkIDwgZGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzd2FwVG9EZWxldGU6IGJvb2xlYW4gPSBkaXN0IDwgQW5jaG9yc0VsZW1lbnQuQU5DSE9SX1BPSU5UX0xJTkVfU1dJVENIX1RIUkVTSE9MRDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZE9uUG9pbnRlclVwICYmIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXggPCAwICYmICFzd2FwVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYWRkQ2xhc3MoXCJhZGRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHAueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHAueSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmxlbmd0aCA+IDIgfHwgc3dhcFRvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLnJlbW92ZUNsYXNzKFwiYWRkXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hZGRDbGFzcyhcImRlbGV0ZVwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogbmVhcmVzdFBvaW50LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBuZWFyZXN0UG9pbnQueSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlT25Qb2ludGVyVXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5yZW1vdmVDbGFzcyhcImRlbGV0ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5yZW1vdmVDbGFzcyhcImFkZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5kZWxldGVPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE9uUG9pbnRlclVwID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBwb2ludGVydXAgZXZlbnQgZm9yIHRoZSBnaG9zdCBhbmNob3IuXHJcbiAgICAgKiBAcGFyYW0gZSAtIFBvaW50ZXJFdmVudCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvbkdob3N0UG9pbnRlclVwKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMuZ2hvc3RBbmNob3Iubm9kZS5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xyXG5cclxuICAgICAgICBjb25zdCByZCA9IHRoaXMucmVnaW9uRGF0YS5jb3B5KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlbGV0ZU9uUG9pbnRlclVwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID49IDAgJiYgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA8IHRoaXMucmVnaW9uRGF0YS5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZC5wb2ludHM7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMuc3BsaWNlKHRoaXMuYWN0aXZlQW5jaG9ySW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmQuc2V0UG9pbnRzKHBvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZWxldGVPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE9uUG9pbnRlclVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJhZGRcIik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFkZE9uUG9pbnRlclVwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50MkQoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZC5wb2ludHM7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZWFyZXN0IHNlZ21lbnQgb2YgcG9seWxpbmVcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuZHJhZ09yaWdpbi5zcXVhcmVEaXN0YW5jZVRvTGluZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkIDwgZGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb2ludHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgcG9pbnQpO1xyXG4gICAgICAgICAgICByZC5zZXRQb2ludHMocG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlT25Qb2ludGVyVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmFkZENsYXNzKFwiZGVsZXRlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCByZCwgQ2hhbmdlRXZlbnRUeXBlLk1PVkVFTkQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWdpb25EYXRhXCI7XHJcblxyXG5pbXBvcnQgeyBJUmVnaW9uQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBEcmFnQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudC9EcmFnQ29tcG9uZW50XCI7XHJcblxyXG4vKipcclxuICogYERyYWdDb21wb25lbnRgIGZvciB0aGUgYFBvbHlnb25SZWdpb25gIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERyYWdFbGVtZW50IGV4dGVuZHMgRHJhZ0NvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYERyYWdFbGVtZW50YC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QgPSBudWxsLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MpO1xyXG5cclxuICAgICAgICB0aGlzLmRyYWdOb2RlID0gcGFwZXIucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZHJhZ05vZGUuYWRkQ2xhc3MoXCJkcmFnUmVjdFN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuZHJhZ05vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRHJhZ0V2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyB0aGUgY29tcG9ubmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZHJhdygpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTm9kZS5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuaW1wb3J0IHsgVGFnc0Rlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vQ29yZS9UYWdzRGVzY3JpcHRvclwiO1xyXG5cclxuaW1wb3J0IHsgSVRhZ3NVcGRhdGVPcHRpb25zIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JVGFnc1VwZGF0ZU9wdGlvbnNcIjtcclxuaW1wb3J0IHsgQ2hhbmdlRXZlbnRUeXBlLCBJUmVnaW9uQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBSZWdpb25Db21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L1JlZ2lvbkNvbXBvbmVudFwiO1xyXG5pbXBvcnQgeyBSZWdpb24gfSBmcm9tIFwiLi4vUmVnaW9uXCI7XHJcbmltcG9ydCB7IEFuY2hvcnNFbGVtZW50IH0gZnJvbSBcIi4vQW5jaG9yc0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgRHJhZ0VsZW1lbnQgfSBmcm9tIFwiLi9EcmFnRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBUYWdzRWxlbWVudCB9IGZyb20gXCIuL1RhZ3NFbGVtZW50XCI7XHJcblxyXG4vKipcclxuICogVGhlIHBvbHlnb24tdHlwZSByZWdpb24gY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9seWdvblJlZ2lvbiBleHRlbmRzIFJlZ2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgQW5jaG9yc0VsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYW5jaG9yTm9kZTogQW5jaG9yc0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIERyYWdFbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRyYWdOb2RlOiBEcmFnRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgVGFnc0VsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdGFnc05vZGU6IFRhZ3NFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB0b29sdGlwIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG9vbFRpcDogU25hcC5GcmFnbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJvdW5kaW5nIHJlY3RzIGZvciB0aGUgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcGVyUmVjdHM6IHsgaG9zdDogUmVjdCwgYWN0dWFsOiBSZWN0IH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgUG9seWdvblJlZ2lvbmAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSByZWdpb24gYGlkYCB1c2VkIHRvIGlkZW50aWZ5IHJlZ2lvbnMgaW4gYFJlZ2lvbnNNYW5hZ2VyYC5cclxuICAgICAqIEBwYXJhbSB0YWdzRGVzY3JpcHRvciAtIFRoZSBkZXNjcmlwdG9yIG9mIHJlZ2lvbiB0YWdzLlxyXG4gICAgICogQHBhcmFtIHRhZ3NVcGRhdGVPcHRpb25zIC0gVGhlIGRyYXdpbmcgb3B0aW9ucyBmb3IgdGFncy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIHBhcGVyUmVjdDogUmVjdCA9IG51bGwsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcyxcclxuICAgICAgICAgICAgICAgIGlkOiBzdHJpbmcsIHRhZ3NEZXNjcmlwdG9yOiBUYWdzRGVzY3JpcHRvciwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MsIGlkLCB0YWdzRGVzY3JpcHRvciwgdGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAocGFwZXJSZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFwZXJSZWN0cyA9IHtcclxuICAgICAgICAgICAgICAgIGFjdHVhbDogbmV3IFJlY3QocGFwZXJSZWN0LndpZHRoIC0gcmVnaW9uRGF0YS53aWR0aCwgcGFwZXJSZWN0LmhlaWdodCAtIHJlZ2lvbkRhdGEuaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgIGhvc3Q6IHBhcGVyUmVjdCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRPbihwYXBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZm90IGludGVybmFsIGNvbXBvbmVudHMuXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IC0gUmVmZXJlbmNlIHRvIHRoZSBVSSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIE5ldyBSZWdpb25EYXRhIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIE5ldyBzdGF0ZSBvZiB0aGUgcmVnaW9uLlxyXG4gICAgICogQHBhcmFtIG11bHRpU2VsZWN0aW9uIC0gRmxhZyBmb3IgbXVsdGlzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkNoYW5nZShjb21wb25lbnQ6IFJlZ2lvbkNvbXBvbmVudCwgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSwgc3RhdGU6IENoYW5nZUV2ZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aVNlbGVjdGlvbjogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5wYXBlclJlY3RzLmFjdHVhbC5yZXNpemUodGhpcy5wYXBlclJlY3RzLmhvc3Qud2lkdGggLSByZWdpb25EYXRhLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFwZXJSZWN0cy5ob3N0LmhlaWdodCAtIHJlZ2lvbkRhdGEuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgc3VwZXIub25DaGFuZ2UoY29tcG9uZW50LCByZWdpb25EYXRhLCBzdGF0ZSwgbXVsdGlTZWxlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyByZWdpb24gdGFncy5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIG5ldyB0YWdzIGRlc2NyaXB0b3Igb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdGFncyBkcmF3aW5nIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVUYWdzKHRhZ3M6IFRhZ3NEZXNjcmlwdG9yLCBvcHRpb25zPzogSVRhZ3NVcGRhdGVPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlVGFncyh0YWdzLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnRhZ3NOb2RlLnVwZGF0ZVRhZ3ModGFncywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5ub2RlLnNlbGVjdChcInRpdGxlXCIpLm5vZGUuaW5uZXJIVE1MID0gKHRhZ3MgIT09IG51bGwpID8gdGFncy50b1N0cmluZygpIDogXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhlIHJlZ2lvbiB0byBzcGVjaWZpZWQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgbmV3IHJlZ2lvbiB3aWR0aC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IHJlZ2lvbiBoZWlnaHQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnBhcGVyUmVjdHMuYWN0dWFsLnJlc2l6ZSh0aGlzLnBhcGVyUmVjdHMuaG9zdC53aWR0aCAtIHdpZHRoLCB0aGlzLnBhcGVyUmVjdHMuaG9zdC5oZWlnaHQgLSBoZWlnaHQpO1xyXG4gICAgICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIFVJIG9mIHRoZSByZWdpb24gY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBlbGVtZW50IHRvIGRyYXcgb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRPbihwYXBlcjogU25hcC5QYXBlcikge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJyZWdpb25TdHlsZVwiKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3ModGhpcy5zdHlsZUlEKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0ge1xyXG4gICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBvbk1hbmlwdWxhdGlvbkJlZ2luOiB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4uYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgb25NYW5pcHVsYXRpb25FbmQ6IHRoaXMub25NYW5pcHVsYXRpb25FbmQuYmluZCh0aGlzKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmRyYWdOb2RlID0gbmV3IERyYWdFbGVtZW50KHBhcGVyLCB0aGlzLnBhcGVyUmVjdHMuYWN0dWFsLCB0aGlzLnJlZ2lvbkRhdGEsIGNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy50YWdzTm9kZSA9IG5ldyBUYWdzRWxlbWVudChwYXBlciwgdGhpcy5wYXBlclJlY3QsIHRoaXMucmVnaW9uRGF0YSwgdGhpcy50YWdzLCB0aGlzLnN0eWxlSUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlU2hlZXQsIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG5ldyBBbmNob3JzRWxlbWVudChwYXBlciwgdGhpcy5wYXBlclJlY3QsIHRoaXMucmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy50b29sVGlwID0gU25hcC5wYXJzZShgPHRpdGxlPiR7KHRoaXMudGFncyAhPT0gbnVsbCkgPyB0aGlzLnRhZ3MudG9TdHJpbmcoKSA6IFwiXCJ9PC90aXRsZT5gKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kKHRoaXMudG9vbFRpcCBhcyBhbnkpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuZHJhZ05vZGUubm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLnRhZ3NOb2RlLm5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5hbmNob3JOb2RlLm5vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLlVJLnB1c2godGhpcy50YWdzTm9kZSwgdGhpcy5kcmFnTm9kZSwgdGhpcy5hbmNob3JOb2RlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5pbXBvcnQgeyBUYWdzRGVzY3JpcHRvciB9IGZyb20gXCIuLi8uLi9Db3JlL1RhZ3NEZXNjcmlwdG9yXCI7XHJcblxyXG5pbXBvcnQgeyBJVGFnc1VwZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lUYWdzVXBkYXRlT3B0aW9uc1wiO1xyXG5cclxuaW1wb3J0IHsgVGFnc0NvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvVGFnc0NvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIGBUYWdzQ29tcG9uZW50YCBmb3IgdGhlIGBQb2x5Z29uUmVnaW9uYCBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYWdzRWxlbWVudCBleHRlbmRzIFRhZ3NDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0ICh2aXN1YWwpIHJhZGl1cyBmb3IgcHJpbWFyeSB0YWcgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9QUklNQVJZX1RBR19SQURJVVM6IG51bWJlciA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0ICh2aXN1YWwpIHNpemUgZm9yIHNlY29uZGFyeSB0YWcgYm94ZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9TRUNPTkRBUllfVEFHX1NJWkU6IG51bWJlciA9IDY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0ICh2aXN1YWwpIHZlcnRpY2FsIHNoaWZ0IGZvciBzZWNvbmRhcnkgdGFnIGJveGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIERFRkFVTFRfU0VDT05EQVJZX1RBR19EWTogbnVtYmVyID0gNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgYm91bmRpbmcgcmVjdCAoYmFja2dyb3VuZCkgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByaW1hcnlUYWdCb3VuZFJlY3Q6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcG9seWdvbiBsaW5lIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwcmltYXJ5VGFnUG9seWdvbjogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGFnc0VsZW1lbnRgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIGBUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IHByZXNlbnRpbmcgY29sb3JzIGFuZCBuYW1lcyBmb3IgcmVnaW9uIHRhZ3MuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVJZCAtIFRoZSB1bmlxdWUgY3NzIHN0eWxlIGlkIGZvciByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVTaGVldCAtIFRoZSByZWdlcmVuY2UgdG8gdGhlIHN0eWxlc2hlZXQgb2JqZWN0IGZvciBydWxlcyBpbnNlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdGFnc1VwZGF0ZU9wdGlvbnMgLSBUaGUgc2V0dGluZ3MgZm9yIHJlZHJhd2luZyB0YWdzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0LCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzOiBUYWdzRGVzY3JpcHRvcixcclxuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0cmluZywgc3R5bGVTaGVldDogQ1NTU3R5bGVTaGVldCwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCB0YWdzLCBzdHlsZUlkLCBzdHlsZVNoZWV0LCB0YWdzVXBkYXRlT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRPbihwYXBlciwgdGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjb21wb25uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50c0RhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgcG9pbnRzRGF0YS5wdXNoKHAueCwgcC55KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IFRhZ3NFbGVtZW50LkRFRkFVTFRfU0VDT05EQVJZX1RBR19TSVpFO1xyXG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3QgY3kgPSB0aGlzLnkgLSBzaXplIC0gNTtcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlUYWdQb2x5Z29uLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNEYXRhLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU2Vjb25kYXJ5IFRhZ3NcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5VGFncyAmJiB0aGlzLnNlY29uZGFyeVRhZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5zZWNvbmRhcnlUYWdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFnID0gdGhpcy5zZWNvbmRhcnlUYWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSBjeCArICgyICogaSAtIGxlbmd0aCArIDAuNSkgKiBzaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGFnLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjeSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdHMgc3R5bGUgbWFwcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGluaXRTdHlsZU1hcHModGFnczogVGFnc0Rlc2NyaXB0b3IpIHtcclxuICAgICAgICBpZiAodGFncyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGFncy5wcmltYXJ5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JTaGFkb3d9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJHt0YWdzLnByaW1hcnkuY29sb3JBY2NlbnR9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuc2VsZWN0ZWQuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnQm91bmRSZWN0U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9ySGlnaGxpZ2h0fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfTpob3ZlciAucHJpbWFyeVRhZ0JvdW5kUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvckhpZ2hsaWdodH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdQb2x5Z29uU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yU2hhZG93fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICR7dGFncy5wcmltYXJ5LmNvbG9yUHVyZX07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH06aG92ZXIgLnByaW1hcnlUYWdQb2x5Z29uU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9ySGlnaGxpZ2h0fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICR7dGFncy5wcmltYXJ5LmNvbG9yUHVyZX07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS5zZWxlY3RlZC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdQb2x5Z29uU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9ySGlnaGxpZ2h0fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICR7dGFncy5wcmltYXJ5LmNvbG9yUHVyZX07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6JHt0YWdzLnByaW1hcnkuY29sb3JEYXJrfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvclB1cmV9YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH06aG92ZXIgLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6I2ZmZjtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGUuZ2hvc3RgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6dHJhbnNwYXJlbnQ7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTGlnaHRNYXAgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ0JvdW5kUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiBub25lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJHt0YWdzLnByaW1hcnkuY29sb3JBY2NlbnR9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnUG9seWdvblN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvck5vQ29sb3J9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJHt0YWdzLnByaW1hcnkuY29sb3JQdXJlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2Utd2lkdGg6IDFweDtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfTpob3ZlciAucHJpbWFyeVRhZ1BvbHlnb25TdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JIaWdobGlnaHR9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJHt0YWdzLnByaW1hcnkuY29sb3JQdXJlfTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLnNlbGVjdGVkLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvbHlnb25TdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JOb0NvbG9yfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICR7dGFncy5wcmltYXJ5LmNvbG9yUHVyZX07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6JHt0YWdzLnByaW1hcnkuY29sb3JEYXJrfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvclB1cmV9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS13aWR0aDogMXB4O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9OmhvdmVyIC5hbmNob3JTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlOiNmZmY7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlLmdob3N0YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOnRyYW5zcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS13aWR0aDogMHB4O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5zZWNvbmRhcnlUYWdTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgb3BhY2l0eTowLjI1O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTGlnaHRNYXAgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvbHlnb25TdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS5zZWxlY3RlZC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdQb2x5Z29uU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6IHZhcigtLWRlZmF1bHQtY29sb3ItdHJhbnNwYXJlbnQpO2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnQm91bmRSZWN0U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6IG5vbmU7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdQb2x5bGluZVN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2Utd2lkdGg6IDFweDtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZS13aWR0aDogMXB4O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5hbmNob3JTdHlsZS5naG9zdGAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlLXdpZHRoOiAwcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhZ3Muc2Vjb25kYXJ5ICE9PSBudWxsICYmIHRhZ3Muc2Vjb25kYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhZ3Muc2Vjb25kYXJ5LmZvckVhY2goKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuc2Vjb25kYXJ5VGFnU3R5bGUuc2Vjb25kYXJ5VGFnLSR7dGFnLm5hbWV9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZy5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUxpZ2h0TWFwLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHJlY3JlYXRlIHRhZyBsYWJlbHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZWJ1aWxkVGFnTGFiZWxzKCkge1xyXG4gICAgICAgIC8vIENsZWFyIHNlY29uZGFyeSB0YWdzIC0+IHJlZHJhdyBmcm9tIHNjcmF0Y2hcclxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnNlY29uZGFyeVRhZ3MpIHtcclxuICAgICAgICAgICAgdGFnLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MgPSBbXTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgdGFncyBhc3NpZ25lZFxyXG4gICAgICAgIGlmICh0aGlzLnRhZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFncy5wcmltYXJ5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy50YWdzLnByaW1hcnkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByaW1hcnkgVGFnXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNlY29uZGFyeSBUYWdzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3Muc2Vjb25kYXJ5ICYmIHRoaXMudGFncy5zZWNvbmRhcnkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy50YWdzLnNlY29uZGFyeS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhZyA9IHRoaXMudGFncy5zZWNvbmRhcnlbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBUYWdzRWxlbWVudC5ERUZBVUxUX1NFQ09OREFSWV9UQUdfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54ICsgdGhpcy5ib3VuZFJlY3Qud2lkdGggLyAyICsgKDIgKiBpIC0gbGVuZ3RoICsgMSkgKiBzIC0gcyAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIHMgLSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ2VsID0gdGhpcy5wYXBlci5yZWN0KHgsIHksIHMsIHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnZWwuYWRkQ2xhc3MoXCJzZWNvbmRhcnlUYWdTdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnZWwuYWRkQ2xhc3MoYHNlY29uZGFyeVRhZy0ke3N0YWcubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzTm9kZS5hZGQodGFnZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5VGFncy5wdXNoKHRhZ2VsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0YWcgbGFiZWxzXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIHRhZ3MgLSBUaGUgYFRhZ3NEZXNjcmlwdG9yYCBvYmplY3QgZGVmaW5pbmcgdGFncy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZE9uKHBhcGVyOiBTbmFwLlBhcGVyLCB0YWdzOiBUYWdzRGVzY3JpcHRvcikge1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ05vZGUgPSBwYXBlci5nKCk7XHJcblxyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdCA9IHBhcGVyLnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMuYm91bmRSZWN0LndpZHRoLCB0aGlzLmJvdW5kUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdC5hZGRDbGFzcyhcInByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgcG9pbnRzRGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVnaW9uRGF0YS5wb2ludHMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgICAgICBwb2ludHNEYXRhLnB1c2gocC54LCBwLnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ1BvbHlnb24gPSBwYXBlci5wb2x5Z29uKHBvaW50c0RhdGEpO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ1BvbHlnb24uYWRkQ2xhc3MoXCJwcmltYXJ5VGFnUG9seWdvblN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgcG9pbnRzRGF0YS5wdXNoKHAueCwgcC55KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnTm9kZS5hZGQodGhpcy5wcmltYXJ5VGFnQm91bmRSZWN0KTtcclxuICAgICAgICB0aGlzLnByaW1hcnlUYWdOb2RlLmFkZCh0aGlzLnByaW1hcnlUYWdQb2x5Z29uKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzTm9kZSA9IHBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3NOb2RlLmFkZENsYXNzKFwic2Vjb25kYXR5VGFnc0xheWVyXCIpO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5VGFncyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMucHJpbWFyeVRhZ05vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5zZWNvbmRhcnlUYWdzTm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdFN0eWxlTWFwcyh0YWdzKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRhZ3ModGFncywgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IENoYW5nZUV2ZW50VHlwZSwgSVJlZ2lvbkNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgQW5jaG9yc0NvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvQW5jaG9yc0NvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIGBBbmNob3JzQ29tcG9uZW50YCBmb3IgdGhlIGBQb2x5bGluZVJlZ2lvbmAgY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5jaG9yc0VsZW1lbnQgZXh0ZW5kcyBBbmNob3JzQ29tcG9uZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCB0aHJlc2hvbGQgZGlzdGFuY2UgdG8gZGVmaW5lIHdoZXRoZXIgY3RybC1wb2ludGVyIGNsaWNrIGlzIG9uIHBvaW50IG9yIGxpbmUuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgQU5DSE9SX1BPSU5UX0xJTkVfU1dJVENIX1RIUkVTSE9MRDogbnVtYmVyID0gNTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZsYWcgdG8gZGVsZXRlIGEgcG9pbnQgb24gcG9pbnRlciB1cCBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkZWxldGVPblBvaW50ZXJVcDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZmxhdCB0byBhZGQgYSBwb2ludCBvbiBwb2ludGVyIHVwIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZE9uUG9pbnRlclVwOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IG51bWJlciBvZiBhbmNob3JzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFuY2hvcnNMZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcG9seWxpbmUgb2JqZWN0LCB1c2VkIHRvIHRyaWdnZXIgYWRkaW5nL2RlbGV0aW5nIHBvaW50cy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhbmNob3JzUG9seWxpbmU6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYEFuY2hvcnNFbGVtZW50YCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIHBhcGVyUmVjdCAtIFRoZSBwYXJlbnQgYm91bmRpbmcgYm94IGZvciBjcmVhdGVkIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSByZWdpb25EYXRhIC0gVGhlIGBSZWdpb25EYXRhYCBvYmplY3Qgc2hhcmVkIGFjcm9zcyBjb21wb25lbnRzLiBVc2VkIGFsc28gZm9yIGluaXRpYWwgc2V0dXAuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIC0gVGhlIGV4dGVybmFsIGNhbGxiYWNrcyBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0ID0gbnVsbCwgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSwgY2FsbGJhY2tzOiBJUmVnaW9uQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIHBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLmFuY2hvcnNMZW5ndGggPSByZWdpb25EYXRhLnBvaW50cy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjb21wb25uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lvbkRhdGEucG9pbnRzICE9PSBudWxsICYmIHRoaXMucmVnaW9uRGF0YS5wb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnJlZ2lvbkRhdGEucG9pbnRzO1xyXG4gICAgICAgICAgICAvLyByZWJ1aWxkIGFuY2hvcnNcclxuICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9yc0xlbmd0aCAhPT0gcG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3JzLmZvckVhY2goKGFuY2hvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3JzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50QW5jaG9ycygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JzTGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uRGF0YS5wb2ludHMuZm9yRWFjaCgocCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3JzW2luZGV4XS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4OiBwLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogcC55LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwb2ludHNEYXRhID0gW107XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uRGF0YS5wb2ludHMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzRGF0YS5wdXNoKHAueCwgcC55KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcnNQb2x5bGluZS5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzRGF0YS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29sbGVjdGlvbiBvbiBhbmNob3JzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYnVpbGRBbmNob3JzKCkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRQb2x5bGluZUFuY2hvcnMoKTtcclxuICAgICAgICB0aGlzLmJ1aWxkUG9pbnRBbmNob3JzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFjb2xsZWN0aW9uIG9mIGFuY2hvciBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZFBvbHlsaW5lQW5jaG9ycygpIHtcclxuICAgICAgICBjb25zdCBwb2ludHNEYXRhID0gW107XHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHBvaW50c0RhdGEucHVzaChwLngsIHAueSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5jaG9yc1BvbHlsaW5lID0gdGhpcy5wYXBlci5wb2x5bGluZShwb2ludHNEYXRhKTtcclxuICAgICAgICB0aGlzLmFuY2hvcnNQb2x5bGluZS5hZGRDbGFzcyhcImFuY2hvckxpbmVTdHlsZVwiKTtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZUxpbmVUb0V2ZW50cyh0aGlzLmFuY2hvcnNQb2x5bGluZSk7XHJcblxyXG4gICAgICAgIHRoaXMuYW5jaG9yc05vZGUuYWRkKHRoaXMuYW5jaG9yc1BvbHlsaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBhbiBhbmNob3IgdG8gZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIGFuY2hvciAtIFRoZSBhbmNob3IgdG8gd2lyZSB1cCB3aXRoIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN1YnNjcmliZUxpbmVUb0V2ZW50cyhhbmNob3I6IFNuYXAuRWxlbWVudCkge1xyXG4gICAgICAgIGFuY2hvci5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zyb3plbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ09yaWdpbiA9IG5ldyBQb2ludDJEKGUub2Zmc2V0WCwgZS5vZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRPblBvaW50ZXJVcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5kcmFnT3JpZ2luLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeTogdGhpcy5kcmFnT3JpZ2luLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE9uUG9pbnRlclVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZWQgdGhlIGByZWdpb25EYXRhYCBiYXNlZCBvbiB0aGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi4gU2hvdWxkIGJlIHJlZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLlxyXG4gICAgICogQHBhcmFtIHAgLSBUaGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVJlZ2lvbihwOiBQb2ludDJEKSB7XHJcbiAgICAgICAgY29uc3QgcmQgPSB0aGlzLnJlZ2lvbkRhdGEuY29weSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID49IDAgJiYgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA8IHRoaXMucmVnaW9uRGF0YS5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJkLnNldFBvaW50KHAsIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCByZCwgQ2hhbmdlRXZlbnRUeXBlLk1PVklORyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJlbnRlciBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyRW50ZXIoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZGRPblBvaW50ZXJVcCAmJiB0aGlzLmFjdGl2ZUFuY2hvckluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hZGRDbGFzcyhcImFkZFwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYWRkQ2xhc3MoXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZU9uUG9pbnRlclVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkT25Qb2ludGVyVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJhZGRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlT25Qb2ludGVyVXAgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuZHJhZyhcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JEcmFnTW92ZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckRyYWdCZWdpbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICB0aGlzLmFuY2hvckRyYWdFbmQuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25CZWdpbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBwb2ludGVybW92ZSBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyTW92ZShlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XHJcbiAgICAgICAgICAgIGxldCBkaXN0OiBudW1iZXIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICBsZXQgbmVhcmVzdFBvaW50OiBQb2ludDJEID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwb2ludCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHAuc3F1YXJlRGlzdGFuY2VUb1BvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChkIDwgZGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzd2FwVG9EZWxldGU6IGJvb2xlYW4gPSBkaXN0IDwgQW5jaG9yc0VsZW1lbnQuQU5DSE9SX1BPSU5UX0xJTkVfU1dJVENIX1RIUkVTSE9MRDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZE9uUG9pbnRlclVwICYmIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXggPCAwICYmICFzd2FwVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IuYWRkQ2xhc3MoXCJhZGRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHAueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHAueSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmxlbmd0aCA+IDIgfHwgc3dhcFRvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLnJlbW92ZUNsYXNzKFwiYWRkXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5hZGRDbGFzcyhcImRlbGV0ZVwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQW5jaG9ySW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogbmVhcmVzdFBvaW50LngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBuZWFyZXN0UG9pbnQueSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlT25Qb2ludGVyVXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5yZW1vdmVDbGFzcyhcImRlbGV0ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5naG9zdEFuY2hvci5yZW1vdmVDbGFzcyhcImFkZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5kZWxldGVPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE9uUG9pbnRlclVwID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIHRoZSBwb2ludGVydXAgZXZlbnQgZm9yIHRoZSBnaG9zdCBhbmNob3IuXHJcbiAgICAgKiBAcGFyYW0gZSAtIFBvaW50ZXJFdmVudCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvbkdob3N0UG9pbnRlclVwKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHRoaXMuZ2hvc3RBbmNob3Iubm9kZS5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xyXG5cclxuICAgICAgICBjb25zdCByZCA9IHRoaXMucmVnaW9uRGF0YS5jb3B5KCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRlbGV0ZU9uUG9pbnRlclVwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID49IDAgJiYgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA8IHRoaXMucmVnaW9uRGF0YS5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZC5wb2ludHM7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMuc3BsaWNlKHRoaXMuYWN0aXZlQW5jaG9ySW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmQuc2V0UG9pbnRzKHBvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZWxldGVPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFkZE9uUG9pbnRlclVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoXCJhZGRcIik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFkZE9uUG9pbnRlclVwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50MkQoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSByZC5wb2ludHM7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZWFyZXN0IHNlZ21lbnQgb2YgcG9seWxpbmVcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuZHJhZ09yaWdpbi5zcXVhcmVEaXN0YW5jZVRvTGluZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkIDwgZGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb2ludHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgcG9pbnQpO1xyXG4gICAgICAgICAgICByZC5zZXRQb2ludHMocG9pbnRzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlT25Qb2ludGVyVXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hZGRPblBvaW50ZXJVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmFkZENsYXNzKFwiZGVsZXRlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLCByZCwgQ2hhbmdlRXZlbnRUeXBlLk1PVkVFTkQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWdpb25EYXRhXCI7XHJcblxyXG5pbXBvcnQgeyBJUmVnaW9uQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBEcmFnQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudC9EcmFnQ29tcG9uZW50XCI7XHJcblxyXG4vKipcclxuICogYERyYWdDb21wb25lbnRgIGZvciB0aGUgYFBvbHlsaW5lUmVnaW9uYCBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEcmFnRWxlbWVudCBleHRlbmRzIERyYWdDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBEcmFnRWxlbWVudGAuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIHBhcGVyUmVjdCAtIFRoZSBwYXJlbnQgYm91bmRpbmcgYm94IGZvciBjcmVhdGVkIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSByZWdpb25EYXRhIC0gVGhlIGBSZWdpb25EYXRhYCBvYmplY3Qgc2hhcmVkIGFjcm9zcyBjb21wb25lbnRzLiBVc2VkIGFsc28gZm9yIGluaXRpYWwgc2V0dXAuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIC0gVGhlIGV4dGVybmFsIGNhbGxiYWNrcyBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0ID0gbnVsbCwgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSwgY2FsbGJhY2tzOiBJUmVnaW9uQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIHBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy5kcmFnTm9kZSA9IHBhcGVyLnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmRyYWdOb2RlLmFkZENsYXNzKFwiZHJhZ1JlY3RTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmRyYWdOb2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0RyYWdFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhd3MgdGhlIGNvbXBvbm5lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWRyYXcoKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ05vZGUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWdpb25EYXRhXCI7XHJcbmltcG9ydCB7IFRhZ3NEZXNjcmlwdG9yIH0gZnJvbSBcIi4uLy4uL0NvcmUvVGFnc0Rlc2NyaXB0b3JcIjtcclxuXHJcbmltcG9ydCB7IElUYWdzVXBkYXRlT3B0aW9ucyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVRhZ3NVcGRhdGVPcHRpb25zXCI7XHJcbmltcG9ydCB7IENoYW5nZUV2ZW50VHlwZSwgSVJlZ2lvbkNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgUmVnaW9uQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudC9SZWdpb25Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgUmVnaW9uIH0gZnJvbSBcIi4uL1JlZ2lvblwiO1xyXG5pbXBvcnQgeyBBbmNob3JzRWxlbWVudCB9IGZyb20gXCIuL0FuY2hvcnNFbGVtZW50XCI7XHJcbmltcG9ydCB7IERyYWdFbGVtZW50IH0gZnJvbSBcIi4vRHJhZ0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgVGFnc0VsZW1lbnQgfSBmcm9tIFwiLi9UYWdzRWxlbWVudFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwb2x5bGluZS10eXBlIHJlZ2lvbiBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQb2x5bGluZVJlZ2lvbiBleHRlbmRzIFJlZ2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgQW5jaG9yc0VsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYW5jaG9yTm9kZTogQW5jaG9yc0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIERyYWdFbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRyYWdOb2RlOiBEcmFnRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgVGFnc0VsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdGFnc05vZGU6IFRhZ3NFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB0b29sdGlwIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdG9vbFRpcDogU25hcC5GcmFnbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJvdW5kaW5nIHJlY3RzIGZvciB0aGUgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcGVyUmVjdHM6IHsgaG9zdDogUmVjdCwgYWN0dWFsOiBSZWN0IH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgUG9seWxpbmVSZWdpb25gIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgcmVnaW9uIGBpZGAgdXNlZCB0byBpZGVudGlmeSByZWdpb25zIGluIGBSZWdpb25zTWFuYWdlcmAuXHJcbiAgICAgKiBAcGFyYW0gdGFnc0Rlc2NyaXB0b3IgLSBUaGUgZGVzY3JpcHRvciBvZiByZWdpb24gdGFncy5cclxuICAgICAqIEBwYXJhbSB0YWdzVXBkYXRlT3B0aW9ucyAtIFRoZSBkcmF3aW5nIG9wdGlvbnMgZm9yIHRhZ3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QgPSBudWxsLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3MsXHJcbiAgICAgICAgICAgICAgICBpZDogc3RyaW5nLCB0YWdzRGVzY3JpcHRvcjogVGFnc0Rlc2NyaXB0b3IsIHRhZ3NVcGRhdGVPcHRpb25zPzogSVRhZ3NVcGRhdGVPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIHBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgY2FsbGJhY2tzLCBpZCwgdGFnc0Rlc2NyaXB0b3IsIHRhZ3NVcGRhdGVPcHRpb25zKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcGVyUmVjdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcGVyUmVjdHMgPSB7XHJcbiAgICAgICAgICAgICAgICBhY3R1YWw6IG5ldyBSZWN0KHBhcGVyUmVjdC53aWR0aCAtIHJlZ2lvbkRhdGEud2lkdGgsIHBhcGVyUmVjdC5oZWlnaHQgLSByZWdpb25EYXRhLmhlaWdodCksXHJcbiAgICAgICAgICAgICAgICBob3N0OiBwYXBlclJlY3QsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJ1aWxkT24ocGFwZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvdCBpbnRlcm5hbCBjb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCAtIFJlZmVyZW5jZSB0byB0aGUgVUkgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBOZXcgUmVnaW9uRGF0YSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdGUgb2YgdGhlIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSBtdWx0aVNlbGVjdGlvbiAtIEZsYWcgZm9yIG11bHRpc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25DaGFuZ2UoY29tcG9uZW50OiBSZWdpb25Db21wb25lbnQsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHN0YXRlOiBDaGFuZ2VFdmVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlTZWxlY3Rpb246IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMucGFwZXJSZWN0cy5hY3R1YWwucmVzaXplKHRoaXMucGFwZXJSZWN0cy5ob3N0LndpZHRoIC0gcmVnaW9uRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcGVyUmVjdHMuaG9zdC5oZWlnaHQgLSByZWdpb25EYXRhLmhlaWdodCk7XHJcblxyXG4gICAgICAgIHN1cGVyLm9uQ2hhbmdlKGNvbXBvbmVudCwgcmVnaW9uRGF0YSwgc3RhdGUsIG11bHRpU2VsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgcmVnaW9uIHRhZ3MuXHJcbiAgICAgKiBAcGFyYW0gdGFncyAtIFRoZSBuZXcgdGFncyBkZXNjcmlwdG9yIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHRhZ3MgZHJhd2luZyBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlVGFncyh0YWdzOiBUYWdzRGVzY3JpcHRvciwgb3B0aW9ucz86IElUYWdzVXBkYXRlT3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZVRhZ3ModGFncywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy50YWdzTm9kZS51cGRhdGVUYWdzKHRhZ3MsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubm9kZS5zZWxlY3QoXCJ0aXRsZVwiKS5ub2RlLmlubmVySFRNTCA9ICh0YWdzICE9PSBudWxsKSA/IHRhZ3MudG9TdHJpbmcoKSA6IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSByZWdpb24gdG8gc3BlY2lmaWVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG5ldyByZWdpb24gd2lkdGguXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyByZWdpb24gaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5wYXBlclJlY3RzLmFjdHVhbC5yZXNpemUodGhpcy5wYXBlclJlY3RzLmhvc3Qud2lkdGggLSB3aWR0aCwgdGhpcy5wYXBlclJlY3RzLmhvc3QuaGVpZ2h0IC0gaGVpZ2h0KTtcclxuICAgICAgICBzdXBlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBVSSBvZiB0aGUgcmVnaW9uIGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgZWxlbWVudCB0byBkcmF3IG9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkT24ocGFwZXI6IFNuYXAuUGFwZXIpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBwYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwicmVnaW9uU3R5bGVcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKHRoaXMuc3R5bGVJRCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgb25NYW5pcHVsYXRpb25CZWdpbjogdGhpcy5vbk1hbmlwdWxhdGlvbkJlZ2luLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIG9uTWFuaXB1bGF0aW9uRW5kOiB0aGlzLm9uTWFuaXB1bGF0aW9uRW5kLmJpbmQodGhpcyksXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5kcmFnTm9kZSA9IG5ldyBEcmFnRWxlbWVudChwYXBlciwgdGhpcy5wYXBlclJlY3RzLmFjdHVhbCwgdGhpcy5yZWdpb25EYXRhLCBjYWxsYmFja3MpO1xyXG4gICAgICAgIHRoaXMudGFnc05vZGUgPSBuZXcgVGFnc0VsZW1lbnQocGFwZXIsIHRoaXMucGFwZXJSZWN0LCB0aGlzLnJlZ2lvbkRhdGEsIHRoaXMudGFncywgdGhpcy5zdHlsZUlELFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZVNoZWV0LCB0aGlzLnRhZ3NVcGRhdGVPcHRpb25zKTtcclxuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBuZXcgQW5jaG9yc0VsZW1lbnQocGFwZXIsIHRoaXMucGFwZXJSZWN0LCB0aGlzLnJlZ2lvbkRhdGEsIGNhbGxiYWNrcyk7XHJcblxyXG4gICAgICAgIHRoaXMudG9vbFRpcCA9IFNuYXAucGFyc2UoYDx0aXRsZT4keyh0aGlzLnRhZ3MgIT09IG51bGwpID8gdGhpcy50YWdzLnRvU3RyaW5nKCkgOiBcIlwifTwvdGl0bGU+YCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZCh0aGlzLnRvb2xUaXAgYXMgYW55KTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmRyYWdOb2RlLm5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy50YWdzTm9kZS5ub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuYW5jaG9yTm9kZS5ub2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5VSS5wdXNoKHRoaXMudGFnc05vZGUsIHRoaXMuZHJhZ05vZGUsIHRoaXMuYW5jaG9yTm9kZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuaW1wb3J0IHsgVGFnc0Rlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vQ29yZS9UYWdzRGVzY3JpcHRvclwiO1xyXG5cclxuaW1wb3J0IHsgSVRhZ3NVcGRhdGVPcHRpb25zIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JVGFnc1VwZGF0ZU9wdGlvbnNcIjtcclxuXHJcbmltcG9ydCB7IFRhZ3NDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L1RhZ3NDb21wb25lbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBgVGFnc0NvbXBvbmVudGAgZm9yIHRoZSBgUG9seWxpbmVSZWdpb25gIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRhZ3NFbGVtZW50IGV4dGVuZHMgVGFnc0NvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgKHZpc3VhbCkgcmFkaXVzIGZvciBwcmltYXJ5IHRhZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBERUZBVUxUX1BSSU1BUllfVEFHX1JBRElVUzogbnVtYmVyID0gMztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgKHZpc3VhbCkgc2l6ZSBmb3Igc2Vjb25kYXJ5IHRhZyBib3hlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBERUZBVUxUX1NFQ09OREFSWV9UQUdfU0laRTogbnVtYmVyID0gNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgKHZpc3VhbCkgdmVydGljYWwgc2hpZnQgZm9yIHNlY29uZGFyeSB0YWcgYm94ZXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgREVGQVVMVF9TRUNPTkRBUllfVEFHX0RZOiBudW1iZXIgPSA2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBib3VuZGluZyByZWN0IChiYWNrZ3JvdW5kKSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHJpbWFyeVRhZ0JvdW5kUmVjdDogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBwb2x5Z29uIGxpbmUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByaW1hcnlUYWdQb2x5bGluZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGFnc0VsZW1lbnRgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIGBUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IHByZXNlbnRpbmcgY29sb3JzIGFuZCBuYW1lcyBmb3IgcmVnaW9uIHRhZ3MuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVJZCAtIFRoZSB1bmlxdWUgY3NzIHN0eWxlIGlkIGZvciByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVTaGVldCAtIFRoZSByZWdlcmVuY2UgdG8gdGhlIHN0eWxlc2hlZXQgb2JqZWN0IGZvciBydWxlcyBpbnNlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdGFnc1VwZGF0ZU9wdGlvbnMgLSBUaGUgc2V0dGluZ3MgZm9yIHJlZHJhd2luZyB0YWdzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0LCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzOiBUYWdzRGVzY3JpcHRvciwgc3R5bGVJZDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldDogQ1NTU3R5bGVTaGVldCwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCB0YWdzLCBzdHlsZUlkLCBzdHlsZVNoZWV0LCB0YWdzVXBkYXRlT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRPbihwYXBlciwgdGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjb21wb25uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50c0RhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLnJlZ2lvbkRhdGEucG9pbnRzLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgcG9pbnRzRGF0YS5wdXNoKHAueCwgcC55KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IFRhZ3NFbGVtZW50LkRFRkFVTFRfU0VDT05EQVJZX1RBR19TSVpFO1xyXG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3QgY3kgPSB0aGlzLnkgLSBzaXplIC0gNTtcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByaW1hcnlUYWdQb2x5bGluZS5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogcG9pbnRzRGF0YS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlY29uZGFyeSBUYWdzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVRhZ3MgJiYgdGhpcy5zZWNvbmRhcnlUYWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuc2Vjb25kYXJ5VGFncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhZyA9IHRoaXMuc2Vjb25kYXJ5VGFnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gY3ggKyAoMiAqIGkgLSBsZW5ndGggKyAwLjUpICogc2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhZy5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRzIHN0eWxlIG1hcHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpbml0U3R5bGVNYXBzKHRhZ3M6IFRhZ3NEZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgaWYgKHRhZ3MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRhZ3MucHJpbWFyeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZU1hcCA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnQm91bmRSZWN0U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yU2hhZG93fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICR7dGFncy5wcmltYXJ5LmNvbG9yQWNjZW50fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLnNlbGVjdGVkLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ0JvdW5kUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvckhpZ2hsaWdodH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH06aG92ZXIgLnByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JIaWdobGlnaHR9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnUG9seWxpbmVTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlOiAke3RhZ3MucHJpbWFyeS5jb2xvclB1cmV9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5hbmNob3JTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlOiR7dGFncy5wcmltYXJ5LmNvbG9yRGFya307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JQdXJlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9OmhvdmVyIC5hbmNob3JTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlOiNmZmY7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlLmdob3N0YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOnRyYW5zcGFyZW50O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZUxpZ2h0TWFwID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogbm9uZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICR7dGFncy5wcmltYXJ5LmNvbG9yQWNjZW50fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvbHlsaW5lU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZTogJHt0YWdzLnByaW1hcnkuY29sb3JQdXJlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2Utd2lkdGg6IDFweDtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZToke3RhZ3MucHJpbWFyeS5jb2xvckRhcmt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yUHVyZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH06aG92ZXIgLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6I2ZmZjtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGUuZ2hvc3RgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6dHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAwcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLnNlY29uZGFyeVRhZ1N0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBvcGFjaXR5OjAuMjU7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYXAgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVMaWdodE1hcCA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnQm91bmRSZWN0U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6IG5vbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAke3RhZ3MucHJpbWFyeS5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogbm9uZTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1BvbHlsaW5lU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZS13aWR0aDogMXB4O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5hbmNob3JTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgc3Ryb2tlLXdpZHRoOiAxcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRhZ3Muc2Vjb25kYXJ5ICE9PSBudWxsICYmIHRhZ3Muc2Vjb25kYXJ5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhZ3Muc2Vjb25kYXJ5LmZvckVhY2goKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuc2Vjb25kYXJ5VGFnU3R5bGUuc2Vjb25kYXJ5VGFnLSR7dGFnLm5hbWV9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZy5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZUxpZ2h0TWFwLnB1c2gocnVsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIHJlY3JlYXRlIHRhZyBsYWJlbHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZWJ1aWxkVGFnTGFiZWxzKCkge1xyXG4gICAgICAgIC8vIENsZWFyIHNlY29uZGFyeSB0YWdzIC0+IHJlZHJhdyBmcm9tIHNjcmF0Y2hcclxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnNlY29uZGFyeVRhZ3MpIHtcclxuICAgICAgICAgICAgdGFnLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MgPSBbXTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgdGFncyBhc3NpZ25lZFxyXG4gICAgICAgIGlmICh0aGlzLnRhZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFncy5wcmltYXJ5ICE9PSB1bmRlZmluZWQgJiYgdGhpcy50YWdzLnByaW1hcnkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFByaW1hcnkgVGFnXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNlY29uZGFyeSBUYWdzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3Muc2Vjb25kYXJ5ICYmIHRoaXMudGFncy5zZWNvbmRhcnkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy50YWdzLnNlY29uZGFyeS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhZyA9IHRoaXMudGFncy5zZWNvbmRhcnlbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBUYWdzRWxlbWVudC5ERUZBVUxUX1NFQ09OREFSWV9UQUdfU0laRTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54ICsgdGhpcy5ib3VuZFJlY3Qud2lkdGggLyAyICsgKDIgKiBpIC0gbGVuZ3RoICsgMSkgKiBzIC0gcyAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIHMgLSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ2VsID0gdGhpcy5wYXBlci5yZWN0KHgsIHksIHMsIHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnZWwuYWRkQ2xhc3MoXCJzZWNvbmRhcnlUYWdTdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnZWwuYWRkQ2xhc3MoYHNlY29uZGFyeVRhZy0ke3N0YWcubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzTm9kZS5hZGQodGFnZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5VGFncy5wdXNoKHRhZ2VsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0YWcgbGFiZWxzXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIHRhZ3MgLSBUaGUgYFRhZ3NEZXNjcmlwdG9yYCBvYmplY3QgZGVmaW5pbmcgdGFncy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZE9uKHBhcGVyOiBTbmFwLlBhcGVyLCB0YWdzOiBUYWdzRGVzY3JpcHRvcikge1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ05vZGUgPSBwYXBlci5nKCk7XHJcblxyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdCA9IHBhcGVyLnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMuYm91bmRSZWN0LndpZHRoLCB0aGlzLmJvdW5kUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdC5hZGRDbGFzcyhcInByaW1hcnlUYWdCb3VuZFJlY3RTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgcG9pbnRzRGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVnaW9uRGF0YS5wb2ludHMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgICAgICBwb2ludHNEYXRhLnB1c2gocC54LCBwLnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ1BvbHlsaW5lID0gcGFwZXIucG9seWxpbmUocG9pbnRzRGF0YSk7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnUG9seWxpbmUuYWRkQ2xhc3MoXCJwcmltYXJ5VGFnUG9seWxpbmVTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHBvaW50c0RhdGEucHVzaChwLngsIHAueSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ05vZGUuYWRkKHRoaXMucHJpbWFyeVRhZ0JvdW5kUmVjdCk7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnTm9kZS5hZGQodGhpcy5wcmltYXJ5VGFnUG9seWxpbmUpO1xyXG5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3NOb2RlID0gcGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5VGFnc05vZGUuYWRkQ2xhc3MoXCJzZWNvbmRhdHlUYWdzTGF5ZXJcIik7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5wcmltYXJ5VGFnTm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLnNlY29uZGFyeVRhZ3NOb2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0U3R5bGVNYXBzKHRhZ3MpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGFncyh0YWdzLCB0aGlzLnRhZ3NVcGRhdGVPcHRpb25zKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQb2ludDJEIH0gZnJvbSBcIi4uLy4uL0NvcmUvUG9pbnQyRFwiO1xyXG5pbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5cclxuaW1wb3J0IHsgQ2hhbmdlRXZlbnRUeXBlLCBJUmVnaW9uQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBBbmNob3JzQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudC9BbmNob3JzQ29tcG9uZW50XCI7XHJcblxyXG4vKipcclxuICogYEFuY2hvcnNDb21wb25lbnRgIGZvciB0aGUgYFJlY3RSZWdpb25gIGNsYXNzLlxyXG4gKiBAdG9kbyBDdXJyZW50IGltcGxlbWVudGF0aW9ucyBvZiBib25lcyByZXVzZXMgZXhpc3RpbmcgYXBycm9hY2ggd2l0aCBhbmNob3IgaW5kZXhcclxuICogYnkgdXNpbmcgbmVnYXRpdmUgaW5kZXhlcyBhbmQgbWFudWFsbHkgY29ycmVjdGluZyB0aGVtIHRvIGFjdHVhbCBpbmRleGVzLlxyXG4gKiBJdCBzZWVtcyBsaWtlIGl0IHNob3VsZCBiZSByZWZhY3RvcmVkIHNvbWUgaG93LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFuY2hvcnNFbGVtZW50IGV4dGVuZHMgQW5jaG9yc0NvbXBvbmVudCB7XHJcbiAgICBwcml2YXRlIGFuY2hvclBvaW50U3R5bGVzOiBzdHJpbmdbXTtcclxuICAgIHByaXZhdGUgYW5jaG9yQm9uZVN0eWxlczogc3RyaW5nW107XHJcblxyXG4gICAgcHJpdmF0ZSBib25lVGhpY2tuZXNzO1xyXG4gICAgcHJpdmF0ZSBhbmNob3JCb25lczogU25hcC5FbGVtZW50W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBBbmNob3JzRWxlbWVudGAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIHBhcGVyUmVjdDogUmVjdCA9IG51bGwsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcykge1xyXG4gICAgICAgIHN1cGVyKHBhcGVyLCBwYXBlclJlY3QsIHJlZ2lvbkRhdGEsIGNhbGxiYWNrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSB2aXN1YWwgb24gdGhlIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZHJhdygpIHtcclxuICAgICAgICBzdXBlci5yZWRyYXcoKTtcclxuXHJcbiAgICAgICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gW3RoaXMucmVnaW9uRGF0YS54LCB0aGlzLnJlZ2lvbkRhdGEueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpb25EYXRhLndpZHRoLCB0aGlzLnJlZ2lvbkRhdGEuaGVpZ2h0XTtcclxuICAgICAgICBjb25zdCBbdEJvbmUsIHJCb25lLCBiQm9uZSwgbEJvbmVdID0gdGhpcy5hbmNob3JCb25lcztcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRCb25lLmF0dHIoe3gsIHk6IHkgLSB0aGlzLmJvbmVUaGlja25lc3MgLyAyLCB3aWR0aCwgaGVpZ2h0OiB0aGlzLmJvbmVUaGlja25lc3MgfSk7XHJcbiAgICAgICAgICAgIHJCb25lLmF0dHIoe3g6IHggKyB3aWR0aCAtIHRoaXMuYm9uZVRoaWNrbmVzcyAvIDIsIHksIHdpZHRoOiB0aGlzLmJvbmVUaGlja25lc3MsIGhlaWdodCB9KTtcclxuICAgICAgICAgICAgYkJvbmUuYXR0cih7eCwgeTogeSArIGhlaWdodCAtIHRoaXMuYm9uZVRoaWNrbmVzcyAvIDIsIHdpZHRoLCBoZWlnaHQ6IHRoaXMuYm9uZVRoaWNrbmVzcyB9KTtcclxuICAgICAgICAgICAgbEJvbmUuYXR0cih7eDogeCAtIHRoaXMuYm9uZVRoaWNrbmVzcyAvIDIsIHksIHdpZHRoOiB0aGlzLmJvbmVUaGlja25lc3MsIGhlaWdodCB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb2xsZWN0aW9uIG9uIGFuY2hvcnMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZEFuY2hvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZEJvbmVBbmNob3JzKCk7XHJcbiAgICAgICAgdGhpcy5idWlsZFBvaW50QW5jaG9ycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBjb2xsZWN0aW9uIG9mIGFuY2hvciBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZFBvaW50QW5jaG9ycygpIHtcclxuICAgICAgICB0aGlzLmFuY2hvclBvaW50U3R5bGVzID0gW1wiVExcIiwgXCJUUlwiLCBcIkJSXCIsIFwiQkxcIl07XHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhLnBvaW50cy5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5jcmVhdGVBbmNob3IodGhpcy5wYXBlciwgcG9pbnQueCwgcG9pbnQueSwgdGhpcy5hbmNob3JQb2ludFN0eWxlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcnMucHVzaChhbmNob3IpO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcnNOb2RlLmFkZChhbmNob3IpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVBbmNob3JUb0V2ZW50cyhhbmNob3IsIGluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgY29sbGVjdGlvbiBvZiBhbmNob3IgYm9uZXMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBidWlsZEJvbmVBbmNob3JzKCkge1xyXG4gICAgICAgIHRoaXMuYW5jaG9yQm9uZVN0eWxlcyA9IFtcIlRcIiwgXCJSXCIsIFwiQlwiLCBcIkxcIl07XHJcbiAgICAgICAgdGhpcy5hbmNob3JCb25lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYm9uZVRoaWNrbmVzcyA9IEFuY2hvcnNDb21wb25lbnQuREVGQVVMVF9HSE9TVF9BTkNIT1JfUkFESVVTO1xyXG5cclxuICAgICAgICBjb25zdCBbeCwgeSwgdywgaF0gPSBbdGhpcy5yZWdpb25EYXRhLngsIHRoaXMucmVnaW9uRGF0YS55LCB0aGlzLnJlZ2lvbkRhdGEud2lkdGgsIHRoaXMucmVnaW9uRGF0YS5oZWlnaHRdO1xyXG5cclxuICAgICAgICBjb25zdCB0Qm9uZSA9IHRoaXMuY3JlYXRlQW5jaG9yQm9uZSh0aGlzLnBhcGVyLCB4LCB5LCB3LCAwLCBcIlRcIiwgdGhpcy5ib25lVGhpY2tuZXNzKTtcclxuICAgICAgICBjb25zdCByQm9uZSA9IHRoaXMuY3JlYXRlQW5jaG9yQm9uZSh0aGlzLnBhcGVyLCB4ICsgdywgeSwgMCwgaCwgXCJSXCIsIHRoaXMuYm9uZVRoaWNrbmVzcyk7XHJcbiAgICAgICAgY29uc3QgYkJvbmUgPSB0aGlzLmNyZWF0ZUFuY2hvckJvbmUodGhpcy5wYXBlciwgeCwgeSArIGgsIHcsIDAsIFwiQlwiLCB0aGlzLmJvbmVUaGlja25lc3MpO1xyXG4gICAgICAgIGNvbnN0IGxCb25lID0gdGhpcy5jcmVhdGVBbmNob3JCb25lKHRoaXMucGFwZXIsIHgsIHksIDAsIGgsIFwiTFwiLCB0aGlzLmJvbmVUaGlja25lc3MpO1xyXG5cclxuICAgICAgICBjb25zdCBib25lcyA9IFt0Qm9uZSwgckJvbmUsIGJCb25lLCBsQm9uZV07XHJcbiAgICAgICAgdGhpcy5hbmNob3JCb25lcy5wdXNoKC4uLmJvbmVzKTtcclxuICAgICAgICBib25lcy5mb3JFYWNoKChib25lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvcnNOb2RlLmFkZChib25lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGFscmVhZHkgZXhpc3RpbmcgaW5mcmFzdHJ1Y3R1cmUgZm9yIGluZGV4ZXNcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVBbmNob3JCb25lVG9FdmVudHMoYm9uZSwgLSAoaW5kZXggKyAxKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IGFuY2hvciBib25lLlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSB4IC0gVGhlIGB4YC1jb29yZGluYXRlIG9mIHRoZSBhY25ob3IgYm9uZS5cclxuICAgICAqIEBwYXJhbSB5IC0gVGhlIGB5YC1jb29yZGluYXRlIG9mIHRoZSBhbmNob3IgYm9uZS5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBgd2lkdGhgIG9mIHRoZSBhbmNob3IgYm9uZS5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgYGhlaWdodGAgb2YgdGhlIGFuY2hvciBib25lLlxyXG4gICAgICogQHBhcmFtIHN0eWxlIC0gQWRkaXRpb25hbCBjc3Mgc3R5bGUgY2xhc3MgdG8gYmUgYXBwbGllZC5cclxuICAgICAqIEBwYXJhbSB0aGlja25lc3MgLSBUaGUgYHRoaWNrbmVzc2Agb2YgdGhlIGJvbmUgKGFjdGl2YXRpb24gYXJlYSkuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVBbmNob3JCb25lKHBhcGVyOiBTbmFwLlBhcGVyLCB4OiBudW1iZXIsIHk6IG51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBzdHlsZT86IHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzczogbnVtYmVyID0gQW5jaG9yc0NvbXBvbmVudC5ERUZBVUxUX0dIT1NUX0FOQ0hPUl9SQURJVVMpOiBTbmFwLkVsZW1lbnQge1xyXG4gICAgICAgIGxldCBib25lOiBTbmFwLkVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGJvbmUgPSBwYXBlci5yZWN0KHggLSB0aGlja25lc3MgLyAyLCB5LCB0aGlja25lc3MsIGhlaWdodCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgYm9uZSA9IHBhcGVyLnJlY3QoeCwgeSAtIHRoaWNrbmVzcyAvIDIsIHdpZHRoLCB0aGlja25lc3MpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmVjdCBib25lcyB0aGF0IGFyZSBuZWl0aGVyIHZlcnRpY2FsIG9yIGhvcml6b250YWwgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJvbmUuYWRkQ2xhc3MoXCJhbmNob3JCb25lU3R5bGVcIik7XHJcblxyXG4gICAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkICYmIHN0eWxlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGJvbmUuYWRkQ2xhc3Moc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYm9uZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGByZWdpb25EYXRhYCBiYXNlZCBvbiB0aGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi4gU2hvdWxkIGJlIHJlZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLlxyXG4gICAgICogQHBhcmFtIHAgLSBUaGUgbmV3IGdob3N0IGFuY2hvciBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVJlZ2lvbihwOiBQb2ludDJEKSB7XHJcbiAgICAgICAgbGV0IHgxOiBudW1iZXIgPSBwLng7XHJcbiAgICAgICAgbGV0IHkxOiBudW1iZXIgPSBwLnk7XHJcbiAgICAgICAgbGV0IHgyOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHkyOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IGZsaXBYOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGZsaXBZOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCBhY3RpdmVBbmNob3IgPSB0aGlzLmdldEFjdGl2ZUFuY2hvcigpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGFjdGl2ZUFuY2hvcikge1xyXG4gICAgICAgICAgICBjYXNlIFwiVExcIjoge1xyXG4gICAgICAgICAgICAgICAgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGZsaXBYID0geDIgPCB4MTtcclxuICAgICAgICAgICAgICAgIGZsaXBZID0geTIgPCB5MTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJUUlwiOiB7XHJcbiAgICAgICAgICAgICAgICB4MiA9IHRoaXMueDtcclxuICAgICAgICAgICAgICAgIHkyID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBmbGlwWCA9IHgxIDwgeDI7XHJcbiAgICAgICAgICAgICAgICBmbGlwWSA9IHkyIDwgeTE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiQkxcIjoge1xyXG4gICAgICAgICAgICAgICAgeTIgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICB4MiA9IHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBmbGlwWCA9IHgyIDwgeDE7XHJcbiAgICAgICAgICAgICAgICBmbGlwWSA9IHkxIDwgeTI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiQlJcIjoge1xyXG4gICAgICAgICAgICAgICAgeDIgPSB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICB5MiA9IHRoaXMueTtcclxuICAgICAgICAgICAgICAgIGZsaXBYID0geDEgPCB4MjtcclxuICAgICAgICAgICAgICAgIGZsaXBZID0geTEgPCB5MjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJUXCI6IHtcclxuICAgICAgICAgICAgICAgIHgxID0gdGhpcy54O1xyXG4gICAgICAgICAgICAgICAgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGZsaXBZID0geTEgPiB5MjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJSXCI6IHtcclxuICAgICAgICAgICAgICAgIHgyID0gdGhpcy54O1xyXG4gICAgICAgICAgICAgICAgeTEgPSB0aGlzLnk7XHJcbiAgICAgICAgICAgICAgICB5MiA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZmxpcFggPSB4MiA+IHgxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcIkJcIjoge1xyXG4gICAgICAgICAgICAgICAgeDEgPSB0aGlzLng7XHJcbiAgICAgICAgICAgICAgICB4MiA9IHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB5MiA9IHRoaXMueTtcclxuICAgICAgICAgICAgICAgIGZsaXBZID0geTEgPCB5MjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJMXCI6IHtcclxuICAgICAgICAgICAgICAgIHgyID0gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIHkxID0gdGhpcy55O1xyXG4gICAgICAgICAgICAgICAgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIGZsaXBYID0geDEgPiB4MjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbmV3QUE6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUFuY2hvciAhPT0gXCJcIiAmJiBhY3RpdmVBbmNob3IubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIG5ld0FBICs9IChhY3RpdmVBbmNob3JbMF0gPT09IFwiVFwiKSA/IChmbGlwWSA/IFwiQlwiIDogXCJUXCIpIDogKGZsaXBZID8gXCJUXCIgOiBcIkJcIik7XHJcbiAgICAgICAgICAgIG5ld0FBICs9IChhY3RpdmVBbmNob3JbMV0gPT09IFwiTFwiKSA/IChmbGlwWCA/IFwiUlwiIDogXCJMXCIpIDogKGZsaXBYID8gXCJMXCIgOiBcIlJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhY3RpdmVBbmNob3IgIT09IFwiXCIgJiYgYWN0aXZlQW5jaG9yLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAoZmxpcFgpIHtcclxuICAgICAgICAgICAgICAgIG5ld0FBID0gKGFjdGl2ZUFuY2hvciA9PT0gXCJSXCIpID8gXCJMXCIgOiBcIlJcIjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmbGlwWSkge1xyXG4gICAgICAgICAgICAgICAgbmV3QUEgPSAoYWN0aXZlQW5jaG9yID09PSBcIlRcIikgPyBcIkJcIiA6IFwiVFwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3QUEgPSBhY3RpdmVBbmNob3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhY3RpdmVBbmNob3IgIT09IG5ld0FBKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RBbmNob3IucmVtb3ZlQ2xhc3MoYWN0aXZlQW5jaG9yKTtcclxuICAgICAgICAgICAgaWYgKG5ld0FBLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA9IHRoaXMuYW5jaG9yUG9pbnRTdHlsZXMuaW5kZXhPZihuZXdBQSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID0gLSAodGhpcy5hbmNob3JCb25lU3R5bGVzLmluZGV4T2YobmV3QUEpICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFjdGl2ZUFuY2hvciA9IG5ld0FBO1xyXG4gICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmFkZENsYXNzKG5ld0FBKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHAxID0gbmV3IFBvaW50MkQoTWF0aC5taW4oeDEsIHgyKSwgTWF0aC5taW4oeTEsIHkyKSkuYm91bmRUb1JlY3QodGhpcy5wYXBlclJlY3QpO1xyXG4gICAgICAgIGNvbnN0IHAyID0gbmV3IFBvaW50MkQoTWF0aC5tYXgoeDEsIHgyKSwgTWF0aC5tYXgoeTEsIHkyKSkuYm91bmRUb1JlY3QodGhpcy5wYXBlclJlY3QpO1xyXG5cclxuICAgICAgICBjb25zdCByZCA9IHRoaXMucmVnaW9uRGF0YS5jb3B5KCk7XHJcbiAgICAgICAgcmQuc2V0UG9pbnRzKFtwMSwgbmV3IFBvaW50MkQocDIueCwgcDEueSksIHAyLCBuZXcgUG9pbnQyRChwMS54LCBwMi55KV0pO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMsIHJkLCBDaGFuZ2VFdmVudFR5cGUuTU9WSU5HKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGZvciB0aGUgcG9pbnRlcmVudGVyIGV2ZW50IGZvciB0aGUgZ2hvc3QgYW5jaG9yLlxyXG4gICAgICogQHBhcmFtIGUgLSBQb2ludGVyRXZlbnQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25HaG9zdFBvaW50ZXJFbnRlcihlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmFkZENsYXNzKHRoaXMuZ2V0QWN0aXZlQW5jaG9yKCkpO1xyXG4gICAgICAgIHN1cGVyLm9uR2hvc3RQb2ludGVyRW50ZXIoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgdGhlIHBvaW50ZXJsZWF2ZSBldmVudCBmb3IgdGhlIGdob3N0IGFuY2hvci5cclxuICAgICAqIEBwYXJhbSBlIC0gUG9pbnRlckV2ZW50IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uR2hvc3RQb2ludGVyTGVhdmUoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5naG9zdEFuY2hvci5yZW1vdmVDbGFzcyh0aGlzLmdldEFjdGl2ZUFuY2hvcigpKTtcclxuICAgICAgICBzdXBlci5vbkdob3N0UG9pbnRlckxlYXZlKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIHN1YnNjcmliZSBhbmNob3IgdG8gYWN0aXZhdGlvbiBldmVudC5cclxuICAgICAqIEBwYXJhbSBib25lIC0gVGhlIGFuY2hvciBib25lIGZvciB3aXJlIHVwLlxyXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBhbmNob3IgdXNlZCB0byBkZWZpbmUgd2hpY2ggb25lIGlzIGFjdGl2ZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN1YnNjcmliZUFuY2hvckJvbmVUb0V2ZW50cyhib25lOiBTbmFwLkVsZW1lbnQsIGluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICBib25lLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGcm96ZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBkcmFnIG9yaWdpbiBwb2ludCB0byBjdXJyZW50IGFuY2hvclxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnT3JpZ2luID0gbmV3IFBvaW50MkQoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVBbmNob3JJbmRleCA9IGluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgZ2hvc3QgYW5jaG9yIHRvIGN1cnJlbnQgYW5jaG9yIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdob3N0QW5jaG9yLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeDogdGhpcy5kcmFnT3JpZ2luLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5OiB0aGlzLmRyYWdPcmlnaW4ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhY3RpdmUgYW5jaG9yLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldEFjdGl2ZUFuY2hvcigpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUFuY2hvckluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgLy8gYW5jaG9yIHBvaW50IGlzIGFjdGl2ZXRlZFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JQb2ludFN0eWxlc1t0aGlzLmFjdGl2ZUFuY2hvckluZGV4XTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBhbmNob3IgYm9uZSBpcyBhY3RpdmV0ZWQsIGluZGV4ZXMgYXJlIG5lZ2F0aXZlIHN0YXJ0aW5nIC0xXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvckJvbmVTdHlsZXNbLXRoaXMuYWN0aXZlQW5jaG9ySW5kZXggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWdpb25EYXRhXCI7XHJcblxyXG5pbXBvcnQgeyBJUmVnaW9uQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBEcmFnQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudC9EcmFnQ29tcG9uZW50XCI7XHJcblxyXG4vKipcclxuICogYERyYWdDb21wb25lbnRgIGZvciB0aGUgYFJlY3RSZWdpb25gIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERyYWdFbGVtZW50IGV4dGVuZHMgRHJhZ0NvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYERyYWdFbGVtZW50YC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QgPSBudWxsLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MpO1xyXG5cclxuICAgICAgICB0aGlzLmRyYWdOb2RlID0gcGFwZXIucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy5ib3VuZFJlY3Qud2lkdGgsIHRoaXMuYm91bmRSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5kcmFnTm9kZS5hZGRDbGFzcyhcImRyYWdSZWN0U3R5bGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5kcmFnTm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9EcmFnRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjb21wb25uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdOb2RlLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgeDogdGhpcy54LFxyXG4gICAgICAgICAgICAgICAgeTogdGhpcy55LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5pbXBvcnQgeyBUYWdzRGVzY3JpcHRvciB9IGZyb20gXCIuLi8uLi9Db3JlL1RhZ3NEZXNjcmlwdG9yXCI7XHJcblxyXG5pbXBvcnQgeyBJVGFnc1VwZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lUYWdzVXBkYXRlT3B0aW9uc1wiO1xyXG5pbXBvcnQgeyBDaGFuZ2VFdmVudFR5cGUsIElSZWdpb25DYWxsYmFja3MgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lSZWdpb25DYWxsYmFja3NcIjtcclxuXHJcbmltcG9ydCB7IFJlZ2lvbkNvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvUmVnaW9uQ29tcG9uZW50XCI7XHJcbmltcG9ydCB7IFJlZ2lvbiB9IGZyb20gXCIuLi9SZWdpb25cIjtcclxuaW1wb3J0IHsgQW5jaG9yc0VsZW1lbnQgfSBmcm9tIFwiLi9BbmNob3JzRWxlbWVudHNcIjtcclxuaW1wb3J0IHsgRHJhZ0VsZW1lbnQgfSBmcm9tIFwiLi9EcmFnRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBUYWdzRWxlbWVudCB9IGZyb20gXCIuL1RhZ3NFbGVtZW50XCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlY3QtdHlwZSByZWdpb24gY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVjdFJlZ2lvbiBleHRlbmRzIFJlZ2lvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEJvdW5kaW5nIHJlY3RzIGZvciB0aGUgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBhcGVyUmVjdHM6IHsgaG9zdDogUmVjdCwgYWN0dWFsOiBSZWN0IH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIEFuY2hvcnNFbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFuY2hvck5vZGU6IEFuY2hvcnNFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBEcmFnRWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkcmFnTm9kZTogRHJhZ0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIFRhZ3NFbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRhZ3NOb2RlOiBUYWdzRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgdG9vbHRpcCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRvb2xUaXA6IFNuYXAuRnJhZ21lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgUmVjdFJlZ2lvbmAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBwYXBlclJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3IgY3JlYXRlZCBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IHNoYXJlZCBhY3Jvc3MgY29tcG9uZW50cy4gVXNlZCBhbHNvIGZvciBpbml0aWFsIHNldHVwLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBleHRlcm5hbCBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSByZWdpb24gYGlkYCB1c2VkIHRvIGlkZW50aWZ5IHJlZ2lvbnMgaW4gYFJlZ2lvbnNNYW5hZ2VyYC5cclxuICAgICAqIEBwYXJhbSB0YWdzRGVzY3JpcHRvciAtIFRoZSBkZXNjcmlwdG9yIG9mIHJlZ2lvbiB0YWdzLlxyXG4gICAgICogQHBhcmFtIHRhZ3NVcGRhdGVPcHRpb25zIC0gVGhlIGRyYXdpbmcgb3B0aW9ucyBmb3IgdGFncy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIHBhcGVyUmVjdDogUmVjdCA9IG51bGwsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIGNhbGxiYWNrczogSVJlZ2lvbkNhbGxiYWNrcyxcclxuICAgICAgICAgICAgICAgIGlkOiBzdHJpbmcsIHRhZ3NEZXNjcmlwdG9yOiBUYWdzRGVzY3JpcHRvciwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MsIGlkLCB0YWdzRGVzY3JpcHRvciwgdGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAocGFwZXJSZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFwZXJSZWN0cyA9IHtcclxuICAgICAgICAgICAgICAgIGFjdHVhbDogbmV3IFJlY3QocGFwZXJSZWN0LndpZHRoIC0gcmVnaW9uRGF0YS53aWR0aCwgcGFwZXJSZWN0LmhlaWdodCAtIHJlZ2lvbkRhdGEuaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgIGhvc3Q6IHBhcGVyUmVjdCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRPbihwYXBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHJlZ2lvbiB0YWdzLlxyXG4gICAgICogQHBhcmFtIHRhZ3MgLSBUaGUgbmV3IHRhZ3MgZGVzY3JpcHRvciBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB0YWdzIGRyYXdpbmcgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVRhZ3ModGFnczogVGFnc0Rlc2NyaXB0b3IsIG9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlci51cGRhdGVUYWdzKHRhZ3MsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMudGFnc05vZGUudXBkYXRlVGFncyh0YWdzLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm5vZGUuc2VsZWN0KFwidGl0bGVcIikubm9kZS5pbm5lckhUTUwgPSAodGFncyAhPT0gbnVsbCkgPyB0YWdzLnRvU3RyaW5nKCkgOiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgcmVnaW9uIHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgcmVnaW9uIHdpZHRoLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBuZXcgcmVnaW9uIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMucGFwZXJSZWN0cy5hY3R1YWwucmVzaXplKHRoaXMucGFwZXJSZWN0cy5ob3N0LndpZHRoIC0gd2lkdGgsIHRoaXMucGFwZXJSZWN0cy5ob3N0LmhlaWdodCAtIGhlaWdodCk7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvdCBpbnRlcm5hbCBjb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCAtIFJlZmVyZW5jZSB0byB0aGUgVUkgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBOZXcgUmVnaW9uRGF0YSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdGUgb2YgdGhlIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSBtdWx0aVNlbGVjdGlvbiAtIEZsYWcgZm9yIG11bHRpc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb25DaGFuZ2UoY29tcG9uZW50OiBSZWdpb25Db21wb25lbnQsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHN0YXRlOiBDaGFuZ2VFdmVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlTZWxlY3Rpb246IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMucGFwZXJSZWN0cy5hY3R1YWwucmVzaXplKHRoaXMucGFwZXJSZWN0cy5ob3N0LndpZHRoIC0gcmVnaW9uRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcGVyUmVjdHMuaG9zdC5oZWlnaHQgLSByZWdpb25EYXRhLmhlaWdodCk7XHJcbiAgICAgICAgc3VwZXIub25DaGFuZ2UoY29tcG9uZW50LCByZWdpb25EYXRhLCBzdGF0ZSwgbXVsdGlTZWxlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgVUkgb2YgdGhlIHJlZ2lvbiBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIGVsZW1lbnQgdG8gZHJhdyBvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZE9uKHBhcGVyOiBTbmFwLlBhcGVyKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gcGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcInJlZ2lvblN0eWxlXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyh0aGlzLnN0eWxlSUQpO1xyXG5cclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIG9uTWFuaXB1bGF0aW9uQmVnaW46IHRoaXMub25NYW5pcHVsYXRpb25CZWdpbi5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBvbk1hbmlwdWxhdGlvbkVuZDogdGhpcy5vbk1hbmlwdWxhdGlvbkVuZC5iaW5kKHRoaXMpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG5ldyBBbmNob3JzRWxlbWVudChwYXBlciwgdGhpcy5wYXBlclJlY3RzLmhvc3QsIHRoaXMucmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLmRyYWdOb2RlID0gbmV3IERyYWdFbGVtZW50KHBhcGVyLCB0aGlzLnBhcGVyUmVjdHMuYWN0dWFsLCB0aGlzLnJlZ2lvbkRhdGEsIGNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy50YWdzTm9kZSA9IG5ldyBUYWdzRWxlbWVudChwYXBlciwgdGhpcy5wYXBlclJlY3RzLmhvc3QsIHRoaXMucmVnaW9uRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFncywgdGhpcy5zdHlsZUlELCB0aGlzLnN0eWxlU2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3NVcGRhdGVPcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy50b29sVGlwID0gU25hcC5wYXJzZShgPHRpdGxlPiR7KHRoaXMudGFncyAhPT0gbnVsbCkgPyB0aGlzLnRhZ3MudG9TdHJpbmcoKSA6IFwiXCJ9PC90aXRsZT5gKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kKHRoaXMudG9vbFRpcCBhcyBhbnkpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMudGFnc05vZGUubm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmRyYWdOb2RlLm5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5hbmNob3JOb2RlLm5vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLlVJLnB1c2godGhpcy50YWdzTm9kZSwgdGhpcy5kcmFnTm9kZSwgdGhpcy5hbmNob3JOb2RlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5pbXBvcnQgeyBUYWdzRGVzY3JpcHRvciB9IGZyb20gXCIuLi8uLi9Db3JlL1RhZ3NEZXNjcmlwdG9yXCI7XHJcblxyXG5pbXBvcnQgeyBJVGFnc1VwZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lUYWdzVXBkYXRlT3B0aW9uc1wiO1xyXG5cclxuaW1wb3J0IHsgVGFnc0NvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvVGFnc0NvbXBvbmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIGBUYWdzQ29tcG9uZW50YCBmb3IgdGhlIGBSZWN0UmVnaW9uYCBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUYWdzRWxlbWVudCBleHRlbmRzIFRhZ3NDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHByaW1hcnkgdGFnIHRleHQtYm94IG9iamVjdCAoc3RvcnluZyBib3ggc2l6ZSkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgdGV4dEJveDogU25hcC5CQm94O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBwcmltYXJ5IHRhZyByZWN0IG9iamVjdCAoY292ZXJzIHRoZSByZWdpb24pLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByaW1hcnlUYWdSZWN0OiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHByaW1hcnkgdGFnIHRleHQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHByaW1hcnlUYWdUZXh0OiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHByaW1hcnkgdGFnIHRleHQgYmFja2dyb3VuZCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcHJpbWFyeVRhZ1RleHRCRzogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGFnc0VsZW1lbnRgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIGBUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IHByZXNlbnRpbmcgY29sb3JzIGFuZCBuYW1lcyBmb3IgcmVnaW9uIHRhZ3MuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVJZCAtIFRoZSB1bmlxdWUgY3NzIHN0eWxlIGlkIGZvciByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVTaGVldCAtIFRoZSByZWdlcmVuY2UgdG8gdGhlIHN0eWxlc2hlZXQgb2JqZWN0IGZvciBydWxlcyBpbnNlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdGFnc1VwZGF0ZU9wdGlvbnMgLSBUaGUgc2V0dGluZ3MgZm9yIHJlZHJhd2luZyB0YWdzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgcGFwZXJSZWN0OiBSZWN0LCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzOiBUYWdzRGVzY3JpcHRvciwgc3R5bGVJZDogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldDogQ1NTU3R5bGVTaGVldCwgdGFnc1VwZGF0ZU9wdGlvbnM/OiBJVGFnc1VwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCB0YWdzLCBzdHlsZUlkLCBzdHlsZVNoZWV0LCB0YWdzVXBkYXRlT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRPbihwYXBlciwgdGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjb21wb25uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KHJlYnVpbGRUYWdzOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgdGFncyBhc3NpZ25lZFxyXG4gICAgICAgIGlmICh0aGlzLnRhZ3MpIHtcclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YWdzLnByaW1hcnkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnRhZ3MucHJpbWFyeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmltYXR5IHRhZyByZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnUmVjdC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy55LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcHJpbWFyeSB0YWcgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWJ1aWxkVGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW1hcnlUYWdUZXh0Lm5vZGUuaW5uZXJIVE1MID0gKHRoaXMudGFncy5wcmltYXJ5ICE9PSBudWxsKSA/IHRoaXMudGFncy5wcmltYXJ5Lm5hbWUgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRCb3ggPSB0aGlzLnByaW1hcnlUYWdUZXh0LmdldEJCb3goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3dUZXh0TGFiZWwgPSAodGhpcy50ZXh0Qm94LndpZHRoICsgMTAgPD0gdGhpcy53aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0aGlzLnRleHRCb3guaGVpZ2h0IDw9IHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dUZXh0TGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnVGV4dEJHLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnRleHRCb3guaGVpZ2h0ICsgNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnRleHRCb3gud2lkdGggKyAxMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMueCArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnkgKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnVGV4dC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJsZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy54ICsgNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMueSArIHRoaXMudGV4dEJveC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZ1RleHRCRy5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5taW4oMTAsIHRoaXMuaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbigxMCwgdGhpcy53aWR0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW1hcnlUYWdUZXh0LmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMueCArIDUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnkgKyB0aGlzLnRleHRCb3guaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZ1JlY3QuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMueSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW1hcnlUYWdUZXh0QkcuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnVGV4dC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy54ICsgNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy55ICsgdGhpcy50ZXh0Qm94LmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBzZWNvbmRhcnkgdGFncyAtPiByZWRyYXcgZnJvbSBzY3JhdGNoXHJcbiAgICAgICAgICAgICAgICBpZiAocmVidWlsZFRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWNyZWF0ZSBzZWNvbmRhcnkgdGFnc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFncy5zZWNvbmRhcnkgJiYgdGhpcy50YWdzLnNlY29uZGFyeS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3ggPSB0aGlzLnggKyAwLjUgKiB0aGlzLmJvdW5kUmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjeSA9IHRoaXMueSAtIHMgLSA1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnRhZ3Muc2Vjb25kYXJ5Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWcgPSB0aGlzLnRhZ3Muc2Vjb25kYXJ5W2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IGN4ICsgKDIgKiBpIC0gbGVuZ3RoICsgMSkgKiBzIC0gcyAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVidWlsZFRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ2VsID0gdGhpcy5wYXBlci5yZWN0KHgsIGN5LCBzLCBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ2VsLmFkZENsYXNzKFwic2Vjb25kYXJ5VGFnU3R5bGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdlbC5hZGRDbGFzcyhgc2Vjb25kYXJ5VGFnLSR7c3RhZy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzTm9kZS5hZGQodGFnZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzLnB1c2godGFnZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnZWwgPSB0aGlzLnNlY29uZGFyeVRhZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdlbC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGN5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnUmVjdC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLnksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJpbWFyeSB0YWdcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeVRhZ1RleHQubm9kZS5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5VGFnVGV4dEJHLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlY29uZGFyeSB0YWdzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3MgPSBbXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdHMgc3R5bGUgbWFwcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGluaXRTdHlsZU1hcHModGFnczogVGFnc0Rlc2NyaXB0b3IpIHtcclxuICAgICAgICBpZiAodGFncyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGFncy5wcmltYXJ5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdSZWN0U3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yU2hhZG93fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6JHt0YWdzLnByaW1hcnkuY29sb3JBY2NlbnR9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9OmhvdmVyICAucHJpbWFyeVRhZ1JlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JIaWdobGlnaHR9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogI2ZmZjtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLnNlbGVjdGVkLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1JlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogJHt0YWdzLnByaW1hcnkuY29sb3JIaWdobGlnaHR9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZToke3RhZ3MucHJpbWFyeS5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdUZXh0QkdTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDoke3RhZ3MucHJpbWFyeS5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6JHt0YWdzLnByaW1hcnkuY29sb3JEYXJrfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvclB1cmV9YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH06aG92ZXIgLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6I2ZmZjtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGUuZ2hvc3RgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6dHJhbnNwYXJlbnQ7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlLmdob3N0OmhvdmVyYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOnJnYmEoMjU1LDI1NSwyNTUsMC41KTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVMaWdodE1hcCA9IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvck5vQ29sb3J9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZToke3RhZ3MucHJpbWFyeS5jb2xvckFjY2VudH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH06aG92ZXIgIC5wcmltYXJ5VGFnUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvckhpZ2hsaWdodH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAjZmZmO2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuc2VsZWN0ZWQuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiAke3RhZ3MucHJpbWFyeS5jb2xvck5vQ29sb3J9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZToke3RhZ3MucHJpbWFyeS5jb2xvckFjY2VudH07YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLnByaW1hcnlUYWdUZXh0QkdTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDoke3RhZ3MucHJpbWFyeS5jb2xvck5vQ29sb3J9O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnVGV4dFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiR7dGFncy5wcmltYXJ5LmNvbG9yQWNjZW50fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuc2Vjb25kYXJ5VGFnU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYG9wYWNpdHk6MC4yNTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGVgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZToke3RhZ3MucHJpbWFyeS5jb2xvckRhcmt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICR7dGFncy5wcmltYXJ5LmNvbG9yUHVyZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHg7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH06aG92ZXIgLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2U6I2ZmZjtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGUuZ2hvc3RgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6dHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAwO2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuJHt0aGlzLnN0eWxlSWR9IC5hbmNob3JTdHlsZS5naG9zdDpob3ZlcmAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDpyZ2JhKDI1NSwyNTUsMjU1LDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLXdpZHRoOiAwO2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTWFwID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTGlnaHRNYXAgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLiR7dGhpcy5zdHlsZUlkfSAucHJpbWFyeVRhZ1JlY3RTdHlsZWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZmlsbDogdmFyKC0tZGVmYXVsdC1jb2xvci10cmFuc3BhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB2YXIoLS1kZWZhdWx0LWNvbG9yLXB1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS13aWR0aDogMXB4O2AsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGAucmVnaW9uU3R5bGUuc2VsZWN0ZWQuJHt0aGlzLnN0eWxlSWR9IC5wcmltYXJ5VGFnUmVjdFN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBmaWxsOiB2YXIoLS1kZWZhdWx0LWNvbG9yLXRyYW5zcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHZhcigtLWRlZmF1bHQtY29sb3ItcHVyZSk7YCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5yZWdpb25TdHlsZS4ke3RoaXMuc3R5bGVJZH0gLmFuY2hvclN0eWxlYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBzdHJva2Utd2lkdGg6IDFweDtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGUuZ2hvc3RgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZS13aWR0aDogMDtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgLnJlZ2lvblN0eWxlLiR7dGhpcy5zdHlsZUlkfSAuYW5jaG9yU3R5bGUuZ2hvc3Q6aG92ZXJgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYHN0cm9rZS13aWR0aDogMDtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGFncy5zZWNvbmRhcnkgIT09IG51bGwgJiYgdGFncy5zZWNvbmRhcnkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGFncy5zZWNvbmRhcnkuZm9yRWFjaCgodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYC5zZWNvbmRhcnlUYWdTdHlsZS5zZWNvbmRhcnlUYWctJHt0YWcubmFtZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGZpbGw6ICR7dGFnLmNvbG9yQWNjZW50fTtgLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVNYXAucHVzaChydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlTGlnaHRNYXAucHVzaChydWxlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdG8gcmVjcmVhdGUgdGFnIGxhYmVscy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYnVpbGRUYWdMYWJlbHMoKSB7XHJcbiAgICAgICAgdGhpcy5yZWRyYXcodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjcmVhdGUgdGFnIGxhYmVsc1xyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSB0YWdzIC0gVGhlIGBUYWdzRGVzY3JpcHRvcmAgb2JqZWN0IGRlZmluaW5nIHRhZ3MuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRPbihwYXBlcjogU25hcC5QYXBlciwgdGFnczogVGFnc0Rlc2NyaXB0b3IpIHtcclxuICAgICAgICB0aGlzLnByaW1hcnlUYWdOb2RlID0gcGFwZXIuZygpO1xyXG5cclxuICAgICAgICB0aGlzLnByaW1hcnlUYWdSZWN0ID0gcGFwZXIucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy5ib3VuZFJlY3Qud2lkdGgsIHRoaXMuYm91bmRSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnUmVjdC5hZGRDbGFzcyhcInByaW1hcnlUYWdSZWN0U3R5bGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ1RleHQgPSBwYXBlci50ZXh0KHRoaXMueCwgdGhpcy55LCBcIlwiKTtcclxuICAgICAgICB0aGlzLnByaW1hcnlUYWdUZXh0LmFkZENsYXNzKFwicHJpbWFyeVRhZ1RleHRTdHlsZVwiKTtcclxuICAgICAgICB0aGlzLnRleHRCb3ggPSB0aGlzLnByaW1hcnlUYWdUZXh0LmdldEJCb3goKTtcclxuXHJcbiAgICAgICAgLy8gYm91bmQgdG8gcmVnaW9uPz8/XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnVGV4dEJHID0gcGFwZXIucmVjdCh0aGlzLngsIHRoaXMueSwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5wcmltYXJ5VGFnVGV4dEJHLmFkZENsYXNzKFwicHJpbWFyeVRhZ1RleHRCR1N0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnByaW1hcnlUYWdOb2RlLmFkZCh0aGlzLnByaW1hcnlUYWdSZWN0KTtcclxuICAgICAgICB0aGlzLnByaW1hcnlUYWdOb2RlLmFkZCh0aGlzLnByaW1hcnlUYWdUZXh0QkcpO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVRhZ05vZGUuYWRkKHRoaXMucHJpbWFyeVRhZ1RleHQpO1xyXG5cclxuICAgICAgICB0aGlzLnNlY29uZGFyeVRhZ3NOb2RlID0gcGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5VGFnc05vZGUuYWRkQ2xhc3MoXCJzZWNvbmRhdHlUYWdzTGF5ZXJcIik7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlUYWdzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5wcmltYXJ5VGFnTm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLnNlY29uZGFyeVRhZ3NOb2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0U3R5bGVNYXBzKHRhZ3MpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGFncyh0YWdzLCB0aGlzLnRhZ3NVcGRhdGVPcHRpb25zKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5pbXBvcnQgeyBUYWdzRGVzY3JpcHRvciB9IGZyb20gXCIuLi9Db3JlL1RhZ3NEZXNjcmlwdG9yXCI7XHJcblxyXG5pbXBvcnQgeyBJTW92YWJsZSB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSU1vdmFibGVcIjtcclxuaW1wb3J0IHsgSVRhZ3NVcGRhdGVPcHRpb25zIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JVGFnc1VwZGF0ZU9wdGlvbnNcIjtcclxuaW1wb3J0IHsgQ2hhbmdlRXZlbnRUeXBlLCBJUmVnaW9uQ2FsbGJhY2tzIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JUmVnaW9uQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBSZWdpb25Db21wb25lbnQgfSBmcm9tIFwiLi9Db21wb25lbnQvUmVnaW9uQ29tcG9uZW50XCI7XHJcblxyXG4vKiBpbXBvcnQgKiBhcyBTTkFQU1ZHX1RZUEUgZnJvbSBcInNuYXBzdmdcIjtcclxuZGVjbGFyZSB2YXIgU25hcDogdHlwZW9mIFNOQVBTVkdfVFlQRTsgKi9cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWdpb24gZXh0ZW5kcyBSZWdpb25Db21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHRhZ3MgZGVzY3JpcHRvciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YWdzOiBUYWdzRGVzY3JpcHRvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4dGVybmFsIHJlZ2lvbiBJRC4gRS5nLiwgdXNlZCBpbiB0aGUgYFJlZ2lvbnNNYW5hZ2VyYC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIElEOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCByZWdpb24gSUQuIFVzZWQgdG8gc2ltcGxpZnkgZGVidWdnaW5nIGFuZCBmb3Igc3R5bGluZy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlZ2lvbklEOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZGluZyBibG9ja3Mgb2YgdGhlIHJlZ2lvbiBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBVSTogUmVnaW9uQ29tcG9uZW50W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBpZCB0byBpbnNlcnQvdHJhY2sgc3R5bGVzaGVldHMuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdHlsZUlEOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVmZXJlbmNlIHRvIHRoZSBDU1NTdHlsZVNoZWV0IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0eWxlU2hlZXQ6IENTU1N0eWxlU2hlZXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJhdGlvbiB0byBkcmF3L3JlZHJhdyB0YWdzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdGFnc1VwZGF0ZU9wdGlvbnM6IElUYWdzVXBkYXRlT3B0aW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBSZWdpb25gIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgcmVnaW9uIGBpZGAgdXNlZCB0byBpZGVudGlmeSByZWdpb25zIGluIGBSZWdpb25zTWFuYWdlcmAuXHJcbiAgICAgKiBAcGFyYW0gdGFnc0Rlc2NyaXB0b3IgLSBUaGUgZGVzY3JpcHRvciBvZiByZWdpb24gdGFncy5cclxuICAgICAqIEBwYXJhbSB0YWdzVXBkYXRlT3B0aW9ucyAtIFRoZSBkcmF3aW5nIG9wdGlvbnMgZm9yIHRhZ3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QgPSBudWxsLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3MsXHJcbiAgICAgICAgICAgICAgICBpZDogc3RyaW5nLCB0YWdzRGVzY3JpcHRvcjogVGFnc0Rlc2NyaXB0b3IsIHRhZ3NVcGRhdGVPcHRpb25zPzogSVRhZ3NVcGRhdGVPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIHBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy5JRCA9IGlkO1xyXG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3NEZXNjcmlwdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvbklEID0gdGhpcy5zOCgpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVJRCA9IGByZWdpb25fJHt0aGlzLnJlZ2lvbklEfV9zdHlsZWA7XHJcbiAgICAgICAgdGhpcy5zdHlsZVNoZWV0ID0gdGhpcy5pbnNlcnRTdHlsZVNoZWV0KCk7XHJcbiAgICAgICAgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyA9IHRhZ3NVcGRhdGVPcHRpb25zO1xyXG5cclxuICAgICAgICB0aGlzLlVJID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciByZWdpb24gc3R5bGVzLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlU3R5bGVzKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc3R5bGVJRCkucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gZm90IGludGVybmFsIGNvbXBvbmVudHMuXHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IC0gUmVmZXJlbmNlIHRvIHRoZSBVSSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIE5ldyBSZWdpb25EYXRhIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIE5ldyBzdGF0ZSBvZiB0aGUgcmVnaW9uLlxyXG4gICAgICogQHBhcmFtIG11bHRpU2VsZWN0aW9uIC0gRmxhZyBmb3IgbXVsdGlzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbkNoYW5nZShjb21wb25lbnQ6IFJlZ2lvbkNvbXBvbmVudCwgcmVnaW9uRGF0YTogUmVnaW9uRGF0YSwgc3RhdGU6IENoYW5nZUV2ZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aVNlbGVjdGlvbjogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25EYXRhLmluaXRGcm9tKHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICAgICAgc3VwZXIub25DaGFuZ2UodGhpcywgdGhpcy5yZWdpb25EYXRhLmNvcHkoKSwgc3RhdGUsIG11bHRpU2VsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgcmVnaW9uIHRhZ3MuXHJcbiAgICAgKiBAcGFyYW0gdGFncyAtIFRoZSBuZXcgdGFncyBkZXNjcmlwdG9yIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHRhZ3MgZHJhd2luZyBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdXBkYXRlVGFncyh0YWdzOiBUYWdzRGVzY3JpcHRvciwgb3B0aW9ucz86IElUYWdzVXBkYXRlT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XHJcbiAgICAgICAgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHJlZ2lvbiB0byBzcGVjaWZpZWQgbG9jYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBOZXcgcmVnaW9uIGxvY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZShwb2ludDogSU1vdmFibGUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZSByZWdpb24gdG8gc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHggLSBOZXcgeC1jb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHkgLSBOZXcgeS1jb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XHJcbiAgICBwdWJsaWMgbW92ZShhcmcxOiBhbnksIGFyZzI/OiBhbnkpIHtcclxuICAgICAgICBzdXBlci5tb3ZlKGFyZzEsIGFyZzIpO1xyXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSByZWdpb24gdG8gc3BlY2lmaWVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG5ldyByZWdpb24gd2lkdGguXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyByZWdpb24gaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSByZWdpb24gY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuVUkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlZHJhdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlzdWFsbHkgZnJlZXplIHRoZSByZWdpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmcmVlemUoKSB7XHJcbiAgICAgICAgc3VwZXIuZnJlZXplKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwib2xkXCIpO1xyXG4gICAgICAgIHRoaXMuVUkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LmZyZWV6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlzdWFsbHkgdW5mcmVlemUgdGhlIHJlZ2lvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVuZnJlZXplKCkge1xyXG4gICAgICAgIHN1cGVyLnVuZnJlZXplKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNsYXNzKFwib2xkXCIpO1xyXG4gICAgICAgIHRoaXMuVUkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LnVuZnJlZXplKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgcmFuZG9tIGlkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgczgoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGluc2VydCBhIG5ldyBzdHlsZXNoZWV0IGludG8gdGhlIGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGluc2VydFN0eWxlU2hlZXQoKTogQ1NTU3R5bGVTaGVldCB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5zdHlsZUlEKTtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgICAgICByZXR1cm4gc3R5bGUuc2hlZXQgYXMgQ1NTU3R5bGVTaGVldDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5cclxuaW1wb3J0IHsgSU1vdmFibGUgfSBmcm9tIFwiLi4vSW50ZXJmYWNlL0lNb3ZhYmxlXCI7XHJcbmltcG9ydCB7IElSZWdpb25DYWxsYmFja3MgfSBmcm9tIFwiLi4vSW50ZXJmYWNlL0lSZWdpb25DYWxsYmFja3NcIjtcclxuXHJcbmltcG9ydCB7IFJlZ2lvbkNvbXBvbmVudCB9IGZyb20gXCIuL0NvbXBvbmVudC9SZWdpb25Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgUmVnaW9uIH0gZnJvbSBcIi4vUmVnaW9uXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlZ2lvbiBtZW51IGVsZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWVudUVsZW1lbnQgZXh0ZW5kcyBSZWdpb25Db21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgU1ZHIHBhdGggZm9yIHgtYnV0dG9uIChjbG9zZSkuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgUGF0aENvbGxlY3Rpb24gPSB7XHJcbiAgICAgICAgZGVsZXRlOiB7XHJcbiAgICAgICAgICAgIGljb25TaXplOiA5NixcclxuICAgICAgICAgICAgcGF0aDogXCJNIDgzLjQgMjEuMSBMIDc0LjkgMTIuNiBMIDQ4IDM5LjUgTCAyMS4xIDEyLjYgTCAxMi42IDIxLjEgTCAzOS41IDQ4IEwgMTIuNiA3NC45IFwiICtcclxuICAgICAgICAgICAgICAgICAgXCJMIDIxLjEgODMuNCBMIDQ4IDU2LjUgTCA3NC45IDgzLjQgTCA4My40IDc0LjkgTCA1Ni41IDQ4IFpcIixcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lbnUgZ3JvdXAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWVudUdyb3VwOiBTbmFwLlBhcGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVudSBiYWNrZ3JvdW5kIHJlY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtZW51UmVjdDogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBncm91cGluZyBvYmplY3QgZm9yIG1lbnUgaXRlbXMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtZW51SXRlbXNHcm91cDogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWVudSBpdGVtcyBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbWVudUl0ZW1zOiBTbmFwLkVsZW1lbnRbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgbWVudSBpdGVtIHNpemUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbWVudUl0ZW1TaXplOiBudW1iZXIgPSAyMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lbnUgeC1jb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG14OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZW51IHktY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBteTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBtZW51IHdpZHRoLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG13OiBudW1iZXIgPSB0aGlzLm1lbnVJdGVtU2l6ZSArIDEwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBtZW51IGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtaDogbnVtYmVyID0gdGhpcy5tZW51SXRlbVNpemUgKyAxMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRocmVzaG9sZCBmb3IgcG9zaXRpb25pbmcgbWVudSBpbnNpZGUvb3V0c2lkZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGRoOiBudW1iZXIgPSAyMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRocmVzaG9sZCBmb3IgcG9zaXRpb25pbmcgbWVudSBsZWZ0L3JpZ2h0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZHc6IG51bWJlciA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGhvc3QgcmVnaW9uIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnaW9uOiBSZWdpb25Db21wb25lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtZW51IGNvbXBvbmVudC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gcGFwZXJSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIGNyZWF0ZWQgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBzaGFyZWQgYWNyb3NzIGNvbXBvbmVudHMuIFVzZWQgYWxzbyBmb3IgaW5pdGlhbCBzZXR1cC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgZXh0ZXJuYWwgY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBwYXBlclJlY3Q6IFJlY3QgPSBudWxsLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBjYWxsYmFja3M6IElSZWdpb25DYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgcGFwZXJSZWN0LCByZWdpb25EYXRhLCBjYWxsYmFja3MpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRVSSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbmV3IGljb24gd2l0aCBhY3Rpb24gdG8gbWVudS5cclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBJdGVtIGFjdGlvbiBkZXNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSBpY29uIC0gSXRlbSBTVkctcGF0aCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRBY3Rpb24oYWN0aW9uOiBzdHJpbmcsIGljb246IHN0cmluZywgYWN0b3I6IChjb21wb25lbnQ6IFJlZ2lvbkNvbXBvbmVudCwgYWN0aW9uPzogc3RyaW5nKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVudUdyb3VwLmcoKTtcclxuICAgICAgICBjb25zdCBpdGVtQmFjayA9IHRoaXMubWVudUdyb3VwLnJlY3QoNSwgNSwgdGhpcy5tZW51SXRlbVNpemUsIHRoaXMubWVudUl0ZW1TaXplLCA1LCA1KTtcclxuICAgICAgICBpdGVtQmFjay5hZGRDbGFzcyhcIm1lbnVJdGVtQmFja1wiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXRlbUljb24gPSB0aGlzLm1lbnVHcm91cC5wYXRoKE1lbnVFbGVtZW50LlBhdGhDb2xsZWN0aW9uLmRlbGV0ZS5wYXRoKTtcclxuICAgICAgICBpdGVtSWNvbi50cmFuc2Zvcm0oYHNjYWxlKDAuMikgdHJhbnNsYXRlKDI2IDI2KWApO1xyXG5cclxuICAgICAgICBpdGVtSWNvbi5hZGRDbGFzcyhcIm1lbnVJY29uXCIpO1xyXG4gICAgICAgIGl0ZW1JY29uLmFkZENsYXNzKFwibWVudUljb24tXCIgKyBpY29uKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXRlbVJlY3QgPSB0aGlzLm1lbnVHcm91cC5yZWN0KDUsIDUsIHRoaXMubWVudUl0ZW1TaXplLCB0aGlzLm1lbnVJdGVtU2l6ZSwgNSwgNSk7XHJcbiAgICAgICAgaXRlbVJlY3QuYWRkQ2xhc3MoXCJtZW51SXRlbVwiKTtcclxuXHJcbiAgICAgICAgaXRlbS5hZGQoaXRlbUJhY2spO1xyXG4gICAgICAgIGl0ZW0uYWRkKGl0ZW1JY29uKTtcclxuICAgICAgICBpdGVtLmFkZChpdGVtUmVjdCk7XHJcblxyXG4gICAgICAgIGl0ZW0uY2xpY2soKGUpID0+IHtcclxuICAgICAgICAgICAgYWN0b3IodGhpcy5yZWdpb24sIGFjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWVudUl0ZW1zR3JvdXAuYWRkKGl0ZW0pO1xyXG4gICAgICAgIHRoaXMubWVudUl0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIG1lbnUgdG8gc3BlY2lmaWVkIHJlZ2lvbiBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSBob3N0IHJlZ2lvbiBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXR0YWNoVG8ocmVnaW9uOiBSZWdpb24pIHtcclxuICAgICAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcclxuICAgICAgICB0aGlzLnJlZ2lvbkRhdGEuaW5pdEZyb20ocmVnaW9uLnJlZ2lvbkRhdGEpO1xyXG4gICAgICAgIHRoaXMucmVhcnJhbmdlTWVudVBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1lbnVHcm91cC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMubXgsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLm15LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgbWVudSBhY2NvcmRpbmcgdG8gbmV3IHJlZ2lvbiBsb2NhdGlvblxyXG4gICAgICogQHJlbWFya3MgVGhpcyBtZXRob2QgbW92ZXMgdGhlIHZpcnR1YWwgc2hhZG93IG9mIHRoZSByZWdpb24gYW5kIHRoZW4gcmVhcnJhbmdlcyBtZW51IHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHBvaW50IC0gTmV3IHJlZ2lvbiBsb2NhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG1vdmUocG9pbnQ6IElNb3ZhYmxlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgbWVudSBhY2NvcmRpbmcgdG8gbmV3IHJlZ2lvbiBjb29yZGluYXRlcy5cclxuICAgICAqIEByZW1hcmtzIFRoaXMgbWV0aG9kIG1vdmVzIHRoZSB2aXJ0dWFsIHNoYWRvdyBvZiB0aGUgcmVnaW9uIGFuZCB0aGVuIHJlYXJyYW5nZXMgbWVudSBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB4IC0gTmV3IHJlZ2lvbiB4LWNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0geSAtIE5ldyByZWdpb24geS1jb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XHJcbiAgICBwdWJsaWMgbW92ZShhcmcxOiBhbnksIGFyZzI/OiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5tb3ZlKGFyZzEsIGFyZzIpO1xyXG5cclxuICAgICAgICB0aGlzLnJlYXJyYW5nZU1lbnVQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tZW51R3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLm14LFxyXG4gICAgICAgICAgICAgICAgeTogdGhpcy5teSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIG1lbnUgYWNjb3JkaW5nIHRvIG5ldyByZWdpb24gc2l6ZS5cclxuICAgICAqIEByZW1hcmtzIFRoaXMgbWV0aG9kIG1vdmVzIHRoZSB2aXJ0dWFsIHNoYWRvdyBvZiB0aGUgcmVnaW9uIGFuZCB0aGVuIHJlYXJyYW5nZXMgbWVudSBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIE5ldyByZWdpb24gd2lkdGguXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gTmV3IHJlZ2lvbiBoZWlnaHQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVhcnJhbmdlTWVudVBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1lbnVHcm91cC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMubXgsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLm15LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZHJhdyBtZW51IGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWRyYXcoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlzdWFsbHkgaGlkZSBtZW51IGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoaWRlKCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1lbnVHcm91cC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZpc3VhbGx5IHNob3cgbWVudSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tZW51R3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG1lbnUgZWxlbWVudCBvbiB0aGUgc3BlY2lmaWVkIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSByZWdpb24gLSBUaGUgaG9zdCByZWdpb24gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3dPblJlZ2lvbihyZWdpb246IFJlZ2lvbikge1xyXG4gICAgICAgIHRoaXMuYXR0YWNoVG8ocmVnaW9uKTtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1lbnUgZWxlbWVudCBVSS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZFVJKCkge1xyXG4gICAgICAgIGNvbnN0IG1lbnVTVkcgPSB0aGlzLnBhcGVyLnN2Zyh0aGlzLm14LCB0aGlzLm15LCB0aGlzLm13LCB0aGlzLm1oLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5teCwgdGhpcy5teSwgdGhpcy5tdywgdGhpcy5taCkgYXMgU1ZHR3JhcGhpY3NFbGVtZW50O1xyXG5cclxuICAgICAgICAvLyBTbmFwLlBhcGVyXHJcbiAgICAgICAgdGhpcy5tZW51R3JvdXAgPSBTbmFwKG1lbnVTVkcpLnBhcGVyO1xyXG4gICAgICAgIHRoaXMubWVudUdyb3VwLmFkZENsYXNzKFwibWVudUxheWVyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnJlYXJyYW5nZU1lbnVQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICB0aGlzLm1lbnVSZWN0ID0gdGhpcy5tZW51R3JvdXAucmVjdCgwLCAwLCB0aGlzLm13LCB0aGlzLm1oLCA1LCA1KTtcclxuICAgICAgICB0aGlzLm1lbnVSZWN0LmFkZENsYXNzKFwibWVudVJlY3RTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZW51SXRlbXNHcm91cCA9IHRoaXMubWVudUdyb3VwLmcoKTtcclxuICAgICAgICB0aGlzLm1lbnVJdGVtc0dyb3VwLmFkZENsYXNzKFwibWVudUl0ZW1zXCIpO1xyXG5cclxuICAgICAgICB0aGlzLm1lbnVJdGVtcyA9IG5ldyBBcnJheTxTbmFwLkVsZW1lbnQ+KCk7XHJcblxyXG4gICAgICAgIHRoaXMubWVudUdyb3VwLmFkZCh0aGlzLm1lbnVSZWN0KTtcclxuICAgICAgICB0aGlzLm1lbnVHcm91cC5hZGQodGhpcy5tZW51SXRlbXNHcm91cCk7XHJcblxyXG4gICAgICAgIHRoaXMubWVudUdyb3VwLm1vdXNlb3ZlcigoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uQmVnaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tZW51R3JvdXAubW91c2VvdXQoKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbk1hbmlwdWxhdGlvbkVuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBtZW51IHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlYXJyYW5nZU1lbnVQb3NpdGlvbigpIHtcclxuICAgICAgICAvKiAvLyBwb3NpdGlvbiBtZW51IGluc2lkZVxyXG4gICAgICAgIGlmICh0aGlzLm1oIDw9IHRoaXMuYm91bmRSZWN0LmhlaWdodCAtIHRoaXMuZGgpIHtcclxuICAgICAgICAgICAgdGhpcy5teSA9IHRoaXMueSArIHRoaXMuYm91bmRSZWN0LmhlaWdodCAvIDIgLSB0aGlzLm1oIC8gMjtcclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWVudSBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy54ICsgdGhpcy5ib3VuZFJlY3Qud2lkdGggKyB0aGlzLm13IC8gMiArIHRoaXMuZHcgPCB0aGlzLnBhcGVyUmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5teCA9IHRoaXMueCArIHRoaXMuYm91bmRSZWN0LndpZHRoIC0gdGhpcy5tdyAvIDI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy54IC0gdGhpcy5tdyAvIDIgLSB0aGlzLmR3ID4gMCkgeyAvLyBwb3NpdGlvbiBtZW51IG9uIHRoZSBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgICAgIHRoaXMubXggPSB0aGlzLnggLSB0aGlzLm13IC8gMjtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcG9zaXRpb24gbWVudSBvbiB0aGUgcmlnaHQgc2lkZSBJTlNJREVcclxuICAgICAgICAgICAgICAgIHRoaXMubXggPSB0aGlzLnggKyB0aGlzLmJvdW5kUmVjdC53aWR0aCAtIHRoaXMubXcgLSB0aGlzLmR3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHsgLy8gcG9zaXRpb24gbWVudSBvdXRzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnkgKyB0aGlzLm1oID4gdGhpcy5wYXBlclJlY3QuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm15ID0gdGhpcy5wYXBlclJlY3QuaGVpZ2h0IC0gdGhpcy5taCAtIHRoaXMuZHc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm15ID0gdGhpcy55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1lbnUgb24gdGhlIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMueCArIHRoaXMuYm91bmRSZWN0LndpZHRoICsgdGhpcy5tdyArIDIgKiB0aGlzLmR3IDwgdGhpcy5wYXBlclJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXggPSB0aGlzLnggKyB0aGlzLmJvdW5kUmVjdC53aWR0aCArIHRoaXMuZHc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy54IC0gdGhpcy5tdyAtIDIgKiB0aGlzLmR3ID4gMCkgeyAvLyBwb3NpdGlvbiBtZW51IG9uIHRoZSBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgICAgIHRoaXMubXggPSB0aGlzLnggLSB0aGlzLm13IC0gdGhpcy5kdztcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcG9zaXRpb24gbWVudSBvbiB0aGUgcmlnaHQgc2lkZSBJTlNJREVcclxuICAgICAgICAgICAgICAgIHRoaXMubXggPSB0aGlzLnggKyB0aGlzLmJvdW5kUmVjdC53aWR0aCAtIHRoaXMubXcgLSB0aGlzLmR3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAqL1xyXG5cclxuICAgICAgICAvLyBwb3NpdGlvbiBtZW51IG91dHNpZGVcclxuICAgICAgICBpZiAodGhpcy55ICsgdGhpcy5taCArIHRoaXMuZHcgPiB0aGlzLnBhcGVyUmVjdC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5teSA9IHRoaXMucGFwZXJSZWN0LmhlaWdodCAtIHRoaXMubWggLSB0aGlzLmR3O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubXkgPSB0aGlzLnkgKyB0aGlzLmR3O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwb3NpdGlvbiBtZW51IG9uIHRoZSByaWdodCBzaWRlXHJcbiAgICAgICAgaWYgKHRoaXMueCArIHRoaXMuYm91bmRSZWN0LndpZHRoICsgdGhpcy5tdyArIDIgKiB0aGlzLmR3IDwgdGhpcy5wYXBlclJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5teCA9IHRoaXMueCArIHRoaXMuYm91bmRSZWN0LndpZHRoICsgdGhpcy5kdztcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMueCAtIHRoaXMubXcgLSAyICogdGhpcy5kdyA+IDApIHsgLy8gcG9zaXRpb24gbWVudSBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgIHRoaXMubXggPSB0aGlzLnggLSB0aGlzLm13IC0gdGhpcy5kdztcclxuICAgICAgICB9IGVsc2UgeyAvLyBwb3NpdGlvbiBtZW51IG9uIHRoZSByaWdodCBzaWRlIElOU0lERVxyXG4gICAgICAgICAgICB0aGlzLm14ID0gdGhpcy54ICsgdGhpcy5ib3VuZFJlY3Qud2lkdGggLSB0aGlzLm13IC0gdGhpcy5kdztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFBvaW50MkQgfSBmcm9tIFwiLi4vQ29yZS9Qb2ludDJEXCI7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IENoYW5nZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVJlZ2lvbkNhbGxiYWNrc1wiO1xyXG5pbXBvcnQgeyBJUmVnaW9uc01hbmFnZXJDYWxsYmFja3MgfSBmcm9tIFwiLi4vSW50ZXJmYWNlL0lSZWdpb25zTWFuYWdlckNhbGxiYWNrc1wiO1xyXG5pbXBvcnQgeyBUYWdzRGVzY3JpcHRvciB9IGZyb20gXCIuLi9Db3JlL1RhZ3NEZXNjcmlwdG9yXCI7XHJcbmltcG9ydCB7IElUYWdzVXBkYXRlT3B0aW9ucyB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVRhZ3NVcGRhdGVPcHRpb25zXCI7XHJcbmltcG9ydCB7IFJlY3RSZWdpb24gfSBmcm9tIFwiLi9SZWN0L1JlY3RSZWdpb25cIjtcclxuaW1wb3J0IHsgUG9pbnRSZWdpb24gfSBmcm9tIFwiLi9Qb2ludC9Qb2ludFJlZ2lvblwiO1xyXG5pbXBvcnQgeyBQb2x5Z29uUmVnaW9uIH0gZnJvbSBcIi4vUG9seWdvbi9Qb2x5Z29uUmVnaW9uXCI7XHJcbmltcG9ydCB7IFBvbHlsaW5lUmVnaW9uIH0gZnJvbSBcIi4vUG9seWxpbmUvUG9seWxpbmVSZWdpb25cIjtcclxuaW1wb3J0IHsgTWVudUVsZW1lbnQgfSBmcm9tIFwiLi9SZWdpb25NZW51XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEsIFJlZ2lvbkRhdGFUeXBlIH0gZnJvbSBcIi4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5pbXBvcnQgeyBSZWdpb24gfSBmcm9tIFwiLi9SZWdpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBmb3IgdmlzdWFsIHJlZ2lvbiBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlZ2lvbnNNYW5hZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGV4dGVybmFsIGNhbGxiYWNrcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbGxiYWNrczogSVJlZ2lvbnNNYW5hZ2VyQ2FsbGJhY2tzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBob3N0IFNWRyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJhc2VQYXJlbnQ6IFNWR1NWR0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXBlcjogU25hcC5QYXBlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXBlciBib3VuZGluZyBib3guXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcGFwZXJSZWN0OiBSZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdGlvbiBvZiByZWdpb25zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlZ2lvbnM6IFJlZ2lvbltdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JvdXBpbmcgZWxlbWVudCBmb3IgbWVudSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG1lbnVMYXllcjogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBgTWVudUVsZW1lbnRgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtZW51OiBNZW51RWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwaW5nIGxheWVyIGZvciB0aGUgbWFuYWdlci5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWdpb25NYW5hZ2VyTGF5ZXI6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBmcmVlemluZyBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpc0Zyb3plblN0YXRlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBtYW5pcHVsYXRpb24gZmxhZy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBqdXN0TWFuaXB1bGF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY3VycmVudCBmcmVlemluZyBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBpc0Zyb3plbigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0Zyb3plblN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkaXRpb25hbCBDU1MgY2xhc3MgdG8gYmUgYWRkZWQgd2hlbiBtYW5hZ2VyIGlzIGZyb3plbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmcm96ZW5OdWFuY2U6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRhZ3MgY3JlYXRlL3JlZHJhdyBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHRhZ3NVcGRhdGVPcHRpb25zOiBJVGFnc1VwZGF0ZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgc2hvd1JlZ2lvbkJhY2tncm91bmQ6IHRydWUsXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYFJlZ2lvbnNNYW5hZ2VyYC5cclxuICAgICAqIEBwYXJhbSBzdmdIb3N0IC0gVGhlIGhvc3RpbmcgU1ZHIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIC0gUmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFja3MgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc3ZnSG9zdDogU1ZHU1ZHRWxlbWVudCwgY2FsbGJhY2tzOiBJUmVnaW9uc01hbmFnZXJDYWxsYmFja3MpIHtcclxuICAgICAgICB0aGlzLmJhc2VQYXJlbnQgPSBzdmdIb3N0O1xyXG4gICAgICAgIHRoaXMucGFwZXIgPSBTbmFwKHN2Z0hvc3QpO1xyXG4gICAgICAgIHRoaXMucGFwZXJSZWN0ID0gbmV3IFJlY3Qoc3ZnSG9zdC53aWR0aC5iYXNlVmFsLnZhbHVlLCBzdmdIb3N0LmhlaWdodC5iYXNlVmFsLnZhbHVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpb25zID0gbmV3IEFycmF5PFJlZ2lvbj4oKTtcclxuXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFja3Mub25DaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25DaGFuZ2UgPSAocmVnaW9uOiBSZWdpb24sIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHN0YXRlOiBDaGFuZ2VFdmVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aVNlbGVjdGlvbjogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlZ2lvbkNoYW5nZShyZWdpb24sIHJlZ2lvbkRhdGEsIHN0YXRlLCBtdWx0aVNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uQ2hhbmdlKHJlZ2lvbiwgcmVnaW9uRGF0YSwgc3RhdGUsIG11bHRpU2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkNoYW5nZSA9IHRoaXMub25SZWdpb25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge1xyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMub25SZWdpb25DaGFuZ2UuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIG9uTWFuaXB1bGF0aW9uQmVnaW46IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvbk1hbmlwdWxhdGlvbkVuZDogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRPbih0aGlzLnBhcGVyKTtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbmV3IHJlZ2lvbiB0byB0aGUgbWFuYWdlci4gQXV0b21hdGljYWxseSBkZWZpbmVzIHJlZ2lvbiB0eXBlIGJhc2VkIG9uIHRoZSBgdHlwZWAgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgcmVnaW9uIElELlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBkZWZpbmluZyByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gdGFnc0Rlc2NyaXB0b3IgLSBUaGUgdGFncyBkZXNjcmlwdG9yIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFJlZ2lvbihpZDogc3RyaW5nLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzRGVzY3JpcHRvcjogVGFnc0Rlc2NyaXB0b3IpIHtcclxuICAgICAgICBpZiAocmVnaW9uRGF0YS50eXBlID09PSBSZWdpb25EYXRhVHlwZS5Qb2ludCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBvaW50UmVnaW9uKGlkLCByZWdpb25EYXRhLCB0YWdzRGVzY3JpcHRvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChyZWdpb25EYXRhLnR5cGUgPT09IFJlZ2lvbkRhdGFUeXBlLlBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUG9seWxpbmVSZWdpb24oaWQsIHJlZ2lvbkRhdGEsIHRhZ3NEZXNjcmlwdG9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlZ2lvbkRhdGEudHlwZSA9PT0gUmVnaW9uRGF0YVR5cGUuUmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJlY3RSZWdpb24oaWQsIHJlZ2lvbkRhdGEsIHRhZ3NEZXNjcmlwdG9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlZ2lvbkRhdGEudHlwZSA9PT0gUmVnaW9uRGF0YVR5cGUuUG9seWdvbikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBvbHlnb25SZWdpb24oaWQsIHJlZ2lvbkRhdGEsIHRhZ3NEZXNjcmlwdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zb3J0UmVnaW9uc0J5QXJlYSgpO1xyXG4gICAgICAgIHRoaXMucmVkcmF3QWxsUmVnaW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5ldyByZWN0IHJlZ2lvbiB0byB0aGUgbWFuYWdlci5cclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSByZWdpb24gSUQuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uRGF0YSAtIFRoZSBgUmVnaW9uRGF0YWAgb2JqZWN0IGRlZmluaW5nIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSB0YWdzRGVzY3JpcHRvciAtIFRoZSB0YWdzIGRlc2NyaXB0b3Igb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkUmVjdFJlZ2lvbihpZDogc3RyaW5nLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzRGVzY3JpcHRvcjogVGFnc0Rlc2NyaXB0b3IpIHtcclxuICAgICAgICB0aGlzLm1lbnUuaGlkZSgpO1xyXG5cclxuICAgICAgICBjb25zdCByZWdpb24gPSBuZXcgUmVjdFJlZ2lvbih0aGlzLnBhcGVyLCB0aGlzLnBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgdGhpcy5jYWxsYmFja3MsIGlkLCB0YWdzRGVzY3JpcHRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3NVcGRhdGVPcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlclJlZ2lvbihyZWdpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5ldyBwb2ludCByZWdpb24gdG8gdGhlIG1hbmFnZXIuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgcmVnaW9uIElELlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBUaGUgYFJlZ2lvbkRhdGFgIG9iamVjdCBkZWZpbmluZyByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gdGFnc0Rlc2NyaXB0b3IgLSBUaGUgdGFncyBkZXNjcmlwdG9yIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZFBvaW50UmVnaW9uKGlkOiBzdHJpbmcsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHRhZ3NEZXNjcmlwdG9yOiBUYWdzRGVzY3JpcHRvcikge1xyXG4gICAgICAgIHRoaXMubWVudS5oaWRlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IG5ldyBQb2ludFJlZ2lvbih0aGlzLnBhcGVyLCB0aGlzLnBhcGVyUmVjdCwgcmVnaW9uRGF0YSwgdGhpcy5jYWxsYmFja3MsIGlkLCB0YWdzRGVzY3JpcHRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJSZWdpb24ocmVnaW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBuZXcgcG9seWxpbmUgcmVnaW9uIHRvIHRoZSBtYW5hZ2VyLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHJlZ2lvbiBJRC5cclxuICAgICAqIEBwYXJhbSByZWdpb25EYXRhIC0gVGhlIGBSZWdpb25EYXRhYCBvYmplY3QgZGVmaW5pbmcgcmVnaW9uLlxyXG4gICAgICogQHBhcmFtIHRhZ3NEZXNjcmlwdG9yIC0gVGhlIHRhZ3MgZGVzY3JpcHRvciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRQb2x5bGluZVJlZ2lvbihpZDogc3RyaW5nLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCB0YWdzRGVzY3JpcHRvcjogVGFnc0Rlc2NyaXB0b3IpIHtcclxuICAgICAgICB0aGlzLm1lbnUuaGlkZSgpO1xyXG5cclxuICAgICAgICBjb25zdCByZWdpb24gPSBuZXcgUG9seWxpbmVSZWdpb24odGhpcy5wYXBlciwgdGhpcy5wYXBlclJlY3QsIHJlZ2lvbkRhdGEsIHRoaXMuY2FsbGJhY2tzLCBpZCwgdGFnc0Rlc2NyaXB0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyUmVnaW9uKHJlZ2lvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgbmV3IHBvbHlnb24gcmVnaW9uIHRvIHRoZSBtYW5hZ2VyLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHJlZ2lvbiBJRC5cclxuICAgICAqIEBwYXJhbSByZWdpb25EYXRhIC0gVGhlIGBSZWdpb25EYXRhYCBvYmplY3QgZGVmaW5pbmcgcmVnaW9uLlxyXG4gICAgICogQHBhcmFtIHRhZ3NEZXNjcmlwdG9yIC0gVGhlIHRhZ3MgZGVzY3JpcHRvciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRQb2x5Z29uUmVnaW9uKGlkOiBzdHJpbmcsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEsIHRhZ3NEZXNjcmlwdG9yOiBUYWdzRGVzY3JpcHRvcikge1xyXG4gICAgICAgIHRoaXMubWVudS5oaWRlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IG5ldyBQb2x5Z29uUmVnaW9uKHRoaXMucGFwZXIsIHRoaXMucGFwZXJSZWN0LCByZWdpb25EYXRhLCB0aGlzLmNhbGxiYWNrcywgaWQsIHRhZ3NEZXNjcmlwdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyUmVnaW9uKHJlZ2lvbik7XHJcbiAgICB9XHJcblxyXG4vKiAgICAgLy8gUkVHSU9OIENSRUFUSU9OXHJcbiAgICBwdWJsaWMgZHJhd1JlZ2lvbih4OiBudW1iZXIsIHk6IG51bWJlciwgcmVjdDogUmVjdCwgaWQ6IHN0cmluZywgdGFnc0Rlc2NyaXB0b3I6IFRhZ3NEZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgdGhpcy5tZW51LmhpZGUoKTtcclxuICAgICAgICBsZXQgcmVnaW9uID0gbmV3IFJlY3RSZWdpb24odGhpcy5wYXBlciwgdGhpcy5wYXBlclJlY3QsIG5ldyBQb2ludDJEKHgsIHkpLCByZWN0LCBpZCwgdGFnc0Rlc2NyaXB0b3IsXHJcbiAgICAgICAgICAgIHRoaXMub25NYW5pcHVsYXRpb25CZWdpbl9sb2NhbC5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICB0aGlzLm9uTWFuaXB1bGF0aW9uRW5kX2xvY2FsLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgIHJlZ2lvbi5hcmVhID0gcmVjdC5oZWlnaHQgKiByZWN0LndpZHRoO1xyXG4gICAgICAgIHJlZ2lvbi5vbkNoYW5nZSA9IHRoaXMub25SZWdpb25DaGFuZ2UuYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgcmVnaW9uLnVwZGF0ZVRhZ3MocmVnaW9uLnRhZ3MsIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucmVnaW9uTWFuYWdlckxheWVyLmFkZChyZWdpb24ubm9kZSk7XHJcbiAgICAgICAgdGhpcy5yZWdpb25zLnB1c2gocmVnaW9uKTtcclxuICAgICAgICAvLyBOZWVkIHRvIGRvIGEgY2hlY2sgZm9yIGludmFsaWQgc3RhY2tpbmcgZnJvbSB1c2VyIGdlbmVyYXRlZCBvciBvbGRlciBzYXZlZCBqc29uXHJcbiAgICAgICAgaWYgKHRoaXMucmVnaW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc29ydFJlZ2lvbnNCeUFyZWEoKTtcclxuICAgICAgICAgICAgdGhpcy5yZWRyYXdBbGxSZWdpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdGhpcy5tZW51LnNob3dPblJlZ2lvbihyZWdpb24pO1xyXG4gICAgfSAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3cyBhbGwgcmVnaW9ucy4gUmVpbnNlcnRzIHJlZ2lvbnMgaW4gYWN0dWFsIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVkcmF3QWxsUmVnaW9ucygpIHtcclxuICAgICAgICAvLyByZS1hZGQgYWxsIGVsZW1lbnRzIHRvIERPTSBiYXNlZCBvbiBuZXcgb3JkZXJcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9ucy5mb3JFYWNoKChyZWdpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSByZWdpb24ubm9kZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVnaW9uTWFuYWdlckxheWVyLmFkZChub2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGJvdW5kaW5nIGJveGVzIG9mIHRoZSBzZWxlY3RlZCByZWdpb25zLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBnZXRTZWxlY3RlZFJlZ2lvbnNgIG1ldGhvZCBpbnN0ZWFkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTZWxlY3RlZFJlZ2lvbnNCb3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgcmVnaW9ucyA9IHRoaXMubG9va3VwU2VsZWN0ZWRSZWdpb25zKCkubWFwKChyZWdpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkOiByZWdpb24uSUQsXHJcbiAgICAgICAgICAgICAgICB4OiByZWdpb24ueCxcclxuICAgICAgICAgICAgICAgIHk6IHJlZ2lvbi55LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlZ2lvbi5ib3VuZFJlY3Qud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlZ2lvbi5ib3VuZFJlY3QuaGVpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZWdpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvbGxlY3Rpb24gb2Ygc2VsZWN0ZWQgcmVnaW9ucy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNlbGVjdGVkUmVnaW9ucygpOiBBcnJheTx7IGlkOiBzdHJpbmcsIHJlZ2lvbkRhdGE6IFJlZ2lvbkRhdGEgfT4ge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lvbnMgPSB0aGlzLmxvb2t1cFNlbGVjdGVkUmVnaW9ucygpLm1hcCgocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpZDogcmVnaW9uLklELFxyXG4gICAgICAgICAgICAgICAgcmVnaW9uRGF0YTogcmVnaW9uLnJlZ2lvbkRhdGEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgcmVnaW9uIHdpdGggc3BlY2lmaWVkIGBpZGAuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBJZCBvZiB0aGUgcmVnaW9uIHRvIGRlbGV0ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZVJlZ2lvbkJ5SWQoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMubG9va3VwUmVnaW9uQnlJRChpZCk7XHJcblxyXG4gICAgICAgIGlmIChyZWdpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVJlZ2lvbihyZWdpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uRW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbGwgdGhlIHJlZ2lvbnMgZnJvbSB0aGUgbWFuYWdlci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRlbGV0ZUFsbFJlZ2lvbnMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZWdpb24gb2YgdGhpcy5yZWdpb25zKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbi5yZW1vdmVTdHlsZXMoKTtcclxuICAgICAgICAgICAgcmVnaW9uLm5vZGUucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVnaW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWVudS5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRhZ3Mgb2YgdGhlIHNwZWNpZmllZCByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgYGlkYCBvZiB0aGUgcmVnaW9uIHRvIHVwZGF0ZS5cclxuICAgICAqIEBwYXJhbSB0YWdzRGVzY3JpcHRvciAtIFRoZSBuZXcgdGFncyBkZXNjcmlwdG9yIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVRhZ3NCeUlkKGlkOiBzdHJpbmcsIHRhZ3NEZXNjcmlwdG9yOiBUYWdzRGVzY3JpcHRvcikge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMubG9va3VwUmVnaW9uQnlJRChpZCk7XHJcblxyXG4gICAgICAgIGlmIChyZWdpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZWdpb24udXBkYXRlVGFncyh0YWdzRGVzY3JpcHRvciwgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0YWdzIGZvciBhbGwgc2VsZWN0ZWQgcmVnaW9ucy5cclxuICAgICAqIEBwYXJhbSB0YWdzRGVzY3JpcHRvciAtIFRoZSBuZXcgdGFncyBkZXNjcmlwdG9yIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZVRhZ3NGb3JTZWxlY3RlZFJlZ2lvbnModGFnc0Rlc2NyaXB0b3I6IFRhZ3NEZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgY29uc3QgcmVnaW9ucyA9IHRoaXMubG9va3VwU2VsZWN0ZWRSZWdpb25zKCk7XHJcblxyXG4gICAgICAgIHJlZ2lvbnMuZm9yRWFjaCgocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZ2lvbi51cGRhdGVUYWdzKHRhZ3NEZXNjcmlwdG9yLCB0aGlzLnRhZ3NVcGRhdGVPcHRpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgdGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgYGlkYC5cclxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBgaWRgIG9mIHRoZSByZWdpb24gdG8gc2VsZWN0LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2VsZWN0UmVnaW9uQnlJZChpZDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcmVnaW9uID0gdGhpcy5sb29rdXBSZWdpb25CeUlEKGlkKTtcclxuICAgICAgICB0aGlzLnNlbGVjdFJlZ2lvbihyZWdpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgbWFuYWdlciB0byBzcGVjaWZpZWQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgbmV3IG1hbmFnZXIgd2lkdGguXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyBtYW5hZ2VyIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHR3ID0gd2lkdGggLyB0aGlzLnBhcGVyUmVjdC53aWR0aDtcclxuICAgICAgICBjb25zdCB0aCA9IGhlaWdodCAvIHRoaXMucGFwZXJSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5wYXBlclJlY3QucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLm1lbnUuaGlkZSgpO1xyXG5cclxuICAgICAgICAvLyByZWNhbGN1bGF0ZSBzaXplL3Bvc2l0aW9uIGZvciBhbGwgcmVnaW9ucztcclxuICAgICAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMpIHtcclxuICAgICAgICAgICAgcmVnaW9uLm1vdmUobmV3IFBvaW50MkQocmVnaW9uLnggKiB0dywgcmVnaW9uLnkgKiB0aCkpO1xyXG4gICAgICAgICAgICByZWdpb24ucmVzaXplKHJlZ2lvbi5ib3VuZFJlY3Qud2lkdGggKiB0dywgcmVnaW9uLmJvdW5kUmVjdC5oZWlnaHQgKiB0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnJlZXplcyB0aGUgbWFuYWdlciBhbmQgYWxsIGl0cyBjdXJyZW50IHJlZ2lvbnMuXHJcbiAgICAgKiBAcGFyYW0gbnVhbmNlIC0gW29wdGlvbmFsXSBBZGRpdGlvbmFsIGNzcy1jbGFzcyB0byBhZGQgdG8gdGhlIG1hbmFnZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBmcmVlemUobnVhbmNlPzogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyTGF5ZXIuYWRkQ2xhc3MoXCJmcm96ZW5cIik7XHJcbiAgICAgICAgaWYgKG51YW5jZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uTWFuYWdlckxheWVyLmFkZENsYXNzKG51YW5jZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvemVuTnVhbmNlID0gbnVhbmNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvemVuTnVhbmNlID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tZW51LmhpZGUoKTtcclxuICAgICAgICB0aGlzLnJlZ2lvbnMuZm9yRWFjaCgocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZ2lvbi5mcmVlemUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5pc0Zyb3plblN0YXRlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuZnJlZXplcyB0aGUgbWFuYWdlciBhbmQgYWxsIGl0cyByZWdpb25zLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdW5mcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyTGF5ZXIucmVtb3ZlQ2xhc3MoXCJmcm96ZW5cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvemVuTnVhbmNlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uTWFuYWdlckxheWVyLnJlbW92ZUNsYXNzKHRoaXMuZnJvemVuTnVhbmNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUmVnaW9ucyA9IHRoaXMubG9va3VwU2VsZWN0ZWRSZWdpb25zKCk7XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RlZFJlZ2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1lbnUuc2hvd09uUmVnaW9uKHNlbGVjdGVkUmVnaW9uc1swXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZ2lvbnMuZm9yRWFjaCgocmVnaW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZ2lvbi51bmZyZWV6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmlzRnJvemVuU3RhdGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgZnJlZXppbmcgbW9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvZ2dsZUZyZWV6ZU1vZGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGcm96ZW4pIHtcclxuICAgICAgICAgICAgdGhpcy51bmZyZWV6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgdGFncyBkcmF3aW5nIHNldHRpbmcgdG8gZHJhdyBiYWNrZ3JvdW5kIG9yIG1ha2UgaXQgdHJhbnNwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b2dnbGVCYWNrZ3JvdW5kKCkge1xyXG4gICAgICAgIHRoaXMudGFnc1VwZGF0ZU9wdGlvbnMuc2hvd1JlZ2lvbkJhY2tncm91bmQgPSAhdGhpcy50YWdzVXBkYXRlT3B0aW9ucy5zaG93UmVnaW9uQmFja2dyb3VuZDtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpb25zLmZvckVhY2goKHIpID0+IHtcclxuICAgICAgICAgICAgci51cGRhdGVUYWdzKHIudGFncywgdGhpcy50YWdzVXBkYXRlT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgcmVnaW9uIGJ5IHNwZWNpZmllZCBgaWRgLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGBpZGAgdG8gbG9vayBmb3IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9va3VwUmVnaW9uQnlJRChpZDogc3RyaW5nKTogUmVnaW9uIHtcclxuICAgICAgICBsZXQgcmVnaW9uOiBSZWdpb24gPSBudWxsO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVnaW9ucy5sZW5ndGggJiYgcmVnaW9uID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVnaW9uc1tpXS5JRCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IHRoaXMucmVnaW9uc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWdpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gc29ydCByZWdpb25zIGJ5IHRoZWlyIGFyZWEuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc29ydFJlZ2lvbnNCeUFyZWEoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gcXVpY2tTb3J0KGFycjogUmVnaW9uW10sIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICBsZXQgcGl2b3Q6IG51bWJlcjtcclxuICAgICAgICAgICAgbGV0IHBhcnRpdGlvbkluZGV4OiBudW1iZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBwaXZvdCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uSW5kZXggPSBwYXJ0aXRpb24oYXJyLCBwaXZvdCwgbGVmdCwgcmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNvcnQgbGVmdCBhbmQgcmlnaHRcclxuICAgICAgICAgICAgICAgIHF1aWNrU29ydChhcnIsIGxlZnQsIHBhcnRpdGlvbkluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgICAgICBxdWlja1NvcnQoYXJyLCBwYXJ0aXRpb25JbmRleCArIDEsIHJpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFydGl0aW9uKGFycjogUmVnaW9uW10sIHBpdm90OiBudW1iZXIsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICBjb25zdCBwaXZvdFZhbHVlID0gYXJyW3Bpdm90XS5hcmVhO1xyXG4gICAgICAgICAgICBsZXQgcGFydGl0aW9uSW5kZXggPSBsZWZ0O1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPCByaWdodDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmFyZWEgPiBwaXZvdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dhcChhcnIsIGksIHBhcnRpdGlvbkluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aXRpb25JbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3YXAoYXJyLCByaWdodCwgcGFydGl0aW9uSW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydGl0aW9uSW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzd2FwKGFycjogUmVnaW9uW10sIGk6IG51bWJlciwgajogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGFycltpXSA9IGFycltqXTtcclxuICAgICAgICAgICAgYXJyW2pdID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMucmVnaW9ucy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcXVpY2tTb3J0KHRoaXMucmVnaW9ucywgMCwgdGhpcy5yZWdpb25zLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIGFsbCBzZWxlY3RlZCByZWdpb25zLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvb2t1cFNlbGVjdGVkUmVnaW9ucygpOiBSZWdpb25bXSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IEFycmF5PFJlZ2lvbj4oKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZWdpb24gb2YgdGhpcy5yZWdpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWdpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKHJlZ2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBwcm92aWRlZCByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIHJlZ2lvbiB0byBkZWxldGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGVsZXRlUmVnaW9uKHJlZ2lvbjogUmVnaW9uKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHN0eWxlXHJcbiAgICAgICAgcmVnaW9uLnJlbW92ZVN0eWxlcygpO1xyXG5cclxuICAgICAgICAvLyByZW1vdmUgZWxlbWVudFxyXG4gICAgICAgIHJlZ2lvbi5ub2RlLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMucmVnaW9ucyA9IHRoaXMucmVnaW9ucy5maWx0ZXIoKHIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHIgIT09IHJlZ2lvbjtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tZW51LmhpZGUoKTtcclxuXHJcbiAgICAgICAgaWYgKCh0eXBlb2YgdGhpcy5jYWxsYmFja3Mub25SZWdpb25EZWxldGUpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25SZWdpb25EZWxldGUocmVnaW9uLklELCByZWdpb24ucmVnaW9uRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbGwgc2VsZWN0ZWQgcmVnaW9ucy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBkZWxldGVTZWxlY3RlZFJlZ2lvbnMoKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMubG9va3VwU2VsZWN0ZWRSZWdpb25zKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCByZWdpb24gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVJlZ2lvbihyZWdpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3ROZXh0UmVnaW9uKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uRW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0cyBzcGVjaWZpZWQgcmVnaW9uLlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByZWdpb24gdG8gc2VsZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNlbGVjdFJlZ2lvbihyZWdpb246IFJlZ2lvbikge1xyXG4gICAgICAgIGlmIChyZWdpb24gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdFJlZ2lvbnMocmVnaW9uKTtcclxuICAgICAgICAgICAgcmVnaW9uLnNlbGVjdCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5tZW51LnNob3dPblJlZ2lvbihyZWdpb24pO1xyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvblNlbGVjdGVkKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvblNlbGVjdGVkKHJlZ2lvbi5JRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIGFsbCB0aGUgcmVnaW9ucy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZWxlY3RBbGxSZWdpb25zKCkge1xyXG4gICAgICAgIGxldCByID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMpIHtcclxuICAgICAgICAgICAgciA9IHJlZ2lvbjtcclxuICAgICAgICAgICAgci5zZWxlY3QoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uUmVnaW9uU2VsZWN0ZWQpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uUmVnaW9uU2VsZWN0ZWQoci5JRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLm1lbnUuc2hvd09uUmVnaW9uKHIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgdGhlIG5leHQgcmVnaW9uIChiYXNlZCBvbiBjdXJyZW50IG9yZGVyLCBlLmcuLCBzb3J0ZWQgYnkgYXJlYSkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2VsZWN0TmV4dFJlZ2lvbigpIHtcclxuICAgICAgICBsZXQgcmVnaW9uID0gbnVsbDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWdpb25zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbnNbMF07XHJcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoICYmIHJlZ2lvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWdpb25zW2ldLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSAoaSA9PT0gbGVuZ3RoIC0gMSkgPyB0aGlzLnJlZ2lvbnNbMF0gOiB0aGlzLnJlZ2lvbnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVnaW9uID09IG51bGwgJiYgbGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbnNbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdFJlZ2lvbihyZWdpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgb3IgY2hhbmdlcyByZWdpb24gc2l6ZVxyXG4gICAgICogQHBhcmFtIHJlZ2lvbiAtIFRoZSByZWdpb24gdG8gYmUgY2hhbmdlZC5cclxuICAgICAqIEBwYXJhbSBkeCAtIHgtY29vcmRpbmF0ZSBzaGlmdC5cclxuICAgICAqIEBwYXJhbSBkeSAtIHktY29vcmRpbmF0ZSBzaGlmdC5cclxuICAgICAqIEBwYXJhbSBkdyAtIHdpZHRoLXNoaWZ0LlxyXG4gICAgICogQHBhcmFtIGRoIC0gaGVpZ2h0LXNoaWZ0LlxyXG4gICAgICogQHBhcmFtIGludmVyc2UgLSBmbGFnIGlmIHRoZSBjaGFuZ2UgaXMgaW52ZXJ0ZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzaGFwZVJlZ2lvbihyZWdpb246IFJlZ2lvbiwgZHg6IG51bWJlciwgZHk6IG51bWJlciwgZHc6IG51bWJlciwgZGg6IG51bWJlciwgaW52ZXJzZTogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHc6IG51bWJlcjtcclxuICAgICAgICBsZXQgaDogbnVtYmVyO1xyXG4gICAgICAgIGxldCB4OiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHk6IG51bWJlcjtcclxuICAgICAgICBpZiAoIWludmVyc2UpIHtcclxuICAgICAgICAgICAgdyA9IHJlZ2lvbi5ib3VuZFJlY3Qud2lkdGggKyBNYXRoLmFicyhkdyk7XHJcbiAgICAgICAgICAgIGggPSByZWdpb24uYm91bmRSZWN0LmhlaWdodCArIE1hdGguYWJzKGRoKTtcclxuICAgICAgICAgICAgeCA9IHJlZ2lvbi54ICsgZHggKyAoZHcgPiAwID8gMCA6IGR3KTtcclxuICAgICAgICAgICAgeSA9IHJlZ2lvbi55ICsgZHkgKyAoZGggPiAwID8gMCA6IGRoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3ID0gTWF0aC5tYXgoMCwgcmVnaW9uLmJvdW5kUmVjdC53aWR0aCAtIE1hdGguYWJzKGR3KSk7XHJcbiAgICAgICAgICAgIGggPSBNYXRoLm1heCgwLCByZWdpb24uYm91bmRSZWN0LmhlaWdodCAtIE1hdGguYWJzKGRoKSk7XHJcblxyXG4gICAgICAgICAgICB4ID0gcmVnaW9uLnggKyBkeCArIChkdyA8IDAgPyAwIDogZHcpO1xyXG4gICAgICAgICAgICB5ID0gcmVnaW9uLnkgKyBkeSArIChkaCA8IDAgPyAwIDogZGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcDEgPSBuZXcgUG9pbnQyRCh4LCB5KS5ib3VuZFRvUmVjdCh0aGlzLnBhcGVyUmVjdCk7XHJcbiAgICAgICAgY29uc3QgcDIgPSBuZXcgUG9pbnQyRCh4ICsgdywgeSArIGgpLmJvdW5kVG9SZWN0KHRoaXMucGFwZXJSZWN0KTtcclxuXHJcbiAgICAgICAgcmVnaW9uLm1vdmUocDEpO1xyXG4gICAgICAgIHJlZ2lvbi5yZXNpemUocDIueCAtIHAxLngsIHAyLnkgLSBwMS55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBzZWxlY3RlZCByZWdpb24gd2l0aCBzcGVjaWZpZWQgc2hpZnQgaW4gY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSBkeCAtIHgtY29vcmRpbmF0ZSBzaGlmdC5cclxuICAgICAqIEBwYXJhbSBkeSAtIHktY29vcmRpbmF0ZSBzaGlmdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtb3ZlU2VsZWN0ZWRSZWdpb25zKGR4OiBudW1iZXIsIGR5OiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCByZWdpb25zID0gdGhpcy5sb29rdXBTZWxlY3RlZFJlZ2lvbnMoKTtcclxuICAgICAgICByZWdpb25zLmZvckVhY2goKHIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNoYXBlUmVnaW9uKHIsIGR4LCBkeSwgMCwgMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tZW51LnNob3dPblJlZ2lvbihyZWdpb25zWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhlIHNlbGVjdGVkIHJlZ2lvbiB3aXRoIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0IHNoaWZ0cy5cclxuICAgICAqIEBwYXJhbSBkdyAtIHdpZHRoLXNoaWZ0LlxyXG4gICAgICogQHBhcmFtIGRoIC0gaGVpZ2h0LXNoaWZ0LlxyXG4gICAgICogQHBhcmFtIGludmVyc2UgLSBmbGFnIGlmIHRoZSBjaGFuZ2UgaXMgaW52ZXJ0ZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzaXplU2VsZWN0ZWRSZWdpb25zKGR3OiBudW1iZXIsIGRoOiBudW1iZXIsIGludmVyc2U6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lvbnMgPSB0aGlzLmxvb2t1cFNlbGVjdGVkUmVnaW9ucygpO1xyXG4gICAgICAgIHJlZ2lvbnMuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2hhcGVSZWdpb24ociwgMCwgMCwgZHcsIGRoLCBpbnZlcnNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1lbnUuc2hvd09uUmVnaW9uKHJlZ2lvbnNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvdCBpbnRlcm5hbCBjb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCAtIFJlZmVyZW5jZSB0byB0aGUgVUkgY29tcG9uZW50LlxyXG4gICAgICogQHBhcmFtIHJlZ2lvbkRhdGEgLSBOZXcgUmVnaW9uRGF0YSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdGUgb2YgdGhlIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSBtdWx0aVNlbGVjdGlvbiAtIEZsYWcgZm9yIG11bHRpc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUmVnaW9uQ2hhbmdlKHJlZ2lvbjogUmVnaW9uLCByZWdpb25EYXRhOiBSZWdpb25EYXRhLCBzdGF0ZTogQ2hhbmdlRXZlbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aVNlbGVjdGlvbjogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gcmVzaXplIG9yIGRyYWcgYmVnaW5cclxuICAgICAgICBpZiAoc3RhdGUgPT09IENoYW5nZUV2ZW50VHlwZS5NT1ZFQkVHSU4pIHtcclxuICAgICAgICAgICAgaWYgKCFtdWx0aVNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdFJlZ2lvbnMocmVnaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1lbnUuaGlkZSgpO1xyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvblNlbGVjdGVkKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvblNlbGVjdGVkKHJlZ2lvbi5JRCwgbXVsdGlTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uUmVnaW9uTW92ZUJlZ2luKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvbk1vdmVCZWdpbihyZWdpb24uSUQsIHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuanVzdE1hbmlwdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHJlc2l6aW5nIG9yIGRyYWdnaW5nXHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQ2hhbmdlRXZlbnRUeXBlLk1PVklORykge1xyXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvbk1vdmUpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uUmVnaW9uTW92ZShyZWdpb24uSUQsIHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuanVzdE1hbmlwdWxhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gcmVzaXplIG9yIGRyYWcgZW5kXHJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQ2hhbmdlRXZlbnRUeXBlLk1PVkVFTkQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuanVzdE1hbmlwdWxhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb24uc2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuc2hvd09uUmVnaW9uKHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRSZWdpb25zQnlBcmVhKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhd0FsbFJlZ2lvbnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvbk1vdmVFbmQpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvbk1vdmVFbmQocmVnaW9uLklELCByZWdpb25EYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IENoYW5nZUV2ZW50VHlwZS5TRUxFQ1RJT05UT0dHTEUgJiYgIXRoaXMuanVzdE1hbmlwdWxhdGVkKSB7XHJcbiAgICAgICAgICAgIC8vIHNlbGVjdFxyXG4gICAgICAgICAgICBpZiAoIXJlZ2lvbi5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW11bHRpU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdFJlZ2lvbnMocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlZ2lvbi5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVudS5zaG93T25SZWdpb24ocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uUmVnaW9uU2VsZWN0ZWQpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvblNlbGVjdGVkKHJlZ2lvbi5JRCwgbXVsdGlTZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdW5zZWxlY3RcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbi51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uUmVnaW9uU2VsZWN0ZWQpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblJlZ2lvblNlbGVjdGVkKFwiXCIsIG11bHRpU2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2VsZWN0cyBhbGwgdGhlIHJlZ2lvbnMsIG5heWJlIGV4Y2VwdCB0aGUgb25lIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSBleGNlcHQgLSBSZWdpb24gdG8gaWdub3JlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHVuc2VsZWN0UmVnaW9ucyhleGNlcHQ/OiBSZWdpb24pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lvbiAhPT0gZXhjZXB0KSB7XHJcbiAgICAgICAgICAgICAgICByZWdpb24udW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRzIHJlZ2lvbnMgbWFuYWdlciBVSS5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgZWxlbWVudCB0byBkcmF3IG9uLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkT24ocGFwZXI6IFNuYXAuUGFwZXIpIHtcclxuICAgICAgICB0aGlzLnJlZ2lvbk1hbmFnZXJMYXllciA9IHBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLnJlZ2lvbk1hbmFnZXJMYXllci5hZGRDbGFzcyhcInJlZ2lvbk1hbmFnZXJcIik7XHJcblxyXG4gICAgICAgIHRoaXMubWVudUxheWVyID0gcGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubWVudUxheWVyLmFkZENsYXNzKFwibWVudU1hbmFnZXJcIik7XHJcbiAgICAgICAgdGhpcy5tZW51ID0gbmV3IE1lbnVFbGVtZW50KHBhcGVyLCB0aGlzLnBhcGVyUmVjdCwgbmV3IFJlZ2lvbkRhdGEoMCwgMCwgMCwgMCksIHRoaXMuY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy5tZW51LmFkZEFjdGlvbihcImRlbGV0ZVwiLCBcInRyYXNoXCIsIChyZWdpb246IFJlZ2lvbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVJlZ2lvbihyZWdpb24pO1xyXG4gICAgICAgICAgICB0aGlzLm1lbnUuaGlkZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm1lbnVMYXllci5hZGQodGhpcy5tZW51Lm1lbnVHcm91cCk7XHJcbiAgICAgICAgdGhpcy5tZW51LmhpZGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBzdWJzY3JpYmUgbWFuYWdlciB0byBwb2ludGVyIGFuZCBrZXlib2FyZCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9FdmVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyTGF5ZXIubW91c2VvdmVyKChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkJlZ2luICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkJlZ2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyTGF5ZXIubW91c2VvdXQoKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uTWFuaXB1bGF0aW9uRW5kICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbk1hbmlwdWxhdGlvbkVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgIShlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpICYmXHJcbiAgICAgICAgICAgICAgICAhKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNGcm96ZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0UmVnaW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgYmFja3NwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlU2VsZWN0ZWRSZWdpb25zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3RybCArIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5ICYmICFlLmFsdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3RlZFJlZ2lvbnMoMCwgLTUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZWxlY3RlZFJlZ2lvbnMoMCwgLTUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5hbHRLZXkgJiYgIWUuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZWxlY3RlZFJlZ2lvbnMoMCwgLTUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdHJsICsgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0ZWRSZWdpb25zKDAsIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZWxlY3RlZFJlZ2lvbnMoMCwgNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSAmJiAhZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVNlbGVjdGVkUmVnaW9ucygwLCA1LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3RybCArIGxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkgJiYgIWUuYWx0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGVkUmVnaW9ucygtNSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNoaWZ0S2V5ICYmICFlLmFsdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVNlbGVjdGVkUmVnaW9ucygtNSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSAmJiAhZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVNlbGVjdGVkUmVnaW9ucygtNSwgMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN0cmwgKyByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0ZWRSZWdpb25zKDUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVTZWxlY3RlZFJlZ2lvbnMoNSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSAmJiAhZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVNlbGVjdGVkUmVnaW9ucyg1LCAwLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIShlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpICYmXHJcbiAgICAgICAgICAgICAgICAhKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCkgJiZcclxuICAgICAgICAgICAgICAgICEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Zyb3plbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN0cmwgKyBBLCBjdHJsICsgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiS2V5QVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTnVtcGFkMVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsUmVnaW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIHRoZSBwcm92aWRlZCByZWdpb24gaW4gdGhlIG1hbmFnZXIuXHJcbiAgICAgKiBAcGFyYW0gcmVnaW9uIC0gVGhlIG5ldyByZWdpb24gdG8gcmVnaXN0ZXIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVnaXN0ZXJSZWdpb24ocmVnaW9uOiBSZWdpb24pIHtcclxuICAgICAgICB0aGlzLnVuc2VsZWN0UmVnaW9ucygpO1xyXG4gICAgICAgIHJlZ2lvbi5zZWxlY3QoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyTGF5ZXIuYWRkKHJlZ2lvbi5ub2RlKTtcclxuICAgICAgICB0aGlzLnJlZ2lvbnMucHVzaChyZWdpb24pO1xyXG5cclxuICAgICAgICB0aGlzLm1lbnUuc2hvd09uUmVnaW9uKHJlZ2lvbik7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi9Db3JlL1JlY3RcIjtcclxuXHJcbmltcG9ydCB7IElTZWxlY3RvckNhbGxiYWNrcyB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVNlbGVjdG9yQ2FsbGJhY2tzXCI7XHJcbmltcG9ydCB7IElTZWxlY3RvclNldHRpbmdzLCBTZWxlY3Rpb25Nb2RlIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JU2VsZWN0b3JTZXR0aW5nc1wiO1xyXG5cclxuaW1wb3J0IHsgUG9pbnRTZWxlY3RvciB9IGZyb20gXCIuL1NlbGVjdG9ycy9Qb2ludFNlbGVjdG9yXCI7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VsZWN0b3IgfSBmcm9tIFwiLi9TZWxlY3RvcnMvUG9seWxpbmVTZWxlY3RvclwiO1xyXG5pbXBvcnQgeyBQb2x5Z29uU2VsZWN0b3IgfSBmcm9tIFwiLi9TZWxlY3RvcnMvUG9seWdvblNlbGVjdG9yXCI7XHJcbmltcG9ydCB7IFJlY3RDb3B5U2VsZWN0b3IgfSBmcm9tIFwiLi9TZWxlY3RvcnMvUmVjdENvcHlTZWxlY3RvclwiO1xyXG5pbXBvcnQgeyBSZWN0U2VsZWN0b3IgfSBmcm9tIFwiLi9TZWxlY3RvcnMvUmVjdFNlbGVjdG9yXCI7XHJcbmltcG9ydCB7IFNlbGVjdG9yIH0gZnJvbSBcIi4vU2VsZWN0b3JzL1NlbGVjdG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlZ2lvbiBzZWxlY3Rpb24gbWFuYWdlci5cclxuICogQHJlbWFya3MgVGhlIG5hbWluZyBvZiB0aGUgY2xhc3MgaXMgaGlzdG9yaWNhbCBwZXIgdGhlIGlkZWEgdG8gc3BlY2lmeSB0aGVcclxuICogcmVnaW9uIGFyZWEgdG8gYmUgc2VsZWN0ZWQuIFRodXMgQXJlYVNlbGVjdG9yLlxyXG4gKiBAdG9kbyBDb25zaWRlciByZW5hbWluZy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcmVhU2VsZWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHRlbXBsYXRlIHNpemUgZm9yIHRoZSBgUmVjdENvcHlTZWxlY3RvcmAuXHJcbiAgICAgKiBAdG9kbyBNb3ZlIHRvIHRoZSBgUmVjdENvcHlTZWxlY3RvcmAgY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRGVmYXVsdFRlbXBsYXRlU2l6ZTogUmVjdCA9IG5ldyBSZWN0KDIwLCAyMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBzZWxlY3RvcidzIGNhbGxiYWNrcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGNhbGxiYWNrczogSVNlbGVjdG9yQ2FsbGJhY2tzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlZmVyZW5jZSB0byB0aGUgaG9zdCBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXJlbnROb2RlOiBTVkdTVkdFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlZmVyZW5jZSB0byB0aGUgYFNuYXAuUGFwZXJgIGVsZW1lbnQgdG8gZHJhdyBvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwYXBlcjogU25hcC5QYXBlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBib3VuZGluZyByZWN0IGZvciBzZWxlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYm91bmRSZWN0OiBSZWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGdyb3VwaW5nIGVsZW1lbnQgZm9yIHNlbGVjdG9ycy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhcmVhU2VsZWN0b3JMYXllcjogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNlbGVjdG9yOiBTZWxlY3RvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgc2VsZWN0b3Igb3B0aW9ucywgaWYgYW55LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNlbGVjdG9yU2V0dGluZ3M6IElTZWxlY3RvclNldHRpbmdzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGEgYFJlY3RTZWxlY3RvcmAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHJlY3RTZWxlY3RvcjogUmVjdFNlbGVjdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGEgYFJlY3RDb3B5U2VsZWN0b3JgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWN0Q29weVNlbGVjdG9yOiBSZWN0Q29weVNlbGVjdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGEgYFBvaW50U2VsZWN0b3JgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwb2ludFNlbGVjdG9yOiBQb2ludFNlbGVjdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGEgYFBvbHlsaW5lU2VsZWN0b3JgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwb2x5bGluZVNlbGVjdG9yOiBQb2x5bGluZVNlbGVjdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIGEgYFBvbHlnb25TZWxlY3RvcmAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBvbHlnb25TZWxlY3RvcjogUG9seWdvblNlbGVjdG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgZmxhZyB0byB0cmFjayBzZWxlY3RvciB2aXNpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBBcmVhU2VsZWN0b3JgIG1hbmFnZXIuXHJcbiAgICAgKiBAcGFyYW0gc3ZnSG9zdCAtIFRoZSBob3N0IFNWRyBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc3ZnSG9zdDogU1ZHU1ZHRWxlbWVudCwgY2FsbGJhY2tzPzogSVNlbGVjdG9yQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gc3ZnSG9zdDtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkxvY2tlZDogbnVsbCxcclxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uQmVnaW46IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkVuZDogbnVsbCxcclxuICAgICAgICAgICAgICAgIG9uVW5sb2NrZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJ1aWxkVUlFbGVtZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyBzZWxlY3RvcnMgdG8gc3BlY2lmaWVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG5ldyBgd2lkdGhgIGZvciBzZWxlY3Rvci5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGBoZWlnaHRgIGZvciBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkICYmIGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRSZWN0LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kUmVjdC5yZXNpemUodGhpcy5wYXJlbnROb2RlLndpZHRoLmJhc2VWYWwudmFsdWUsIHRoaXMucGFyZW50Tm9kZS5oZWlnaHQuYmFzZVZhbC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIHRoZSBjdXJyZW50IHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IuZW5hYmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IucmVzaXplKHRoaXMuYm91bmRSZWN0LndpZHRoLCB0aGlzLmJvdW5kUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGVzIHRoZSBjdXJyZW50IHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzYWJsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RvciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmRpc2FibGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBjdXJyZW50IHNlbGVjdG9yIHZpc2libGUgYW5kIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlKCk7XHJcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgY3VycmVudCBzZWxlY3RvciBoaWRkZW4gYW5kIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGlkZSgpIHtcclxuICAgICAgICB0aGlzLmRpc2FibGUoKTtcclxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgc2VsZWN0aW9uIG1vZGUgKGNoYW5nZXMgYWN0aXZlIHNlbGVjdG9yKS5cclxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25Nb2RlIC0gU2VsZWN0b3IgbW9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNlbGVjdGlvbk1vZGUoc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyBzZWxlY3Rpb24gbW9kZSAoY2hhbmdlcyBhY3RpdmUgc2VsZWN0b3IpLlxyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gU2VsZWN0b3Igc2V0dGluZ3MsIGluY2x1ZGluZyBzZWxlY3Rpb24gbW9kZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2VsZWN0aW9uTW9kZShzZXR0aW5nczogSVNlbGVjdG9yU2V0dGluZ3MpO1xyXG4gICAgcHVibGljIHNldFNlbGVjdGlvbk1vZGUoc2V0dGluZ3M6IElTZWxlY3RvclNldHRpbmdzIHwgU2VsZWN0aW9uTW9kZSkge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IG51bGwgfHwgc2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICBtb2RlOiBTZWxlY3Rpb25Nb2RlLk5PTkUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICgoc2V0dGluZ3MgYXMgSVNlbGVjdG9yU2V0dGluZ3MpLm1vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yU2V0dGluZ3MgPSBzZXR0aW5ncyBhcyBJU2VsZWN0b3JTZXR0aW5ncztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yU2V0dGluZ3MgPSB7IG1vZGU6IHNldHRpbmdzIGFzIFNlbGVjdGlvbk1vZGUgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbk1vZGUgPSB0aGlzLnNlbGVjdG9yU2V0dGluZ3MubW9kZTtcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuTk9ORSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5DT1BZUkVDVCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5yZWN0Q29weVNlbGVjdG9yO1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuc2VsZWN0b3JTZXR0aW5ncy50ZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjdENvcHlTZWxlY3Rvci5zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3RDb3B5U2VsZWN0b3Iuc2V0VGVtcGxhdGUoQXJlYVNlbGVjdG9yLkRlZmF1bHRUZW1wbGF0ZVNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLlJFQ1QpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMucmVjdFNlbGVjdG9yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QT0lOVCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5wb2ludFNlbGVjdG9yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QT0xZTElORSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5wb2x5bGluZVNlbGVjdG9yO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QT0xZR09OKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnBvbHlnb25TZWxlY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlc3RvcmUgZW5hYmxlbWVudCBzdGF0dXNcclxuICAgICAgICB0aGlzLmVuYWJsZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgb3B0aW9ucyAoc2V0dGluZ3MpIGZvciBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNlbGVjdG9yU2V0dGluZ3MoKTogSVNlbGVjdG9yU2V0dGluZ3Mge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yU2V0dGluZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIFVJIG9mIHRoZSBBcmVhU2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRVSUVsZW1lbnRzKCkge1xyXG4gICAgICAgIHRoaXMucGFwZXIgPSBTbmFwKHRoaXMucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgdGhpcy5ib3VuZFJlY3QgPSBuZXcgUmVjdCh0aGlzLnBhcmVudE5vZGUud2lkdGguYmFzZVZhbC52YWx1ZSwgdGhpcy5wYXJlbnROb2RlLmhlaWdodC5iYXNlVmFsLnZhbHVlKTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhU2VsZWN0b3JMYXllciA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMuYXJlYVNlbGVjdG9yTGF5ZXIuYWRkQ2xhc3MoXCJhcmVhU2VsZWN0b3JcIik7XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdG9yID0gbmV3IFJlY3RTZWxlY3Rvcih0aGlzLnBhcmVudE5vZGUsIHRoaXMucGFwZXIsIHRoaXMuYm91bmRSZWN0LCB0aGlzLmNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy5yZWN0Q29weVNlbGVjdG9yID0gbmV3IFJlY3RDb3B5U2VsZWN0b3IodGhpcy5wYXJlbnROb2RlLCB0aGlzLnBhcGVyLCB0aGlzLmJvdW5kUmVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmVjdCgwLCAwKSwgdGhpcy5jYWxsYmFja3MpO1xyXG4gICAgICAgIHRoaXMucG9pbnRTZWxlY3RvciA9IG5ldyBQb2ludFNlbGVjdG9yKHRoaXMucGFyZW50Tm9kZSwgdGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QsIHRoaXMuY2FsbGJhY2tzKTtcclxuICAgICAgICB0aGlzLnBvbHlsaW5lU2VsZWN0b3IgPSBuZXcgUG9seWxpbmVTZWxlY3Rvcih0aGlzLnBhcmVudE5vZGUsIHRoaXMucGFwZXIsIHRoaXMuYm91bmRSZWN0LCB0aGlzLmNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uU2VsZWN0b3IgPSBuZXcgUG9seWdvblNlbGVjdG9yKHRoaXMucGFyZW50Tm9kZSwgdGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QsIHRoaXMuY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMucmVjdFNlbGVjdG9yO1xyXG5cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rvci5lbmFibGUoKTtcclxuICAgICAgICB0aGlzLnJlY3RDb3B5U2VsZWN0b3IuZGlzYWJsZSgpO1xyXG4gICAgICAgIHRoaXMucG9pbnRTZWxlY3Rvci5kaXNhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5wb2x5bGluZVNlbGVjdG9yLmRpc2FibGUoKTtcclxuICAgICAgICB0aGlzLnBvbHlnb25TZWxlY3Rvci5kaXNhYmxlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IuaGlkZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWFTZWxlY3RvckxheWVyLmFkZCh0aGlzLnJlY3RTZWxlY3Rvci5ub2RlKTtcclxuICAgICAgICB0aGlzLmFyZWFTZWxlY3RvckxheWVyLmFkZCh0aGlzLnJlY3RDb3B5U2VsZWN0b3Iubm9kZSk7XHJcbiAgICAgICAgdGhpcy5hcmVhU2VsZWN0b3JMYXllci5hZGQodGhpcy5wb2ludFNlbGVjdG9yLm5vZGUpO1xyXG4gICAgICAgIHRoaXMuYXJlYVNlbGVjdG9yTGF5ZXIuYWRkKHRoaXMucG9seWxpbmVTZWxlY3Rvci5ub2RlKTtcclxuICAgICAgICB0aGlzLmFyZWFTZWxlY3RvckxheWVyLmFkZCh0aGlzLnBvbHlnb25TZWxlY3Rvci5ub2RlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBQb2ludDJEIH0gZnJvbSBcIi4uLy4uL0NvcmUvUG9pbnQyRFwiO1xyXG5pbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVjdFwiO1xyXG5pbXBvcnQgeyBJTW92YWJsZSB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSU1vdmFibGVcIjtcclxuXHJcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiLi9FbGVtZW50XCI7XHJcbmltcG9ydCB7IElQb2ludDJEIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUG9pbnQyRFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjcm9zcyBlbGVtZW50IGZvciBzZWxlY3RvcnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ3Jvc3NFbGVtZW50IGV4dGVuZHMgRWxlbWVudCBpbXBsZW1lbnRzIElQb2ludDJEIHtcclxuICAgIC8qKlxyXG4gICAgICogSG9yaXpvbnRhbCBsaW5lIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaGw6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcnRpY2FsIGxpbmUgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2bDogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmlzdWFsIGNlbnRlciBvZiB0aGUgY3Jvc3MuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2VudGVyOiBQb2ludDJEO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB4YC1jb29yZGluYXRlIG9mIHRoZSBjcm9zcyBjZW50ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci54O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB5YC1jb29yZGluYXRlIG9mIHRoZSBjcm9zcyBjZW50ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYENyb3NzRWxlbWVudGAuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIG9iamVjdCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIGJvdW5kUmVjdCAtIFRoZSBwYXJlbnQgYm91bmRpbmcgYm94IGZvciBzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBib3VuZFJlY3Q6IFJlY3QpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgYm91bmRSZWN0KTtcclxuICAgICAgICB0aGlzLmJ1aWxkVUlFbGVtZW50cygpO1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQm91bmRzIHRoZSBjcm9zcyBjZW50ZXIgdG8gdGhlIHNwZWNpZmllZCBib3guXHJcbiAgICAgKiBAcGFyYW0gcmVjdCAtIFRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBib3VuZFRvUmVjdChyZWN0OiBSZWN0KTogUG9pbnQyRCB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludDJEKHRoaXMueCwgdGhpcy55KS5ib3VuZFRvUmVjdChyZWN0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIGNyb3NzIHRvIHNwZWNpZmllZCBwb2ludCwgYXBwbHlpbmcgYm91bmRpbmcgYW5kIHRha2luZyBpbnRvIGFjY291bnQgc3F1YXJlIG1vdmVtZW50IG1vZGlmaWNhdG9yLlxyXG4gICAgICogQHBhcmFtIHAgLSBUaGUgbmV3IGNyb3NzIGNlbnRlciBsb2NhdGlvbi5cclxuICAgICAqIEBwYXJhbSByZWN0IC0gVGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqIEBwYXJhbSBzcXVhcmUgLSBUaGUgc3F1YXJlIG1vdmVtZW50IGZsYWcuXHJcbiAgICAgKiBAcGFyYW0gcmVmIC0gVGhlIHJlZmVyZW5jZSBwb2ludCBmb3Igc3F1YXJlLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbW92ZShwOiBJUG9pbnQyRCwgYm91bmRSZWN0OiBSZWN0LCBzcXVhcmU6IGJvb2xlYW4gPSBmYWxzZSwgcmVmOiBJUG9pbnQyRCA9IG51bGwpIHtcclxuICAgICAgICBjb25zdCBucDogUG9pbnQyRCA9IG5ldyBQb2ludDJEKHApLmJvdW5kVG9SZWN0KGJvdW5kUmVjdCk7XHJcblxyXG4gICAgICAgIGlmIChzcXVhcmUpIHtcclxuICAgICAgICAgICAgY29uc3QgZHggPSBNYXRoLmFicyhucC54IC0gcmVmLngpO1xyXG4gICAgICAgICAgICBjb25zdCB2eCA9IE1hdGguc2lnbihucC54IC0gcmVmLngpO1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IE1hdGguYWJzKG5wLnkgLSByZWYueSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZ5ID0gTWF0aC5zaWduKG5wLnkgLSByZWYueSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkID0gTWF0aC5taW4oZHgsIGR5KTtcclxuICAgICAgICAgICAgbnAueCA9IHJlZi54ICsgZCAqIHZ4O1xyXG4gICAgICAgICAgICBucC55ID0gcmVmLnkgKyBkICogdnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNlbnRlci5tb3ZlKG5wKTtcclxuXHJcbiAgICAgICAgdGhpcy52bC5ub2RlLnNldEF0dHJpYnV0ZShcIngxXCIsIG5wLngudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgdGhpcy52bC5ub2RlLnNldEF0dHJpYnV0ZShcIngyXCIsIG5wLngudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgdGhpcy52bC5ub2RlLnNldEF0dHJpYnV0ZShcInkyXCIsIGJvdW5kUmVjdC5oZWlnaHQudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgIHRoaXMuaGwubm9kZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBucC55LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHRoaXMuaGwubm9kZS5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBib3VuZFJlY3Qud2lkdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgdGhpcy5obC5ub2RlLnNldEF0dHJpYnV0ZShcInkyXCIsIG5wLnkudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSBjcm9zcyBlbGVtZW50IHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgYHdpZHRoYC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGBoZWlnaHRgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudmwubm9kZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBoZWlnaHQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgdGhpcy5obC5ub2RlLnNldEF0dHJpYnV0ZShcIngyXCIsIHdpZHRoLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHRoZSB2aXN1YWwgcHJlc2VudGF0aW9uIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkVUlFbGVtZW50cygpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0aWNhbExpbmU6IFNuYXAuRWxlbWVudCA9IHRoaXMucGFwZXIubGluZSgwLCAwLCAwLCB0aGlzLmJvdW5kUmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxMaW5lOiBTbmFwLkVsZW1lbnQgPSB0aGlzLnBhcGVyLmxpbmUoMCwgMCwgdGhpcy5ib3VuZFJlY3Qud2lkdGgsIDApO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLnBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJjcm9zc1N0eWxlXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodmVydGljYWxMaW5lKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKGhvcml6b250YWxMaW5lKTtcclxuXHJcbiAgICAgICAgdGhpcy5obCA9IGhvcml6b250YWxMaW5lO1xyXG4gICAgICAgIHRoaXMudmwgPSB2ZXJ0aWNhbExpbmU7XHJcblxyXG4gICAgICAgIHRoaXMuY2VudGVyID0gbmV3IFBvaW50MkQoMCwgMCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgSUhpZGVhYmxlIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JSGlkZWFkYmxlXCI7XHJcbmltcG9ydCB7IElSZXNpemFibGUgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lSZXNpemFibGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgYnVpbGRpbmcgYmxvY2tzIG9mIHNlbGVjdG9ycy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFbGVtZW50IGltcGxlbWVudHMgSUhpZGVhYmxlLCBJUmVzaXphYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBTbmFwLkVsZW1lbnRgIG9iamVjdCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb24gaW50byBTVkctdHJlZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG5vZGU6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBwYXBlcjogU25hcC5QYXBlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXJlbnQgYm91bmRpbmcgYm94IGZvciBzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBib3VuZFJlY3Q6IFJlY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZWxlbWVudCB2aXNpYmlsaXR5IGZsYWcuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBpc1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB3aWR0aGAgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRSZWN0LndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBoZWlnaHRgIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZFJlY3QuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYEVsZW1lbnRgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gYm91bmRSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIHNlbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIGJvdW5kUmVjdDogUmVjdCkge1xyXG4gICAgICAgIHRoaXMucGFwZXIgPSBwYXBlcjtcclxuICAgICAgICB0aGlzLmJvdW5kUmVjdCA9IGJvdW5kUmVjdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIGVsZW1lbWVudCB2aXN1YWxseSBoaWRkZW4uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoaWRlKCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5ub2RlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIGVsZW1lbnQgdmlzaWJsZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlLm5vZGUuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyBlbGVtZW50IHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIE5ldyBlbGVtZW50IGB3aWR0aGAuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gTmV3IGVsZW1lbnQgYGhlaWdodGAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmJvdW5kUmVjdC5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gXCIuL0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgUmVjdEVsZW1lbnQgfSBmcm9tIFwiLi9SZWN0RWxlbWVudFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYXNrIGVsZW1lbnQgZm9yIHNlbGVjdG9yc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1hc2tFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIG1hc2sgY29tcG9zaXRpb24gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtYXNrOiBSZWN0RWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGxheWVyIGZvciB0aGUgbWFzayBjb3Zlci5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtYXNrSW46IFJlY3RFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwgbGF5ZXIgZm9yIHRoZSBtYXNrIGZpbHRlci5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtYXNrT3V0OiB7IG5vZGU6IFNuYXAuRWxlbWVudCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgTWFza0VsZW1lbnRgLlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBvYmplY3QgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBib3VuZFJlY3QgLSBUaGUgcGFyZW50IGJvdW5kaW5nIGJveCBmb3Igc2VsZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIG1hc2tPdXQgLSBUaGUgZWxlbWVudCB0byBiZSB1c2VkIGFzIG1hc2sgZmlsdGVyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgYm91bmRSZWN0OiBSZWN0LCBtYXNrT3V0OiB7IG5vZGU6IFNuYXAuRWxlbWVudCB9KSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIGJvdW5kUmVjdCk7XHJcbiAgICAgICAgdGhpcy5tYXNrT3V0ID0gbWFza091dDtcclxuICAgICAgICB0aGlzLmJ1aWxkVUlFbGVtZW50cygpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKGJvdW5kUmVjdC53aWR0aCwgYm91bmRSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgdGhlIGVsZW1lbnQgdG8gc3BlY2lmaWVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIC0gVGhlIG5ldyBgd2lkdGhgLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCAtIFRoZSBuZXcgYGhlaWdodGAuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5tYXNrLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm1hc2tJbi5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgdGhlIHZpc3VhbCBwcmVzZW50YXRpb24gb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRVSUVsZW1lbnRzKCkge1xyXG4gICAgICAgIHRoaXMubWFzayA9IHRoaXMuY3JlYXRlTWFzaygpO1xyXG5cclxuICAgICAgICB0aGlzLm1hc2tJbiA9IHRoaXMuY3JlYXRlTWFza0luKCk7XHJcbiAgICAgICAgdGhpcy5tYXNrT3V0Lm5vZGUuYWRkQ2xhc3MoXCJtYXNrT3V0U3R5bGVcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkTWFzayA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIGNvbWJpbmVkTWFzay5hZGQodGhpcy5tYXNrSW4ubm9kZSk7XHJcbiAgICAgICAgY29tYmluZWRNYXNrLmFkZCh0aGlzLm1hc2tPdXQubm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMubWFzay5ub2RlLmF0dHIoe1xyXG4gICAgICAgICAgICBtYXNrOiBjb21iaW5lZE1hc2ssXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMubWFzay5ub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSBtYXNrIHJlY3QuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlTWFzaygpOiBSZWN0RWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgcjogUmVjdEVsZW1lbnQgPSBuZXcgUmVjdEVsZW1lbnQodGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QsIHRoaXMuYm91bmRSZWN0KTtcclxuICAgICAgICByLm5vZGUuYWRkQ2xhc3MoXCJtYXNrU3R5bGVcIik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnVpbGQgdGhlIG1hc2staW4gcmVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVNYXNrSW4oKTogUmVjdEVsZW1lbnQge1xyXG4gICAgICAgIGNvbnN0IHI6IFJlY3RFbGVtZW50ID0gbmV3IFJlY3RFbGVtZW50KHRoaXMucGFwZXIsIHRoaXMuYm91bmRSZWN0LCB0aGlzLmJvdW5kUmVjdCk7XHJcbiAgICAgICAgci5ub2RlLmFkZENsYXNzKFwibWFza0luU3R5bGVcIik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuXHJcbmltcG9ydCB7IEVsZW1lbnR9IGZyb20gXCIuL0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgSVBvaW50MkQgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lQb2ludDJEXCI7XHJcbmltcG9ydCB7IElSZWN0IH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JUmVjdFwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZWN0IGVsZW1lbnQgZm9yIHNlbGVjdG9yc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlY3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCBpbXBsZW1lbnRzIElQb2ludDJEIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlY3Qgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlY3Q6IFJlY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWaXN1YWwgY2VudGVyIG9mIHRoZSBjcm9zcy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvcmlnaW5Qb2ludDogUG9pbnQyRDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgeGAtY29vcmRpbmF0ZSBvZiB0aGUgY3Jvc3MgY2VudGVyLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5Qb2ludC54O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGB5YC1jb29yZGluYXRlIG9mIHRoZSBjcm9zcyBjZW50ZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpblBvaW50Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBuZXcgYFJlY3RFbGVtZW50YC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgb2JqZWN0IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gYm91bmRSZWN0IC0gVGhlIHBhcmVudCBib3VuZGluZyBib3ggZm9yIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSByZWN0IC0gVGhlIHJlY3Qgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFwZXI6IFNuYXAuUGFwZXIsIGJvdW5kUmVjdDogUmVjdCwgcmVjdDogSVJlY3QpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgYm91bmRSZWN0KTtcclxuICAgICAgICB0aGlzLnJlY3QgPSBuZXcgUmVjdChyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2ludCA9IG5ldyBQb2ludDJEKDAsIDApO1xyXG4gICAgICAgIHRoaXMuYnVpbGRVSUVsZW1lbnRzKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyByZWN0IGVsZW1lbnQgdG8gc3BlY2lmaWVkIGxvY2F0aW9uLlxyXG4gICAgICogQHBhcmFtIHAgLSBUaGUgbmV3IHJlY3QgbG9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtb3ZlKHA6IFBvaW50MkQpIHtcclxuICAgICAgICB0aGlzLm5vZGUubm9kZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHAueC50b1N0cmluZygpKTtcclxuICAgICAgICB0aGlzLm5vZGUubm9kZS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHAueS50b1N0cmluZygpKTtcclxuICAgICAgICB0aGlzLm9yaWdpblBvaW50Lm1vdmUocCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSBlbGVtZW50IHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgYHdpZHRoYC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGBoZWlnaHRgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZWN0LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm5vZGUubm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHRoaXMubm9kZS5ub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHRoZSB2aXN1YWwgcHJlc2VudGF0aW9uIG9mIHRoZSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkVUlFbGVtZW50cygpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLnBhcGVyLnJlY3QoMCwgMCwgdGhpcy5yZWN0LndpZHRoLCB0aGlzLnJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IElFdmVudERlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lFdmVudERlc2NyaXB0b3JcIjtcclxuaW1wb3J0IHsgSVNlbGVjdG9yQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JU2VsZWN0b3JDYWxsYmFja3NcIjtcclxuXHJcbmltcG9ydCB7IENyb3NzRWxlbWVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvQ3Jvc3NFbGVtZW50XCI7XHJcbmltcG9ydCB7IFNlbGVjdG9yIH0gZnJvbSBcIi4vU2VsZWN0b3JcIjtcclxuaW1wb3J0IHsgSVBvaW50MkQgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lQb2ludDJEXCI7XHJcblxyXG4vKipcclxuICogVGhlIHNlbGVjdG9yIHRvIGRlZmluZSBhIHBvaW50LXJlZ2lvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQb2ludFNlbGVjdG9yIGV4dGVuZHMgU2VsZWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHJhZGl1cyBmb3IgdGhlIHBvaW50IGVsZW1lbnQuIENhbiBiZSByZWRlZmluZWQgdGhyb3VnaCBjc3Mgc3R5bGVzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBERUZBVUxUX1BPSU5UX1JBRElVUzogbnVtYmVyID0gNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgQ3Jvc3NFbGVtZW50YCB0byBkZWZpbmUgcG9pbnQgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcm9zc0E6IENyb3NzRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZW1wb3JhcnkgcG9pbnQgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwb2ludDogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYFBvaW50U2VsZWN0b3JgIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IFNWRy1lbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHBhcGVyIC0gVGhlIGBTbmFwLlBhcGVyYCBlbGVtZW50IHRvIGRyYXcgb24uXHJcbiAgICAgKiBAcGFyYW0gYm91bmRSZWN0IC0gVGhlIGJvdW5kaW5nIGJveC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogU1ZHU1ZHRWxlbWVudCwgcGFwZXI6IFNuYXAuUGFwZXIsIGJvdW5kUmVjdDogUmVjdCwgY2FsbGJhY2tzPzogSVNlbGVjdG9yQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgc3VwZXIocGFyZW50LCBwYXBlciwgYm91bmRSZWN0LCBjYWxsYmFja3MpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRVSUVsZW1lbnRzKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSBzZWxlY3RvciB0byBzcGVjaWZpZWQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgbmV3IGB3aWR0aGAuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyBgaGVpZ2h0YC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNyb3NzQS5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoaWRlKCkge1xyXG4gICAgICAgIHN1cGVyLmhpZGUoKTtcclxuICAgICAgICB0aGlzLmhpZGVBbGwoW3RoaXMuY3Jvc3NBLCB0aGlzLnBvaW50XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIHN1cGVyLnNob3coKTtcclxuICAgICAgICB0aGlzLnNob3dBbGwoW3RoaXMuY3Jvc3NBLCB0aGlzLnBvaW50XSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgc2VsZWN0b3IncyBVSS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZFVJRWxlbWVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwicG9pbnRTZWxlY3RvclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc0EgPSBuZXcgQ3Jvc3NFbGVtZW50KHRoaXMucGFwZXIsIHRoaXMuYm91bmRSZWN0KTtcclxuICAgICAgICB0aGlzLnBvaW50ID0gdGhpcy5wYXBlci5jaXJjbGUoMCwgMCwgUG9pbnRTZWxlY3Rvci5ERUZBVUxUX1BPSU5UX1JBRElVUyk7XHJcbiAgICAgICAgdGhpcy5wb2ludC5hZGRDbGFzcyhcInBvaW50U3R5bGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5jcm9zc0Eubm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLnBvaW50KTtcclxuXHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzOiBJRXZlbnREZXNjcmlwdG9yW10gPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBcInBvaW50ZXJlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6ICgpID0+IHRoaXMuc2hvdygpLFxyXG4gICAgICAgICAgICAgICAgYnlwYXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwicG9pbnRlcmxlYXZlXCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiB0aGlzLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogKCkgPT4gdGhpcy5oaWRlKCksXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVyZG93blwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVQb2ludCh0aGlzLnBvaW50LCB0aGlzLmNyb3NzQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkJlZ2luID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TZWxlY3Rpb25CZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVydXBcIixcclxuICAgICAgICAgICAgICAgIGJhc2U6IHRoaXMucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyOiAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kKFJlZ2lvbkRhdGEuQnVpbGRQb2ludFJlZ2lvbkRhdGEodGhpcy5jcm9zc0EueCwgdGhpcy5jcm9zc0EueSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVybW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQb2ludDJEKGUuY2xpZW50WCAtIHJlY3RbMF0ubGVmdCwgZS5jbGllbnRZIC0gcmVjdFswXS50b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NBLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVQb2ludCh0aGlzLnBvaW50LCB0aGlzLmNyb3NzQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cyhsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFBvaW50MkQgfSBmcm9tIFwiLi4vLi4vQ29yZS9Qb2ludDJEXCI7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWN0XCI7XHJcbmltcG9ydCB7IFJlZ2lvbkRhdGEsIFJlZ2lvbkRhdGFUeXBlIH0gZnJvbSBcIi4uLy4uL0NvcmUvUmVnaW9uRGF0YVwiO1xyXG5cclxuaW1wb3J0IHsgSUV2ZW50RGVzY3JpcHRvciB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSUV2ZW50RGVzY3JpcHRvclwiO1xyXG5pbXBvcnQgeyBJTW92YWJsZSB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSU1vdmFibGVcIjtcclxuaW1wb3J0IHsgSVNlbGVjdG9yQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JU2VsZWN0b3JDYWxsYmFja3NcIjtcclxuXHJcbmltcG9ydCB7IENyb3NzRWxlbWVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvQ3Jvc3NFbGVtZW50XCI7XHJcbmltcG9ydCB7IFNlbGVjdG9yIH0gZnJvbSBcIi4vU2VsZWN0b3JcIjtcclxuaW1wb3J0IHsgSVBvaW50MkQgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lQb2ludDJEXCI7XHJcblxyXG4vKipcclxuICogVGhlIHNlbGVjdG9yIHRvIGRlZmluZSBhIHBvbHlnb24tcmVnaW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvbHlnb25TZWxlY3RvciBleHRlbmRzIFNlbGVjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBDcm9zc0VsZW1lbnRgIHRvIGRlZmluZSBwb2ludCBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyb3NzQTogQ3Jvc3NFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGVsZW1lbnQgdG8gYWRkIGEgbmV3IHBvaW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG5leHRQb2ludDogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpbmUgc2VnbWVudCB0byBhZGQgYSBuZXcgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbmV4dFNlZ21lbnQ6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaW5lIHRvIHRoZSBuZXcgcG9pbnQgZnJvbSB0aGUgZmlyc3QgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbmV4dEwxOiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGluZSB0byB0aGUgbmV3IHBvaW50IGZyb20gdGhlIGxhc3QgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbmV4dExOOiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JvdXBpbmcgZWxlbWVudCBmb3IgcG9seWxpbmUgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBvaW50c0dyb3VwOiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9seWdvbiBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBvbHlnb246IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3Rpb24gb2YgcG9pbnRzIGNvbXBvc2luZyBwb2x5bGluZSBkYXRhLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBvaW50czogUG9pbnQyRFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhc3QgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbGFzdFBvaW50OiBQb2ludDJEO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBwb2ludCByYWRpdXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcG9pbnRSYWRpdXM6IG51bWJlciA9IDM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHN0YXRlIG9mIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzQ2FwdHVyaW5nOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgUG9seWdvblNlbGVjdG9yYCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBTVkctZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgZWxlbWVudCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIGJvdW5kUmVjdCAtIFRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIC0gVGhlIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFNWR1NWR0VsZW1lbnQsIHBhcGVyOiBTbmFwLlBhcGVyLCBib3VuZFJlY3Q6IFJlY3QsIGNhbGxiYWNrcz86IElTZWxlY3RvckNhbGxiYWNrcykge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgcGFwZXIsIGJvdW5kUmVjdCwgY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy5idWlsZFVJRWxlbWVudHMoKTtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSBzZWxlY3RvciB0byBzcGVjaWZpZWQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgbmV3IGB3aWR0aGAuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyBgaGVpZ2h0YC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNyb3NzQS5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoaWRlKCkge1xyXG4gICAgICAgIHN1cGVyLmhpZGUoKTtcclxuICAgICAgICB0aGlzLmhpZGVBbGwoW3RoaXMuY3Jvc3NBLCB0aGlzLm5leHRQb2ludCwgdGhpcy5uZXh0U2VnbWVudCwgdGhpcy5wb2x5Z29uLCB0aGlzLnBvaW50c0dyb3VwXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIHN1cGVyLnNob3coKTtcclxuICAgICAgICB0aGlzLnNob3dBbGwoW3RoaXMuY3Jvc3NBLCB0aGlzLm5leHRQb2ludCwgdGhpcy5uZXh0U2VnbWVudCwgdGhpcy5wb2x5Z29uLCB0aGlzLnBvaW50c0dyb3VwXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlcyBhbmQgaGlkZXMgdGhpcyBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc2FibGUoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBzZWxlY3RvcidzIFVJLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkVUlFbGVtZW50cygpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLnBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJwb2x5Z29uU2VsZWN0b3JcIik7XHJcblxyXG4gICAgICAgIHRoaXMuY3Jvc3NBID0gbmV3IENyb3NzRWxlbWVudCh0aGlzLnBhcGVyLCB0aGlzLmJvdW5kUmVjdCk7XHJcbiAgICAgICAgdGhpcy5uZXh0UG9pbnQgPSB0aGlzLnBhcGVyLmNpcmNsZSgwLCAwLCB0aGlzLnBvaW50UmFkaXVzKTtcclxuICAgICAgICB0aGlzLm5leHRQb2ludC5hZGRDbGFzcyhcIm5leHRQb2ludFN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLm5leHRTZWdtZW50ID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5uZXh0TDEgPSB0aGlzLnBhcGVyLmxpbmUoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5uZXh0TE4gPSB0aGlzLnBhcGVyLmxpbmUoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5uZXh0TDEuYWRkQ2xhc3MoXCJuZXh0U2VnbWVudFN0eWxlXCIpO1xyXG4gICAgICAgIHRoaXMubmV4dExOLmFkZENsYXNzKFwibmV4dFNlZ21lbnRTdHlsZVwiKTtcclxuICAgICAgICB0aGlzLm5leHRTZWdtZW50LmFkZCh0aGlzLm5leHRMMSk7XHJcbiAgICAgICAgdGhpcy5uZXh0U2VnbWVudC5hZGQodGhpcy5uZXh0TE4pO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50c0dyb3VwID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5wb2ludHNHcm91cC5hZGRDbGFzcyhcInBvbHlnb25Hcm91cFN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnBvbHlnb24gPSB0aGlzLnBhcGVyLnBvbHlnb24oW10pO1xyXG4gICAgICAgIHRoaXMucG9seWdvbi5hZGRDbGFzcyhcInBvbHlnb25TdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLnBvbHlnb24pO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5wb2ludHNHcm91cCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmNyb3NzQS5ub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMubmV4dFNlZ21lbnQpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5uZXh0UG9pbnQpO1xyXG5cclxuICAgICAgICBjb25zdCBsaXN0ZW5lcnM6IElFdmVudERlc2NyaXB0b3JbXSA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwicG9pbnRlcmVudGVyXCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiB0aGlzLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogKCkgPT4gdGhpcy5zaG93KCksXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVybGVhdmVcIixcclxuICAgICAgICAgICAgICAgIGJhc2U6IHRoaXMucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyOiAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ2FwdHVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbmV3IFBvaW50MkQoZS5jbGllbnRYIC0gcmVjdFswXS5sZWZ0LCBlLmNsaWVudFkgLSByZWN0WzBdLnRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NBLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlUG9pbnQodGhpcy5uZXh0UG9pbnQsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJwb2ludGVyZG93blwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogdGhpcy5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDYXB0dXJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NhcHR1cmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uQmVnaW4gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TZWxlY3Rpb25CZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBcImNsaWNrXCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiB0aGlzLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kZXRhaWwgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRCh0aGlzLmNyb3NzQS54LCB0aGlzLmNyb3NzQS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQocC54LCBwLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0UG9pbnQgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYnlwYXNzOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwicG9pbnRlcm1vdmVcIixcclxuICAgICAgICAgICAgICAgIGJhc2U6IHRoaXMucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyOiAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQb2ludDJEKGUuY2xpZW50WCAtIHJlY3RbMF0ubGVmdCwgZS5jbGllbnRZIC0gcmVjdFswXS50b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Jvc3ModGhpcy5jcm9zc0EsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVQb2ludCh0aGlzLm5leHRQb2ludCwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RQb2ludCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVMaW5lKHRoaXMubmV4dExOLCB0aGlzLmxhc3RQb2ludCwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVMaW5lKHRoaXMubmV4dEwxLCB0aGlzLnBvaW50c1swXSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVMaW5lKHRoaXMubmV4dExOLCBwLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUxpbmUodGhpcy5uZXh0TDEsIHAsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJ5cGFzczogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBcImRibGNsaWNrXCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiB0aGlzLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogKCkgPT4gdGhpcy5zdWJtaXRQb2x5Z29uKCksXHJcbiAgICAgICAgICAgICAgICBieXBhc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogXCJrZXl1cFwiLFxyXG4gICAgICAgICAgICAgICAgYmFzZTogd2luZG93LFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXI6IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFc2NhcGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdFBvbHlnb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYnlwYXNzOiB0cnVlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHMobGlzdGVuZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBuZXcgQXJyYXk8UG9pbnQyRD4oKTtcclxuICAgICAgICB0aGlzLmxhc3RQb2ludCA9IG51bGw7XHJcbiAgICAgICAgbGV0IHBzID0gdGhpcy5wb2ludHNHcm91cC5jaGlsZHJlbigpO1xyXG4gICAgICAgIHdoaWxlIChwcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHBzWzBdLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBwcyA9IHRoaXMucG9pbnRzR3JvdXAuY2hpbGRyZW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucG9seWdvbi5hdHRyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBcIlwiLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc0NhcHR1cmluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBwb2ludCB0byBwb2x5Z29uIGF0IHNwZWNpZmllZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHggLSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb2ludC5cclxuICAgICAqIEBwYXJhbSB5IC0geS1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYWRkUG9pbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnBvaW50cy5wdXNoKG5ldyBQb2ludDJEKHgsIHkpKTtcclxuXHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnBhcGVyLmNpcmNsZSh4LCB5LCB0aGlzLnBvaW50UmFkaXVzKTtcclxuICAgICAgICBwb2ludC5hZGRDbGFzcyhcInBvbHlnb25Qb2ludFN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50c0dyb3VwLmFkZChwb2ludCk7XHJcblxyXG4gICAgICAgIGxldCBwb2ludHNTdHIgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgcG9pbnRzU3RyICs9IGAke3AueH0sJHtwLnl9LGA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucG9seWdvbi5hdHRyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNTdHIuc3Vic3RyKDAsIHBvaW50c1N0ci5sZW5ndGggLSAxKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1Ym1pdHMgdGhlIG5ldyBwb2x5Z29uIHJlZ2lvbiB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3VibWl0UG9seWdvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgYm94ID0gdGhpcy5wb2x5Z29uLmdldEJCb3goKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kKG5ldyBSZWdpb25EYXRhKGJveC54LCBib3gueSwgYm94LndpZHRoLCBib3guaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50cy5tYXAoKHApID0+IHAuY29weSgpKSwgUmVnaW9uRGF0YVR5cGUuUG9seWdvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSwgUmVnaW9uRGF0YVR5cGUgfSBmcm9tIFwiLi4vLi4vQ29yZS9SZWdpb25EYXRhXCI7XHJcblxyXG5pbXBvcnQgeyBJRXZlbnREZXNjcmlwdG9yIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JRXZlbnREZXNjcmlwdG9yXCI7XHJcbmltcG9ydCB7IElNb3ZhYmxlIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JTW92YWJsZVwiO1xyXG5pbXBvcnQgeyBJU2VsZWN0b3JDYWxsYmFja3MgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lTZWxlY3RvckNhbGxiYWNrc1wiO1xyXG5cclxuaW1wb3J0IHsgQ3Jvc3NFbGVtZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudC9Dcm9zc0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgU2VsZWN0b3IgfSBmcm9tIFwiLi9TZWxlY3RvclwiO1xyXG5pbXBvcnQgeyBJUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVBvaW50MkRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2VsZWN0b3IgdG8gZGVmaW5lIGEgcG9seWxpbmUtcmVnaW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvbHlsaW5lU2VsZWN0b3IgZXh0ZW5kcyBTZWxlY3RvciB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgQ3Jvc3NFbGVtZW50YCB0byBkZWZpbmUgcG9pbnQgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcm9zc0E6IENyb3NzRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlbGVtZW50IHRvIGFkZCBhIG5ldyBwb2ludC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBuZXh0UG9pbnQ6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaW5lIHNlZ21lbnQgdG8gYWRkIGEgbmV3IHBvaW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG5leHRTZWdtZW50OiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JvdXBpbmcgZWxlbWVudCBmb3IgcG9seWxpbmUgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHBvaW50c0dyb3VwOiBTbmFwLkVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9seWxpbmUgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwb2x5bGluZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdGlvbiBvZiBwb2ludHMgY29tcG9zaW5nIHBvbHlsaW5lIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcG9pbnRzOiBQb2ludDJEW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFzdCBwb2ludC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsYXN0UG9pbnQ6IFBvaW50MkQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IHBvaW50IHJhZGl1cy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwb2ludFJhZGl1czogbnVtYmVyID0gMztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgc3RhdGUgb2Ygc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNDYXB0dXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGBQb2x5bGluZVNlbGVjdG9yYCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBTVkctZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgZWxlbWVudCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIGJvdW5kUmVjdCAtIFRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIC0gVGhlIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFNWR1NWR0VsZW1lbnQsIHBhcGVyOiBTbmFwLlBhcGVyLCBib3VuZFJlY3Q6IFJlY3QsIGNhbGxiYWNrcz86IElTZWxlY3RvckNhbGxiYWNrcykge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgcGFwZXIsIGJvdW5kUmVjdCwgY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgdGhpcy5idWlsZFVJRWxlbWVudHMoKTtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSBzZWxlY3RvciB0byBzcGVjaWZpZWQgYHdpZHRoYCBhbmQgYGhlaWdodGAuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgbmV3IGB3aWR0aGAuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIG5ldyBgaGVpZ2h0YC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNyb3NzQS5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyB0aGUgc2VsZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoaWRlKCkge1xyXG4gICAgICAgIHN1cGVyLmhpZGUoKTtcclxuICAgICAgICB0aGlzLmNyb3NzQS5oaWRlKCk7XHJcbiAgICAgICAgdGhpcy5uZXh0UG9pbnQubm9kZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAgIHRoaXMubmV4dFNlZ21lbnQubm9kZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAgIHRoaXMucG9seWxpbmUubm9kZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAgIHRoaXMucG9pbnRzR3JvdXAubm9kZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgdGhlIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBzdXBlci5zaG93KCk7XHJcbiAgICAgICAgdGhpcy5jcm9zc0Euc2hvdygpO1xyXG4gICAgICAgIHRoaXMubmV4dFBvaW50Lm5vZGUuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICAgICAgdGhpcy5uZXh0U2VnbWVudC5ub2RlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gICAgICAgIHRoaXMucG9seWxpbmUubm9kZS5zZXRBdHRyaWJ1dGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgICAgICB0aGlzLnBvaW50c0dyb3VwLm5vZGUuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlcyBhbmQgaGlkZXMgdGhpcyBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc2FibGUoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHN1cGVyLmRpc2FibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkcyBzZWxlY3RvcidzIFVJLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJ1aWxkVUlFbGVtZW50cygpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLnBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJwb2x5bGluZVNlbGVjdG9yXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmNyb3NzQSA9IG5ldyBDcm9zc0VsZW1lbnQodGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QpO1xyXG4gICAgICAgIHRoaXMubmV4dFBvaW50ID0gdGhpcy5wYXBlci5jaXJjbGUoMCwgMCwgdGhpcy5wb2ludFJhZGl1cyk7XHJcbiAgICAgICAgdGhpcy5uZXh0UG9pbnQuYWRkQ2xhc3MoXCJuZXh0UG9pbnRTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5uZXh0U2VnbWVudCA9IHRoaXMucGFwZXIubGluZSgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLm5leHRTZWdtZW50LmFkZENsYXNzKFwibmV4dFNlZ21lbnRTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb2ludHNHcm91cCA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMucG9pbnRzR3JvdXAuYWRkQ2xhc3MoXCJwb2x5bGluZUdyb3VwU3R5bGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMucG9seWxpbmUgPSB0aGlzLnBhcGVyLnBvbHlsaW5lKFtdKTtcclxuICAgICAgICB0aGlzLnBvbHlsaW5lLmFkZENsYXNzKFwicG9seWxpbmVTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLnBvbHlsaW5lKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMucG9pbnRzR3JvdXApO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5jcm9zc0Eubm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLm5leHRTZWdtZW50KTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMubmV4dFBvaW50KTtcclxuXHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzOiBJRXZlbnREZXNjcmlwdG9yW10gPSBbXHJcbiAgICAgICAgICAgIHsgZXZlbnQ6IFwicG9pbnRlcmVudGVyXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlckVudGVyLCBiYXNlOiB0aGlzLnBhcmVudE5vZGUsIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJwb2ludGVybGVhdmVcIiwgbGlzdGVuZXI6IHRoaXMub25Qb2ludGVyTGVhdmUsIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJkb3duXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlckRvd24sIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcImNsaWNrXCIsIGxpc3RlbmVyOiB0aGlzLm9uQ2xpY2ssIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJtb3ZlXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlck1vdmUsIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcImRibGNsaWNrXCIsIGxpc3RlbmVyOiB0aGlzLm9uRG91YmxlQ2xpY2ssIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcImtleXVwXCIsIGxpc3RlbmVyOiB0aGlzLm9uS2V5VXAsIGJhc2U6IHdpbmRvdywgYnlwYXNzOiB0cnVlIH0sXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cyhsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IG5ldyBBcnJheTxQb2ludDJEPigpO1xyXG4gICAgICAgIHRoaXMubGFzdFBvaW50ID0gbnVsbDtcclxuICAgICAgICBsZXQgcHMgPSB0aGlzLnBvaW50c0dyb3VwLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgd2hpbGUgKHBzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcHNbMF0ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHBzID0gdGhpcy5wb2ludHNHcm91cC5jaGlsZHJlbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wb2x5bGluZS5hdHRyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBcIlwiLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc0NhcHR1cmluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBwb2ludCB0byBwb2x5bGluZSBhdCBzcGVjaWZpZWQgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB4IC0geC1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0geSAtIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvaW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFkZFBvaW50KHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludHMucHVzaChuZXcgUG9pbnQyRCh4LCB5KSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5wYXBlci5jaXJjbGUoeCwgeSwgdGhpcy5wb2ludFJhZGl1cyk7XHJcbiAgICAgICAgcG9pbnQuYWRkQ2xhc3MoXCJwb2x5bGluZVBvaW50U3R5bGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMucG9pbnRzR3JvdXAuYWRkKHBvaW50KTtcclxuXHJcbiAgICAgICAgbGV0IHBvaW50c1N0ciA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgICAgICBwb2ludHNTdHIgKz0gYCR7cC54fSwke3AueX0sYDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wb2x5bGluZS5hdHRyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNTdHIuc3Vic3RyKDAsIHBvaW50c1N0ci5sZW5ndGggLSAxKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciBlbnRlciBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUG9pbnRlckVudGVyKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciBsZWF2ZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUG9pbnRlckxlYXZlKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0NhcHR1cmluZykge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRChlLmNsaWVudFggLSByZWN0WzBdLmxlZnQsIGUuY2xpZW50WSAtIHJlY3RbMF0udG9wKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NBLCBwKTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlUG9pbnQodGhpcy5uZXh0UG9pbnQsIHApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciBkb3duIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGUgUG9pbnRlckV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25Qb2ludGVyRG93bihlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDYXB0dXJpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0NhcHR1cmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uQmVnaW4gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TZWxlY3Rpb25CZWdpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSBtb3VzZSBjbGljayBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIE1vdXNlRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvbkNsaWNrKGU6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoZS5kZXRhaWwgPD0gMSkge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRCh0aGlzLmNyb3NzQS54LCB0aGlzLmNyb3NzQS55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQocC54LCBwLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFBvaW50ID0gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSBwb2ludGVyIG1vdmUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZSBQb2ludGVyRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvblBvaW50ZXJNb3ZlKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRChlLmNsaWVudFggLSByZWN0WzBdLmxlZnQsIGUuY2xpZW50WSAtIHJlY3RbMF0udG9wKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVDcm9zcyh0aGlzLmNyb3NzQSwgcCk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVBvaW50KHRoaXMubmV4dFBvaW50LCBwKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RQb2ludCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVMaW5lKHRoaXMubmV4dFNlZ21lbnQsIHRoaXMubGFzdFBvaW50LCBwKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUxpbmUodGhpcy5uZXh0U2VnbWVudCwgcCwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSBtb3VzZSBkb3VibGUgY2xpY2sgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZSBNb3VzZUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25Eb3VibGVDbGljayhlOiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5zdWJtaXRQb2x5bGluZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3VibWl0cyB0aGUgbmV3IHBvbHlnb24gcmVnaW9uIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdWJtaXRQb2x5bGluZSgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgYm94ID0gdGhpcy5wb2x5bGluZS5nZXRCQm94KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkVuZChuZXcgUmVnaW9uRGF0YShib3gueCwgYm94LnksIGJveC53aWR0aCwgYm94LmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQb2x5bGluZVBvaW50cygpLCBSZWdpb25EYXRhVHlwZS5Qb2x5bGluZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2x5bGluZSBwb2ludHMsIGNsb3NlcyBpdCBpZiByZXF1aXJlZC5cclxuICAgICAqIEBwYXJhbSBjbG9zZSAtIEEgZmxhZyB0byBcImNsb3NlXCIgdGhlIHBvbHlsaW5lIGlmIGxhc3QgcG9pbnQgaXMgbmVhciB0byB0aGUgZmlyc3Qgb25lLlxyXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCAtIFRoZSB0aHJlc2hvbGQgdG8gY2FsY3VsYXRlIHdoYXQgaXMgXCJuZWFyXCIuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0UG9seWxpbmVQb2ludHMoY2xvc2U6IGJvb2xlYW4gPSB0cnVlLCB0aHJlc2hvbGQ6IG51bWJlciA9IDUpIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cy5tYXAoKHApID0+IHAuY29weSgpKTtcclxuXHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPj0gMyAmJiBjbG9zZSkge1xyXG4gICAgICAgICAgICBjb25zdCBmcCA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgY29uc3QgbHAgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VTcXVhcmUgPSAoZnAueCAtIGxwLngpICogKGZwLnggLSBscC54KSArIChmcC55IC0gbHAueSkgKiAoZnAueSAtIGxwLnkpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VTcXVhcmUgPD0gdGhyZXNob2xkICogdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID0gZnAuY29weSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSBrZXkgdXAgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZSBLZXlib2FyZEV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25LZXlVcChlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgICAgLy8gSG9sZGluZyBzaGlmdCBrZXkgZW5hYmxlIHNxdWFyZSBkcmF3aW5nIG1vZGVcclxuICAgICAgICBpZiAoZS5jb2RlID09PSBcIkVzY2FwZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VibWl0UG9seWxpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IElFdmVudERlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lFdmVudERlc2NyaXB0b3JcIjtcclxuaW1wb3J0IHsgSVJlY3QgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lSZWN0XCI7XHJcbmltcG9ydCB7IElTZWxlY3RvckNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVNlbGVjdG9yQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBDcm9zc0VsZW1lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L0Nyb3NzRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBSZWN0RWxlbWVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvUmVjdEVsZW1lbnRcIjtcclxuaW1wb3J0IHsgU2VsZWN0b3IgfSBmcm9tIFwiLi9TZWxlY3RvclwiO1xyXG5pbXBvcnQgeyBJUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVBvaW50MkRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc2VsZWN0b3IgdG8gZGVmaW5lIGEgcmVjdC1yZWdpb24gdXNpbmcgYSB0ZW1wbGF0ZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWN0Q29weVNlbGVjdG9yIGV4dGVuZHMgU2VsZWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHRlbXBsYXRlIGZvciBzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29weVJlY3Q6IFJlY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYENyb3NzRWxlbWVudGAgdG8gZGVmaW5lIHJlY3QgY2VudGVyLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGNyb3NzQTogQ3Jvc3NFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBSZWN0RWxlbWVudGAgdG8gc2hvdyBjdXJyZW50IHJlY3QuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY29weVJlY3RFbDogUmVjdEVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBgUmVjdENvcHlTZWxlY3RvcmAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgU1ZHLWVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIGVsZW1lbnQgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBib3VuZFJlY3QgLSBUaGUgYm91bmRpbmcgYm94LlxyXG4gICAgICogQHBhcmFtIGNvcHlSZWN0IC0gVGhlIHRlbXBsYXRlIHJlY3QgZm9yIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgLSBUaGUgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogU1ZHU1ZHRWxlbWVudCwgcGFwZXI6IFNuYXAuUGFwZXIsIGJvdW5kUmVjdDogUmVjdCwgY29weVJlY3Q6IFJlY3QsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M/OiBJU2VsZWN0b3JDYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIHBhcGVyLCBib3VuZFJlY3QsIGNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy5jb3B5UmVjdCA9IGNvcHlSZWN0O1xyXG4gICAgICAgIHRoaXMuYnVpbGRVSUVsZW1lbnRzKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0ZW1wbGF0ZSBmb3Igc2VsZWN0b3IuXHJcbiAgICAgKiBAcGFyYW0gY29weVJlY3QgLSBOZXcgdGVtcGxhdGUgcmVjdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFRlbXBsYXRlKGNvcHlSZWN0OiBJUmVjdCkge1xyXG4gICAgICAgIHRoaXMuY29weVJlY3QgPSBuZXcgUmVjdChjb3B5UmVjdC53aWR0aCwgY29weVJlY3QuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jb3B5UmVjdEVsLnJlc2l6ZShjb3B5UmVjdC53aWR0aCwgY29weVJlY3QuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm1vdmVDb3B5UmVjdCh0aGlzLmNvcHlSZWN0RWwsIHRoaXMuY3Jvc3NBKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhlIHNlbGVjdG9yIHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgYHdpZHRoYC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGBoZWlnaHRgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NBLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGhpZGUoKSB7XHJcbiAgICAgICAgc3VwZXIuaGlkZSgpO1xyXG4gICAgICAgIHRoaXMuaGlkZUFsbChbdGhpcy5jcm9zc0EsIHRoaXMuY29weVJlY3RFbF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgdGhlIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBzdXBlci5zaG93KCk7XHJcbiAgICAgICAgdGhpcy5zaG93QWxsKFt0aGlzLmNyb3NzQSwgdGhpcy5jb3B5UmVjdEVsXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgc2VsZWN0b3IncyBVSS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBidWlsZFVJRWxlbWVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwicmVjdENvcHlTZWxlY3RvclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5jcm9zc0EgPSBuZXcgQ3Jvc3NFbGVtZW50KHRoaXMucGFwZXIsIHRoaXMuYm91bmRSZWN0KTtcclxuICAgICAgICB0aGlzLmNvcHlSZWN0RWwgPSBuZXcgUmVjdEVsZW1lbnQodGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QsIHRoaXMuY29weVJlY3QpO1xyXG4gICAgICAgIHRoaXMuY29weVJlY3RFbC5ub2RlLmFkZENsYXNzKFwiY29weVJlY3RTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmNyb3NzQS5ub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuY29weVJlY3RFbC5ub2RlKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzOiBJRXZlbnREZXNjcmlwdG9yW10gPSBbXHJcbiAgICAgICAgICAgIHsgZXZlbnQ6IFwicG9pbnRlcmVudGVyXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlckVudGVyLCBiYXNlOiB0aGlzLnBhcmVudE5vZGUsIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJwb2ludGVybGVhdmVcIiwgbGlzdGVuZXI6IHRoaXMub25Qb2ludGVyTGVhdmUsIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJkb3duXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlckRvd24sIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJ1cFwiLCBsaXN0ZW5lcjogdGhpcy5vblBvaW50ZXJVcCwgYmFzZTogdGhpcy5wYXJlbnROb2RlLCBieXBhc3M6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgIHsgZXZlbnQ6IFwicG9pbnRlcm1vdmVcIiwgbGlzdGVuZXI6IHRoaXMub25Qb2ludGVyTW92ZSwgYmFzZTogdGhpcy5wYXJlbnROb2RlLCBieXBhc3M6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgIHsgZXZlbnQ6IFwid2hlZWxcIiwgbGlzdGVuZXI6IHRoaXMub25XaGVlbCwgYmFzZTogdGhpcy5wYXJlbnROb2RlLCBieXBhc3M6IGZhbHNlIH0sXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cyhsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1vdmUgcmVjdCB0byBzcGVjaWZpZWQgcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gY29weVJlY3QgLSBUaGUgcmVjdCBlbGVtZW50IHRvIG1vdmUuXHJcbiAgICAgKiBAcGFyYW0gcCAtIFRoZSBuZXcgbG9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbW92ZUNvcHlSZWN0KGNvcHlSZWN0OiBSZWN0RWxlbWVudCwgcDogSVBvaW50MkQpIHtcclxuICAgICAgICBjb25zdCB4ID0gcC54IC0gY29weVJlY3QucmVjdC53aWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3QgeSA9IHAueSAtIGNvcHlSZWN0LnJlY3QuaGVpZ2h0IC8gMjtcclxuICAgICAgICBjb3B5UmVjdC5tb3ZlKG5ldyBQb2ludDJEKHgsIHkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciBlbnRlciBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUG9pbnRlckVudGVyKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNyb3NzQS5zaG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29weVJlY3RFbC5zaG93KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW5lciBmb3IgdGhlIHBvaW50ZXIgbGVhdmUgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZSBQb2ludGVyRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvblBvaW50ZXJMZWF2ZShlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW5lciBmb3IgdGhlIHBvaW50ZXIgZG93biBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUG9pbnRlckRvd24oZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVDb3B5UmVjdCh0aGlzLmNvcHlSZWN0RWwsIHRoaXMuY3Jvc3NBKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkJlZ2luID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSBwb2ludGVyIHVwIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGUgUG9pbnRlckV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25Qb2ludGVyVXAoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYWxsYmFja3Mub25TZWxlY3Rpb25FbmQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHAxID0gbmV3IFBvaW50MkQodGhpcy5jcm9zc0EueCAtIHRoaXMuY29weVJlY3Qud2lkdGggLyAyLCB0aGlzLmNyb3NzQS55IC0gdGhpcy5jb3B5UmVjdC5oZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgICAgIGxldCBwMiA9IG5ldyBQb2ludDJEKHRoaXMuY3Jvc3NBLnggKyB0aGlzLmNvcHlSZWN0LndpZHRoIC8gMiwgdGhpcy5jcm9zc0EueSArIHRoaXMuY29weVJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgICAgICAgICAgICAgcDEgPSBwMS5ib3VuZFRvUmVjdCh0aGlzLmJvdW5kUmVjdCk7XHJcbiAgICAgICAgICAgICAgICBwMiA9IHAyLmJvdW5kVG9SZWN0KHRoaXMuYm91bmRSZWN0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcDIueCAtIHAxLng7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBwMi55IC0gcDEueTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25EYXRhID0gUmVnaW9uRGF0YS5CdWlsZFJlY3RSZWdpb25EYXRhKHAxLngsIHAxLnksIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kKHJlZ2lvbkRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW5lciBmb3IgdGhlIHBvaW50ZXIgbW92ZSBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUG9pbnRlck1vdmUoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQb2ludDJEKGUuY2xpZW50WCAtIHJlY3RbMF0ubGVmdCwgZS5jbGllbnRZIC0gcmVjdFswXS50b3ApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jcm9zc0Euc2hvdygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jb3B5UmVjdEVsLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Jvc3ModGhpcy5jcm9zc0EsIHApO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVDb3B5UmVjdCh0aGlzLmNvcHlSZWN0RWwsIHRoaXMuY3Jvc3NBKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSB3aGVlbCBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFdoZWVsRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvbldoZWVsKGU6IFdoZWVsRXZlbnQpIHtcclxuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmNvcHlSZWN0LndpZHRoO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmNvcHlSZWN0LmhlaWdodDtcclxuXHJcbiAgICAgICAgY29uc3QgayA9IGhlaWdodCAvIHdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICBpZiAoZS5kZWx0YVkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCAqPSAxLjE7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgKj0gMS4xO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggLz0gMS4xO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC89IDEuMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChlLmRlbHRhWSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoICs9IDEuMDtcclxuICAgICAgICAgICAgICAgIGhlaWdodCArPSBrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggLT0gMS4wO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0IC09IGs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3aWR0aCA8IDEuMCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IDEuMDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA8IDEuMCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgPSAxLjA7XHJcbiAgICAgICAgICAgIHdpZHRoID0gMS4wIC8gaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNvcHlSZWN0LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5jb3B5UmVjdEVsLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlQ29weVJlY3QodGhpcy5jb3B5UmVjdEVsLCB0aGlzLmNyb3NzQSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuLi8uLi9Db3JlL1BvaW50MkRcIjtcclxuaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUmVnaW9uRGF0YSB9IGZyb20gXCIuLi8uLi9Db3JlL1JlZ2lvbkRhdGFcIjtcclxuXHJcbmltcG9ydCB7IElFdmVudERlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lFdmVudERlc2NyaXB0b3JcIjtcclxuaW1wb3J0IHsgSU1vdmFibGUgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lNb3ZhYmxlXCI7XHJcbmltcG9ydCB7IElTZWxlY3RvckNhbGxiYWNrcyB9IGZyb20gXCIuLi8uLi9JbnRlcmZhY2UvSVNlbGVjdG9yQ2FsbGJhY2tzXCI7XHJcblxyXG5pbXBvcnQgeyBDcm9zc0VsZW1lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L0Nyb3NzRWxlbWVudFwiO1xyXG5pbXBvcnQgeyBNYXNrRWxlbWVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvTWFza0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgUmVjdEVsZW1lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L1JlY3RFbGVtZW50XCI7XHJcbmltcG9ydCB7IFNlbGVjdG9yIH0gZnJvbSBcIi4vU2VsZWN0b3JcIjtcclxuaW1wb3J0IHsgSVBvaW50MkQgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lQb2ludDJEXCI7XHJcblxyXG4vKipcclxuICogRW51bSB0byBzcGVjaWZ5IHNlbGVjdGlvbiBtb2RlLlxyXG4gKi9cclxuZXhwb3J0IGVudW0gU2VsZWN0aW9uTW9kaWZpY2F0b3IgeyBSRUNULCBTUVVBUkUgfVxyXG5cclxuLyoqXHJcbiAqIFRoZSBzZWxlY3RvciB0byBkZWZpbmUgYSByZWN0LXJlZ2lvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWN0U2VsZWN0b3IgZXh0ZW5kcyBTZWxlY3RvciB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgQ3Jvc3NFbGVtZW50YCB0byBzZXQgdGhlIGZpcnN0IGNvcm5lciBvZiB0aGUgcmVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcm9zc0E6IENyb3NzRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgQ3Jvc3NFbGVtZW50YCB0byBzZXQgdGhlIG9wcG9zaXRlIGNvcm5lciBvZiB0aGUgcmVjdC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcm9zc0I6IENyb3NzRWxlbWVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgUmVjdEVsZW1lbnRgIHRvIGRyYXcgc2VsZWN0aW9uIGJveC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZWxlY3Rpb25Cb3g6IFJlY3RFbGVtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBNYXNrRWxlbWVudGAgdG8gaGlkZSByZXN0IG9mIHRoZSBzb3VyY2UgaW1hZ2UuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbWFzazogTWFza0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBmbGFnIGZvciBzZWxlY3Rpb24gc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2FwdHVyaW5nU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsIGZsYWcgZm9yIHNlbGVjdGlvbiBtb2RlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVHdvUG9pbnRzOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBmbGFnIGZvciBzZWxlY3Rpb24gdHlwZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZWxlY3Rpb25Nb2RpZmljYXRvcjogU2VsZWN0aW9uTW9kaWZpY2F0b3IgPSBTZWxlY3Rpb25Nb2RpZmljYXRvci5SRUNUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgYFJlY3RTZWxlY3RvcmAgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgU1ZHLWVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gcGFwZXIgLSBUaGUgYFNuYXAuUGFwZXJgIGVsZW1lbnQgdG8gZHJhdyBvbi5cclxuICAgICAqIEBwYXJhbSBib3VuZFJlY3QgLSBUaGUgYm91bmRpbmcgYm94LlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBTVkdTVkdFbGVtZW50LCBwYXBlcjogU25hcC5QYXBlciwgYm91bmRSZWN0OiBSZWN0LCBjYWxsYmFja3M/OiBJU2VsZWN0b3JDYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIHBhcGVyLCBib3VuZFJlY3QsIGNhbGxiYWNrcyk7XHJcbiAgICAgICAgdGhpcy5idWlsZFVJRWxlbWVudHMoKTtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhlIHNlbGVjdG9yIHRvIHNwZWNpZmllZCBgd2lkdGhgIGFuZCBgaGVpZ2h0YC5cclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFRoZSBuZXcgYHdpZHRoYC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgbmV3IGBoZWlnaHRgLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucmVzaXplQWxsKFt0aGlzLm1hc2ssIHRoaXMuY3Jvc3NBLCB0aGlzLmNyb3NzQl0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlkZXMgdGhlIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGlkZSgpIHtcclxuICAgICAgICBzdXBlci5oaWRlKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlQWxsKFt0aGlzLmNyb3NzQSwgdGhpcy5jcm9zc0IsIHRoaXMubWFza10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgdGhlIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBzdXBlci5zaG93KCk7XHJcbiAgICAgICAgdGhpcy5jcm9zc0Euc2hvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHNlbGVjdG9yJ3MgVUkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYnVpbGRVSUVsZW1lbnRzKCkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcInJlY3RTZWxlY3RvclwiKTtcclxuICAgICAgICB0aGlzLmNyb3NzQSA9IG5ldyBDcm9zc0VsZW1lbnQodGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QpO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NCID0gbmV3IENyb3NzRWxlbWVudCh0aGlzLnBhcGVyLCB0aGlzLmJvdW5kUmVjdCk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Cb3ggPSBuZXcgUmVjdEVsZW1lbnQodGhpcy5wYXBlciwgdGhpcy5ib3VuZFJlY3QsIG5ldyBSZWN0KDAsIDApKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbkJveC5ub2RlLmFkZENsYXNzKFwic2VsZWN0aW9uQm94U3R5bGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMubWFzayA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLnBhcGVyLCB0aGlzLmJvdW5kUmVjdCwgdGhpcy5zZWxlY3Rpb25Cb3gpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMubWFzay5ub2RlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuY3Jvc3NBLm5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5jcm9zc0Iubm9kZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyczogSUV2ZW50RGVzY3JpcHRvcltdID0gW1xyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJlbnRlclwiLCBsaXN0ZW5lcjogdGhpcy5vblBvaW50ZXJFbnRlciwgYmFzZTogdGhpcy5wYXJlbnROb2RlLCBieXBhc3M6IGZhbHNlIH0sXHJcbiAgICAgICAgICAgIHsgZXZlbnQ6IFwicG9pbnRlcmxlYXZlXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlckxlYXZlLCBiYXNlOiB0aGlzLnBhcmVudE5vZGUsIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJwb2ludGVyZG93blwiLCBsaXN0ZW5lcjogdGhpcy5vblBvaW50ZXJEb3duLCBiYXNlOiB0aGlzLnBhcmVudE5vZGUsIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJwb2ludGVydXBcIiwgbGlzdGVuZXI6IHRoaXMub25Qb2ludGVyVXAsIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcInBvaW50ZXJtb3ZlXCIsIGxpc3RlbmVyOiB0aGlzLm9uUG9pbnRlck1vdmUsIGJhc2U6IHRoaXMucGFyZW50Tm9kZSwgYnlwYXNzOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IGV2ZW50OiBcImtleWRvd25cIiwgbGlzdGVuZXI6IHRoaXMub25LZXlEb3duLCBiYXNlOiB3aW5kb3csIGJ5cGFzczogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBldmVudDogXCJrZXl1cFwiLCBsaXN0ZW5lcjogdGhpcy5vbktleVVwLCBiYXNlOiB3aW5kb3csIGJ5cGFzczogdHJ1ZSB9LFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHMobGlzdGVuZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBtb3ZlIHRoZSByZWN0IGVsZW1lbnQgdG8gc3BlY2lmaWVkIGxvY2F0aW9ucy5cclxuICAgICAqIEBwYXJhbSBib3ggLSBUaGUgYm94IHRvIG1vdmUuXHJcbiAgICAgKiBAcGFyYW0gcGEgLSBUaGUgZmlyc3QgY29ybmVyIHBvaW50LlxyXG4gICAgICogQHBhcmFtIHBiIC0gVGhlIG9wcG9zaXRlIGNvcm5lciBwb2ludC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtb3ZlU2VsZWN0aW9uQm94KGJveDogUmVjdEVsZW1lbnQsIHBhOiBJUG9pbnQyRCwgcGI6IElQb2ludDJEKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IChwYS54IDwgcGIueCkgPyBwYS54IDogcGIueDtcclxuICAgICAgICBjb25zdCB5ID0gKHBhLnkgPCBwYi55KSA/IHBhLnkgOiBwYi55O1xyXG4gICAgICAgIGNvbnN0IHcgPSBNYXRoLmFicyhwYS54IC0gcGIueCk7XHJcbiAgICAgICAgY29uc3QgaCA9IE1hdGguYWJzKHBhLnkgLSBwYi55KTtcclxuXHJcbiAgICAgICAgYm94Lm1vdmUobmV3IFBvaW50MkQoeCwgeSkpO1xyXG4gICAgICAgIGJveC5yZXNpemUodywgaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW5lciBmb3IgdGhlIHBvaW50ZXIgZW50ZXIgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gZSBQb2ludGVyRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvblBvaW50ZXJFbnRlcihlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jcm9zc0Euc2hvdygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlzdGVuZXIgZm9yIHRoZSBwb2ludGVyIGxlYXZlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGUgUG9pbnRlckV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25Qb2ludGVyTGVhdmUoZTogUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQb2ludDJEKGUuY2xpZW50WCAtIHJlY3RbMF0ubGVmdCwgZS5jbGllbnRZIC0gcmVjdFswXS50b3ApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmluZ1N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVBbGwoW3RoaXMuY3Jvc3NBLCB0aGlzLmNyb3NzQiwgdGhpcy5zZWxlY3Rpb25Cb3hdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVHdvUG9pbnRzICYmIHRoaXMuY2FwdHVyaW5nU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NCLCBwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbkJveCh0aGlzLnNlbGVjdGlvbkJveCwgdGhpcy5jcm9zc0EsIHRoaXMuY3Jvc3NCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciBkb3duIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGUgUG9pbnRlckV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25Qb2ludGVyRG93bihlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVHdvUG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmluZ1N0YXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Jvc3ModGhpcy5jcm9zc0IsIHRoaXMuY3Jvc3NBKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbkJveCh0aGlzLnNlbGVjdGlvbkJveCwgdGhpcy5jcm9zc0EsIHRoaXMuY3Jvc3NCKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dBbGwoW3RoaXMubWFzaywgdGhpcy5jcm9zc0IsIHRoaXMuc2VsZWN0aW9uQm94XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkJlZ2luID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkJlZ2luKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciB1cCBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uUG9pbnRlclVwKGU6IFBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5wYXJlbnROb2RlLmdldENsaWVudFJlY3RzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQyRChlLmNsaWVudFggLSByZWN0WzBdLmxlZnQsIGUuY2xpZW50WSAtIHJlY3RbMF0udG9wKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1R3b1BvaW50cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJpbmdTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVBbGwoW3RoaXMuY3Jvc3NCLCB0aGlzLm1hc2tdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4odGhpcy5jcm9zc0EueCwgdGhpcy5jcm9zc0IueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHRoaXMuY3Jvc3NBLnksIHRoaXMuY3Jvc3NCLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBNYXRoLmFicyh0aGlzLmNyb3NzQS54IC0gdGhpcy5jcm9zc0IueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaCA9IE1hdGguYWJzKHRoaXMuY3Jvc3NBLnkgLSB0aGlzLmNyb3NzQi55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TZWxlY3Rpb25FbmQoUmVnaW9uRGF0YS5CdWlsZFJlY3RSZWdpb25EYXRhKHgsIHksIHcsIGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmluZ1N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJpbmdTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUFsbChbdGhpcy5jcm9zc0IsIHRoaXMubWFza10pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHRoaXMuY3Jvc3NBLngsIHRoaXMuY3Jvc3NCLngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4odGhpcy5jcm9zc0EueSwgdGhpcy5jcm9zc0IueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBNYXRoLmFicyh0aGlzLmNyb3NzQS54IC0gdGhpcy5jcm9zc0IueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGggPSBNYXRoLmFicyh0aGlzLmNyb3NzQS55IC0gdGhpcy5jcm9zc0IueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblNlbGVjdGlvbkVuZChSZWdpb25EYXRhLkJ1aWxkUmVjdFJlZ2lvbkRhdGEoeCwgeSwgdywgaCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVDcm9zcyh0aGlzLmNyb3NzQSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Jvc3ModGhpcy5jcm9zc0IsIHApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmluZ1N0YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVDcm9zcyh0aGlzLmNyb3NzQiwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uQm94KHRoaXMuc2VsZWN0aW9uQm94LCB0aGlzLmNyb3NzQSwgdGhpcy5jcm9zc0IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0FsbChbdGhpcy5jcm9zc0EsIHRoaXMuY3Jvc3NCLCB0aGlzLnNlbGVjdGlvbkJveCwgdGhpcy5tYXNrXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYWxsYmFja3Mub25TZWxlY3Rpb25CZWdpbiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU2VsZWN0aW9uQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExpc3RlbmVyIGZvciB0aGUgcG9pbnRlciBtb3ZlIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGUgUG9pbnRlckV2ZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgb25Qb2ludGVyTW92ZShlOiBQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IFBvaW50MkQoZS5jbGllbnRYIC0gcmVjdFswXS5sZWZ0LCBlLmNsaWVudFkgLSByZWN0WzBdLnRvcCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNyb3NzQS5zaG93KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUd29Qb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmluZ1N0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Jvc3ModGhpcy5jcm9zc0IsIHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RpZmljYXRvciA9PT0gU2VsZWN0aW9uTW9kaWZpY2F0b3IuU1FVQVJFLCB0aGlzLmNyb3NzQSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uQm94KHRoaXMuc2VsZWN0aW9uQm94LCB0aGlzLmNyb3NzQSwgdGhpcy5jcm9zc0IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVDcm9zcyh0aGlzLmNyb3NzQSwgcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJpbmdTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NCLCBwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kaWZpY2F0b3IgPT09IFNlbGVjdGlvbk1vZGlmaWNhdG9yLlNRVUFSRSwgdGhpcy5jcm9zc0EpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbkJveCh0aGlzLnNlbGVjdGlvbkJveCwgdGhpcy5jcm9zc0EsIHRoaXMuY3Jvc3NCKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Jvc3ModGhpcy5jcm9zc0EsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NCLCBwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW5lciBmb3IgdGhlIGtleSBkb3duIGV2ZW50LlxyXG4gICAgICogQHBhcmFtIGUgS2V5Ym9hcmRFdmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIG9uS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgICAgLy8gSG9sZGluZyBzaGlmdCBrZXkgZW5hYmxlIHNxdWFyZSBkcmF3aW5nIG1vZGVcclxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGlmaWNhdG9yID0gU2VsZWN0aW9uTW9kaWZpY2F0b3IuU1FVQVJFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUuY3RybEtleSAmJiAhdGhpcy5jYXB0dXJpbmdTdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzVHdvUG9pbnRzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaXN0ZW5lciBmb3IgdGhlIGtleSB1cCBldmVudC5cclxuICAgICAqIEBwYXJhbSBlIEtleWJvYXJkRXZlbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBvbktleVVwKGU6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgICAgICAvLyBIb2xkaW5nIHNoaWZ0IGtleSBlbmFibGUgc3F1YXJlIGRyYXdpbmcgbW9kZVxyXG4gICAgICAgIGlmICghZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGlmaWNhdG9yID0gU2VsZWN0aW9uTW9kaWZpY2F0b3IuUkVDVDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhvbGRpbmcgQ3RybCBrZXkgdG8gZW5hYmxlIHR3byBwb2ludCBzZWxlY3Rpb24gbW9kZVxyXG4gICAgICAgIGlmICghZS5jdHJsS2V5ICYmIHRoaXMuaXNUd29Qb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1R3b1BvaW50cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmluZ1N0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZUNyb3NzKHRoaXMuY3Jvc3NBLCB0aGlzLmNyb3NzQik7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUFsbChbdGhpcy5jcm9zc0IsIHRoaXMuc2VsZWN0aW9uQm94LCB0aGlzLm1hc2tdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi8uLi9Db3JlL1JlY3RcIjtcclxuXHJcbmltcG9ydCB7IElFdmVudERlc2NyaXB0b3IgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lFdmVudERlc2NyaXB0b3JcIjtcclxuaW1wb3J0IHsgSUhpZGVhYmxlIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JSGlkZWFkYmxlXCI7XHJcbmltcG9ydCB7IElSZXNpemFibGUgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lSZXNpemFibGVcIjtcclxuaW1wb3J0IHsgSVNlbGVjdG9yQ2FsbGJhY2tzIH0gZnJvbSBcIi4uLy4uL0ludGVyZmFjZS9JU2VsZWN0b3JDYWxsYmFja3NcIjtcclxuXHJcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50L0VsZW1lbnRcIjtcclxuaW1wb3J0IHsgSVBvaW50MkQgfSBmcm9tIFwiLi4vLi4vSW50ZXJmYWNlL0lQb2ludDJEXCI7XHJcbmltcG9ydCB7IENyb3NzRWxlbWVudCB9IGZyb20gXCIuLi9Db21wb25lbnQvQ3Jvc3NFbGVtZW50XCI7XHJcblxyXG4vKipcclxuICogVGhlIGFic3RyYWN0IGNsYXNzIHRvIGRlZmluZSByZWdpb24gc2VsZWN0b3JzLlxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNlbGVjdG9yIGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZWZlcmVuY2UgdG8gY2FsbGJhY2tzIGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjYWxsYmFja3M6IElTZWxlY3RvckNhbGxiYWNrcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbGFnIHRvIGRlZmluZSBpZiBzZWxlY3RvciBpcyBlbmFibGVkIG9yIGRpc2FibGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaXNFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZWZlcmVuY2UgdG8gaG9zdGluZyBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcmVudE5vZGU6IFNWR1NWR0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBzZWxlY3Rvci5cclxuICAgICAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IChob3N0KSBTVkctZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBwYXBlciAtIFRoZSBgU25hcC5QYXBlcmAgZWxlbWVudCB0byBkcmF3IG9uLlxyXG4gICAgICogQHBhcmFtIGJvdW5kUmVjdCAtIFRoZSBib3VuZGluZyBib3ggZm9yIHNlbGVjdG9yLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyAtIFRoZSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBTVkdTVkdFbGVtZW50LCBwYXBlcjogU25hcC5QYXBlciwgYm91bmRSZWN0OiBSZWN0LCBjYWxsYmFja3M/OiBJU2VsZWN0b3JDYWxsYmFja3MpIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgYm91bmRSZWN0KTtcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgIGlmIChjYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgICAgIG9uTG9ja2VkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25TZWxlY3Rpb25CZWdpbjogbnVsbCxcclxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRW5kOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25VbmxvY2tlZDogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIGFuZCBzaG93cyB0aGlzIHNlbGVjdG9yLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW5hYmxlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlcyBhbmQgaGlkZXMgdGhpcyBzZWxlY3Rvci5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGRpc2FibGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBzdWJzY3JpYmUgY29sbGVjdGlvbiBvZiBlbGVtZW50cyB0byBzcGVjaWZpZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVycyAtIFRoZSBjb2xsZWN0aW9uIG9mIGBJRXZlbnREZXNjcmlwdG9yYCBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlVG9FdmVudHMobGlzdGVuZXJzOiBJRXZlbnREZXNjcmlwdG9yW10pIHtcclxuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLmJhc2UuYWRkRXZlbnRMaXN0ZW5lcihlLmV2ZW50LCB0aGlzLmVuYWJsaWZ5KGUubGlzdGVuZXIuYmluZCh0aGlzKSwgZS5ieXBhc3MpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byB3cmFwIGxpc3RlbmVyIHdpdGggdGhlIGVuYWJsZW1lbnQgZmxhZy5cclxuICAgICAqIEBwYXJhbSBmIC0gVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXHJcbiAgICAgKiBAcGFyYW0gYnlwYXNzIC0gVGhlIGBieXBhc3NgIGZsYWcgdG8gZGVmaW5lIHdoZXRoZXIgZXZlbnQgc2hvdWxkIGJlIGNhcHR1cmVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZW5hYmxpZnkoZjogKGFyZ3M6IFBvaW50ZXJFdmVudCB8IEtleWJvYXJkRXZlbnQpID0+IHZvaWQsIGJ5cGFzczogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIChhcmdzOiBQb2ludGVyRXZlbnQgfCBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCB8fCBieXBhc3MpIHtcclxuICAgICAgICAgICAgICAgIGYoYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgYWxsIHRoZSBlbGVtZW50cyBpbiBzcGVjaWZpZWQgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudHMgLSBUaGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gc2hvdy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHNob3dBbGwoZWxlbWVudHM6IEFycmF5PElIaWRlYWJsZXxTbmFwLkVsZW1lbnQ+KSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgoZWxlbWVudCBhcyBJSGlkZWFibGUpLnNob3cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIElIaWRlYWJsZSkuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBTbmFwLkVsZW1lbnQpLm5vZGUuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlkZXMgYWxsIHRoZSBlbGVtZW50cyBpbiBzcGVjaWZpZWQgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudHMgLSBUaGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gaGlkZS5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGhpZGVBbGwoZWxlbWVudHM6IEFycmF5PElIaWRlYWJsZXxTbmFwLkVsZW1lbnQ+KSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgoZWxlbWVudCBhcyBJSGlkZWFibGUpLmhpZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIElIaWRlYWJsZSkuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBTbmFwLkVsZW1lbnQpLm5vZGUuc2V0QXR0cmlidXRlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIGFsbCB0aGUgZWxlbWVudHMgdG8gdGhlIGBib3VuZFJlY3RgIG9mIHRoaXMgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBlbGVtZW5ldHMgLSBUaGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gcmVzaXplLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVzaXplQWxsKGVsZW1lbnRzOiBJUmVzaXphYmxlW10pIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemUodGhpcy5ib3VuZFJlY3Qud2lkdGgsIHRoaXMuYm91bmRSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1vdmUgdGhlIGNyb3NzIGVsZW1lbnQgdG8gc3BlY2lmaWVkIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIGNyb3NzIC0gVGhlIGNyb3NzIGVsZW1lbnQgdG8gbW92ZS5cclxuICAgICAqIEBwYXJhbSBwb2ludFRvIC0gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgY3Jvc3MgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSBzcXVhcmUgLSBUaGUgZmxhZyB0aGF0IG1vdmVtZW50IHNob3VsZCBiZSByZWxhdGVkIHRvIHJlZmVyZW5jZSBwb2ludCBvZiBhIHNxdWFyZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgbW92ZUNyb3NzKGNyb3NzOiBDcm9zc0VsZW1lbnQsIHBvaW50VG86IElQb2ludDJELCBzcXVhcmU6IGJvb2xlYW4gPSBmYWxzZSwgcmVmOiBJUG9pbnQyRCA9IG51bGwpIHtcclxuICAgICAgICBjcm9zcy5tb3ZlKHBvaW50VG8sIHRoaXMuYm91bmRSZWN0LCBzcXVhcmUsIHJlZik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gbW92ZSBhIHBvaW50IGVsZW1lbnQgdG8gc3BlY2lmaWVkIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgZWxlbWVudCB0byBtb3ZlLlxyXG4gICAgICogQHBhcmFtIHBvaW50VG8gLSBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBwb2ludC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG1vdmVQb2ludChwb2ludDogU25hcC5FbGVtZW50LCBwb2ludFRvOiBJUG9pbnQyRCkge1xyXG4gICAgICAgIHBvaW50LmF0dHIoe1xyXG4gICAgICAgICAgICBjeDogcG9pbnRUby54LFxyXG4gICAgICAgICAgICBjeTogcG9pbnRUby55LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1vdmUgYSBsaW5lIGVsZW1lbnQgdG8gc3BlY2lmaWVkIGJlZ2luIGFuZCBlbmQgcG9zaXRpb25zXHJcbiAgICAgKiBAcGFyYW0gbGluZSAtIFRoZSBsaW5lIGVsZW1lbnQgdG8gbW92ZS5cclxuICAgICAqIEBwYXJhbSBwb2ludEZyb20gLSBUaGUgYmVnaW4gcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRUbyAtIFRoZSBlbmQgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBtb3ZlTGluZShsaW5lOiBTbmFwLkVsZW1lbnQsIHBvaW50RnJvbTogSVBvaW50MkQsIHBvaW50VG86IElQb2ludDJEKSB7XHJcbiAgICAgICAgbGluZS5hdHRyKHtcclxuICAgICAgICAgICAgeDE6IHBvaW50RnJvbS54LFxyXG4gICAgICAgICAgICB4MjogcG9pbnRUby54LFxyXG4gICAgICAgICAgICB5MTogcG9pbnRGcm9tLnksXHJcbiAgICAgICAgICAgIHkyOiBwb2ludFRvLnksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdCB9IGZyb20gXCIuLi9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgSVRvb2xiYXJJY29uIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JVG9vbGJhckljb25cIjtcclxuaW1wb3J0IHsgSWNvbkNhbGxiYWNrLCBUb29sYmFySWNvbiB9IGZyb20gXCIuL1Rvb2xiYXJJY29uXCI7XHJcbmltcG9ydCB7IFRvb2xiYXJTZWxlY3RJY29uIH0gZnJvbSBcIi4vVG9vbGJhclNlbGVjdEljb25cIjtcclxuaW1wb3J0IHsgVG9vbGJhclNlcGFyYXRvciB9IGZyb20gXCIuL1Rvb2xiYXJTZXBhcmF0b3JcIjtcclxuaW1wb3J0IHsgVG9vbGJhclN3aXRjaEljb24gfSBmcm9tIFwiLi9Ub29sYmFyU3dpdGNoSWNvblwiO1xyXG5pbXBvcnQgeyBUb29sYmFyVHJpZ2dlckljb24gfSBmcm9tIFwiLi9Ub29sYmFyVHJpZ2dlckljb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBUb29sYmFyIHtcclxuICAgIHByaXZhdGUgYmFzZVBhcmVudDogU1ZHU1ZHRWxlbWVudDtcclxuICAgIHByaXZhdGUgcGFwZXI6IFNuYXAuUGFwZXI7XHJcbiAgICBwcml2YXRlIHBhcGVyUmVjdDogUmVjdDtcclxuXHJcbiAgICBwcml2YXRlIGJhY2tncm91bmRSZWN0OiBTbmFwLkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGljb25zTGF5ZXI6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICBwcml2YXRlIGljb25TcGFjZTogbnVtYmVyID0gODtcclxuXHJcbiAgICBwcml2YXRlIHRvb2xiYXJXaWR0aDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB0b29sYmFySGVpZ2h0OiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBpY29uczogVG9vbGJhckljb25bXTtcclxuXHJcbiAgICBwcml2YXRlIGFyZUhvdEtleXNFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzdmdIb3N0OiBTVkdTVkdFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5pY29ucyA9IG5ldyBBcnJheTxUb29sYmFySWNvbj4oKTtcclxuXHJcbiAgICAgICAgdGhpcy5idWlsZFVJRWxlbWVudHMoc3ZnSG9zdCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZFNlbGVjdG9yKGljb246IElUb29sYmFySWNvbiwgYWN0b3I6IEljb25DYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IG5ld0ljb24gPSBuZXcgVG9vbGJhclNlbGVjdEljb24odGhpcy5wYXBlciwgaWNvbiwgKGFjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChhY3Rpb24pO1xyXG4gICAgICAgICAgICBhY3RvcihhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFkZEljb24obmV3SWNvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZFN3aXRjaChpY29uOiBJVG9vbGJhckljb24sIGFjdG9yOiBJY29uQ2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBuZXdJY29uID0gbmV3IFRvb2xiYXJTd2l0Y2hJY29uKHRoaXMucGFwZXIsIGljb24sIChhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgYWN0b3IoYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJY29uKG5ld0ljb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGRTZXBhcmF0b3IoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3SWNvbiA9IG5ldyBUb29sYmFyU2VwYXJhdG9yKHRoaXMucGFwZXIsIFRvb2xiYXJJY29uLkljb25XaWR0aCk7XHJcbiAgICAgICAgdGhpcy5hZGRJY29uKG5ld0ljb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGRUcmlnZ2VyKGljb246IElUb29sYmFySWNvbiwgYWN0b3I6IEljb25DYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IG5ld0ljb24gPSBuZXcgVG9vbGJhclRyaWdnZXJJY29uKHRoaXMucGFwZXIsIGljb24sIChhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgYWN0b3IoYWN0aW9uKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRJY29uKG5ld0ljb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZWxlY3QoYWN0aW9uOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmljb25zLmZvckVhY2goKGljb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKGljb24gaW5zdGFuY2VvZiBUb29sYmFyU2VsZWN0SWNvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb24uZGVzY3JpcHRpb24uYWN0aW9uICE9PSBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpY29uLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGljb24uc2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0U3dpdGNoKGFjdGlvbjogc3RyaW5nLCBvbjogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnN0IHN3aXRjaEljb246IFRvb2xiYXJJY29uID0gdGhpcy5maW5kSWNvbkJ5QWN0aW9uKGFjdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChzd2l0Y2hJY29uICE9PSB1bmRlZmluZWQgJiYgc3dpdGNoSWNvbiBpbnN0YW5jZW9mIFRvb2xiYXJTd2l0Y2hJY29uKSB7XHJcbiAgICAgICAgICAgIChvbikgPyBzd2l0Y2hJY29uLnNlbGVjdCgpIDogc3dpdGNoSWNvbi51bnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZW5hYmxlSG90a2V5cygpIHtcclxuICAgICAgICB0aGlzLmFyZUhvdEtleXNFbmFibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzYWJsZUhvdGtleXMoKSB7XHJcbiAgICAgICAgdGhpcy5hcmVIb3RLZXlzRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRVSUVsZW1lbnRzKHN2Z0hvc3Q6IFNWR1NWR0VsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmJhc2VQYXJlbnQgPSBzdmdIb3N0O1xyXG4gICAgICAgIHRoaXMucGFwZXIgPSBTbmFwKHN2Z0hvc3QpO1xyXG4gICAgICAgIHRoaXMucGFwZXJSZWN0ID0gbmV3IFJlY3Qoc3ZnSG9zdC53aWR0aC5iYXNlVmFsLnZhbHVlLCBzdmdIb3N0LmhlaWdodC5iYXNlVmFsLnZhbHVlKTtcclxuXHJcbiAgICAgICAgY29uc3QgdG9vbGJhckdyb3VwID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdG9vbGJhckdyb3VwLmFkZENsYXNzKFwidG9vbGJhckxheWVyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlVG9vbGJhclNpemUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kUmVjdCA9IHRoaXMucGFwZXIucmVjdCgwLCAwLCB0aGlzLnRvb2xiYXJXaWR0aCwgdGhpcy50b29sYmFySGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRSZWN0LmFkZENsYXNzKFwidG9vbGJhckJHU3R5bGVcIik7XHJcbiAgICAgICAgdG9vbGJhckdyb3VwLmFkZCh0aGlzLmJhY2tncm91bmRSZWN0KTtcclxuXHJcbiAgICAgICAgdGhpcy5pY29uc0xheWVyID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5pY29uc0xheWVyLmFkZENsYXNzKFwiaWNvbnNMYXllclN0eWxlXCIpO1xyXG4gICAgICAgIHRvb2xiYXJHcm91cC5hZGQodGhpcy5pY29uc0xheWVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0tleWJvYXJkRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZWNhbGN1bGF0ZVRvb2xiYXJTaXplKG5ld0ljb24/OiBUb29sYmFySWNvbikge1xyXG4gICAgICAgIGlmIChuZXdJY29uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy50b29sYmFyV2lkdGggPSBUb29sYmFySWNvbi5JY29uV2lkdGggKyAyICogdGhpcy5pY29uU3BhY2U7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbGJhckhlaWdodCA9IHRoaXMuaWNvbnMubGVuZ3RoICogKFRvb2xiYXJJY29uLkljb25IZWlnaHQgKyB0aGlzLmljb25TcGFjZSkgKyB0aGlzLmljb25TcGFjZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG5ld0ljb24ud2lkdGggKyAyICogdGhpcy5pY29uU3BhY2U7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IHRoaXMudG9vbGJhcldpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXJXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRvb2xiYXJIZWlnaHQgPSB0aGlzLnRvb2xiYXJIZWlnaHQgKyBuZXdJY29uLmhlaWdodCArIHRoaXMuaWNvblNwYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZVRvb2xiYXJTaXplKCkge1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFJlY3QuYXR0cih7XHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy50b29sYmFySGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy50b29sYmFyV2lkdGgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhZGRJY29uKG5ld0ljb246IFRvb2xiYXJJY29uKSB7XHJcbiAgICAgICAgdGhpcy5pY29ucy5wdXNoKG5ld0ljb24pO1xyXG4gICAgICAgIHRoaXMuaWNvbnNMYXllci5hZGQobmV3SWNvbi5ub2RlKTtcclxuXHJcbiAgICAgICAgbmV3SWNvbi5tb3ZlKHRoaXMuaWNvblNwYWNlLCB0aGlzLnRvb2xiYXJIZWlnaHQgKyB0aGlzLmljb25TcGFjZSk7XHJcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZVRvb2xiYXJTaXplKG5ld0ljb24pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbGJhclNpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZpbmRJY29uQnlLZXljb2RlKGtleWNvZGU6IHN0cmluZyk6IFRvb2xiYXJJY29uIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pY29ucy5maW5kKChpY29uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBpY29uLmRlc2NyaXB0aW9uICE9PSBudWxsICYmIGljb24uZGVzY3JpcHRpb24ua2V5Y29kZSA9PT0ga2V5Y29kZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZpbmRJY29uQnlBY3Rpb24oYWN0aW9uOiBzdHJpbmcpOiBUb29sYmFySWNvbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbnMuZmluZCgoaWNvbikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaWNvbi5kZXNjcmlwdGlvbiAhPT0gbnVsbCAmJiBpY29uLmRlc2NyaXB0aW9uLmFjdGlvbiA9PT0gYWN0aW9uO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG9LZXlib2FyZEV2ZW50cygpIHtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkgJiZcclxuICAgICAgICAgICAgICAgICEoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgIShlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJlSG90S2V5c0VuYWJsZWQgJiYgIWUuY3RybEtleSAmJiAhZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gdGhpcy5maW5kSWNvbkJ5S2V5Y29kZShlLmNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpY29uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGljb24gaW5zdGFuY2VvZiBUb29sYmFyU2VsZWN0SWNvbiB8fCBpY29uIGluc3RhbmNlb2YgVG9vbGJhclN3aXRjaEljb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGljb24gaW5zdGFuY2VvZiBUb29sYmFyVHJpZ2dlckljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb24uYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IElUb29sYmFySWNvbiB9IGZyb20gXCIuLi9JbnRlcmZhY2UvSVRvb2xiYXJJY29uXCI7XHJcblxyXG5leHBvcnQgdHlwZSBJY29uQ2FsbGJhY2sgPSAoYWN0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgZW51bSBUb29sYmFySXRlbVR5cGUgeyBTRUxFQ1RPUiwgU1dJVENILCBTRVBBUkFUT1IsIFRSSUdHRVIgfVxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRvb2xiYXJJY29uIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgSWNvbldpZHRoOiBudW1iZXIgPSA0ODtcclxuICAgIHB1YmxpYyBzdGF0aWMgSWNvbkhlaWdodDogbnVtYmVyID0gNDg7XHJcblxyXG4gICAgcHVibGljIHdpZHRoOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7XHJcblxyXG4gICAgcHVibGljIGRlc2NyaXB0aW9uOiBJVG9vbGJhckljb247XHJcbiAgICBwdWJsaWMgbm9kZTogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIHByb3RlY3RlZCBwYXBlcjogU25hcC5QYXBlcjtcclxuICAgIHByb3RlY3RlZCB4OiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgeTogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGlzU2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgaWNvbj86IElUb29sYmFySWNvbikge1xyXG4gICAgICAgIHRoaXMucGFwZXIgPSBwYXBlcjtcclxuXHJcbiAgICAgICAgaWYgKGljb24gIT09IHVuZGVmaW5lZCAmJiBpY29uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBpY29uO1xyXG4gICAgICAgICAgICBpZiAoaWNvbi53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gaWNvbi53aWR0aDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBUb29sYmFySWNvbi5JY29uV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpY29uLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGljb24uaGVpZ2h0O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBUb29sYmFySWNvbi5JY29uSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBUb29sYmFySWNvbi5JY29uV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gVG9vbGJhckljb24uSWNvbkhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG1vdmUoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0KCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcInNlbGVjdGVkXCIpO1xyXG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVuc2VsZWN0KCkge1xyXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpO1xyXG4gICAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB0b2dnbGVTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSVRvb2xiYXJJY29uIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JVG9vbGJhckljb25cIjtcclxuaW1wb3J0IHsgSWNvbkNhbGxiYWNrLCBUb29sYmFySWNvbiB9IGZyb20gXCIuL1Rvb2xiYXJJY29uXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlbGVjdEljb24gZXh0ZW5kcyBUb29sYmFySWNvbiB7XHJcbiAgICBwdWJsaWMgb25BY3Rpb246IEljb25DYWxsYmFjaztcclxuXHJcbiAgICBwcml2YXRlIGljb25CYWNrZ3JvdW5SZWN0OiBTbmFwLkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGljb25JbWFnZTogU25hcC5FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpY29uSW1hZ2VTVkc6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgaWNvbjogSVRvb2xiYXJJY29uLCBvbkFjdGlvbjogSWNvbkNhbGxiYWNrKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIGljb24pO1xyXG5cclxuICAgICAgICB0aGlzLm9uQWN0aW9uID0gb25BY3Rpb247XHJcbiAgICAgICAgdGhpcy5idWlsZEljb25VSSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3RpdmF0ZSgpIHtcclxuICAgICAgICB0aGlzLm9uQWN0aW9uKHRoaXMuZGVzY3JpcHRpb24uYWN0aW9uKTtcclxuICAgICAgICB0aGlzLnNlbGVjdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtb3ZlKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIubW92ZSh4LCB5KTtcclxuICAgICAgICB0aGlzLmljb25CYWNrZ3JvdW5SZWN0LmF0dHIoeyB4LCB5IH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmljb25JbWFnZVNWRyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWNvbkltYWdlU1ZHLmF0dHIoeyB4LCB5IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmljb25CYWNrZ3JvdW5SZWN0LmF0dHIoe1xyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5pY29uSW1hZ2VTVkcuYXR0cih7XHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYnVpbGRJY29uVUkoKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5wYXBlci5nKCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwiaWNvblN0eWxlXCIpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcInNlbGVjdG9yXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmljb25CYWNrZ3JvdW5SZWN0ID0gdGhpcy5wYXBlci5yZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmljb25CYWNrZ3JvdW5SZWN0LmFkZENsYXNzKFwiaWNvbkJHUmVjdFN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmljb25JbWFnZSA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLmljb25VcmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBTbmFwLmxvYWQodGhpcy5kZXNjcmlwdGlvbi5pY29uVXJsLCAoZnJhZ21lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbkltYWdlLmFwcGVuZChmcmFnbWVudCBhcyBhbnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uSW1hZ2VTVkcgPSB0aGlzLmljb25JbWFnZS5jaGlsZHJlbigpLmZpbmQoKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW1lbnQudHlwZSA9PT0gXCJzdmdcIik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmljb25JbWFnZVNWRyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pY29uSW1hZ2VTVkcuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmUodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pY29uSW1hZ2UuYWRkQ2xhc3MoXCJpY29uSW1hZ2VTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSBTbmFwLnBhcnNlKGA8dGl0bGU+JHt0aGlzLmRlc2NyaXB0aW9uLnRvb2x0aXB9PC90aXRsZT5gKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmljb25CYWNrZ3JvdW5SZWN0KTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuaWNvbkltYWdlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kKHRpdGxlIGFzIGFueSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5jbGljaygoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgVG9vbGJhckljb24gfSBmcm9tIFwiLi9Ub29sYmFySWNvblwiO1xyXG5cclxuLyogaW1wb3J0ICogYXMgU05BUFNWR19UWVBFIGZyb20gXCJzbmFwc3ZnXCI7XHJcbmRlY2xhcmUgdmFyIFNuYXA6IHR5cGVvZiBTTkFQU1ZHX1RZUEU7ICovXHJcblxyXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlcGFyYXRvciBleHRlbmRzIFRvb2xiYXJJY29uIHtcclxuICAgIHByaXZhdGUgaWNvblNlcGFyYXRvcjogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCB3aWR0aDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRJY29uVUkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtb3ZlKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIubW92ZSh4LCB5KTtcclxuICAgICAgICB0aGlzLmljb25TZXBhcmF0b3IuYXR0cih7XHJcbiAgICAgICAgICAgIHgxOiB4LFxyXG4gICAgICAgICAgICB4MjogeCArIHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIHkxOiB5LFxyXG4gICAgICAgICAgICB5MjogeSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIucmVzaXplKHdpZHRoLCAxKTtcclxuXHJcbiAgICAgICAgdGhpcy5pY29uU2VwYXJhdG9yLmF0dHIoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkSWNvblVJKCkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcImljb25TdHlsZVwiKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJzZXBhcmF0b3JcIik7XHJcblxyXG4gICAgICAgIHRoaXMuaWNvblNlcGFyYXRvciA9IHRoaXMucGFwZXIubGluZSgwLCAwLCB0aGlzLndpZHRoLCAwKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuaWNvblNlcGFyYXRvcik7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSVRvb2xiYXJJY29uIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JVG9vbGJhckljb25cIjtcclxuaW1wb3J0IHsgSWNvbkNhbGxiYWNrLCBUb29sYmFySWNvbiB9IGZyb20gXCIuL1Rvb2xiYXJJY29uXCI7XHJcblxyXG4vKiBpbXBvcnQgKiBhcyBTTkFQU1ZHX1RZUEUgZnJvbSBcInNuYXBzdmdcIjtcclxuZGVjbGFyZSB2YXIgU25hcDogdHlwZW9mIFNOQVBTVkdfVFlQRTsgKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBUb29sYmFyU3dpdGNoSWNvbiBleHRlbmRzIFRvb2xiYXJJY29uIHtcclxuICAgIHB1YmxpYyBvbkFjdGlvbjogSWNvbkNhbGxiYWNrO1xyXG5cclxuICAgIHByaXZhdGUgaWNvbkJhY2tncm91blJlY3Q6IFNuYXAuRWxlbWVudDtcclxuICAgIHByaXZhdGUgaWNvbkltYWdlOiBTbmFwLkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGljb25JbWFnZVNWRzogU25hcC5FbGVtZW50O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcGVyOiBTbmFwLlBhcGVyLCBpY29uOiBJVG9vbGJhckljb24sIG9uQWN0aW9uOiBJY29uQ2FsbGJhY2spIHtcclxuICAgICAgICBzdXBlcihwYXBlciwgaWNvbik7XHJcblxyXG4gICAgICAgIHRoaXMub25BY3Rpb24gPSBvbkFjdGlvbjtcclxuICAgICAgICB0aGlzLmJ1aWxkSWNvblVJKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlKCkge1xyXG4gICAgICAgIHRoaXMub25BY3Rpb24odGhpcy5kZXNjcmlwdGlvbi5hY3Rpb24pO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlU2VsZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG1vdmUoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci5tb3ZlKHgsIHkpO1xyXG4gICAgICAgIHRoaXMuaWNvbkJhY2tncm91blJlY3QuYXR0cih7IHgsIHkgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaWNvbkltYWdlU1ZHICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pY29uSW1hZ2VTVkcuYXR0cih7IHgsIHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuaWNvbkJhY2tncm91blJlY3QuYXR0cih7XHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmljb25JbWFnZVNWRy5hdHRyKHtcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBidWlsZEljb25VSSgpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLnBhcGVyLmcoKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJpY29uU3R5bGVcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZENsYXNzKFwic3dpdGNoXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmljb25CYWNrZ3JvdW5SZWN0ID0gdGhpcy5wYXBlci5yZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmljb25CYWNrZ3JvdW5SZWN0LmFkZENsYXNzKFwiaWNvbkJHUmVjdFN0eWxlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmljb25JbWFnZSA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLmljb25VcmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBTbmFwLmxvYWQodGhpcy5kZXNjcmlwdGlvbi5pY29uVXJsLCAoZnJhZ21lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbkltYWdlLmFwcGVuZChmcmFnbWVudCBhcyBhbnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pY29uSW1hZ2VTVkcgPSB0aGlzLmljb25JbWFnZS5jaGlsZHJlbigpLmZpbmQoKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW1lbnQudHlwZSA9PT0gXCJzdmdcIik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmljb25JbWFnZVNWRyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pY29uSW1hZ2VTVkcuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmUodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pY29uSW1hZ2UuYWRkQ2xhc3MoXCJpY29uSW1hZ2VTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSBTbmFwLnBhcnNlKGA8dGl0bGU+JHt0aGlzLmRlc2NyaXB0aW9uLnRvb2x0aXB9PC90aXRsZT5gKTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmljb25CYWNrZ3JvdW5SZWN0KTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkKHRoaXMuaWNvbkltYWdlKTtcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kKHRpdGxlIGFzIGFueSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5jbGljaygoZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSVRvb2xiYXJJY29uIH0gZnJvbSBcIi4uL0ludGVyZmFjZS9JVG9vbGJhckljb25cIjtcclxuaW1wb3J0IHsgSWNvbkNhbGxiYWNrLCBUb29sYmFySWNvbiB9IGZyb20gXCIuL1Rvb2xiYXJJY29uXCI7XHJcblxyXG5pbXBvcnQgKiBhcyBTTkFQU1ZHX1RZUEUgZnJvbSBcInNuYXBzdmdcIjtcclxuZGVjbGFyZSB2YXIgU25hcDogdHlwZW9mIFNOQVBTVkdfVFlQRTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUb29sYmFyVHJpZ2dlckljb24gZXh0ZW5kcyBUb29sYmFySWNvbiB7XHJcbiAgICBwdWJsaWMgb25BY3Rpb246IEljb25DYWxsYmFjaztcclxuXHJcbiAgICBwcml2YXRlIGljb25CYWNrZ3JvdW5SZWN0OiBTbmFwLkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGljb25JbWFnZTogU25hcC5FbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBpY29uSW1hZ2VTVkc6IFNuYXAuRWxlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXBlcjogU25hcC5QYXBlciwgaWNvbjogSVRvb2xiYXJJY29uLCBvbkFjdGlvbjogSWNvbkNhbGxiYWNrKSB7XHJcbiAgICAgICAgc3VwZXIocGFwZXIsIGljb24pO1xyXG5cclxuICAgICAgICB0aGlzLm9uQWN0aW9uID0gb25BY3Rpb247XHJcbiAgICAgICAgdGhpcy5idWlsZEljb25VSSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3RpdmF0ZSgpIHtcclxuICAgICAgICB0aGlzLm9uQWN0aW9uKHRoaXMuZGVzY3JpcHRpb24uYWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbW92ZSh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLm1vdmUoeCwgeSk7XHJcbiAgICAgICAgdGhpcy5pY29uQmFja2dyb3VuUmVjdC5hdHRyKHsgeCwgeSB9KTtcclxuICAgICAgICBpZiAodGhpcy5pY29uSW1hZ2VTVkcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmljb25JbWFnZVNWRy5hdHRyKHsgeCwgeSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlc2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5pY29uQmFja2dyb3VuUmVjdC5hdHRyKHtcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuaWNvbkltYWdlU1ZHLmF0dHIoe1xyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkSWNvblVJKCkge1xyXG4gICAgICAgIHRoaXMubm9kZSA9IHRoaXMucGFwZXIuZygpO1xyXG4gICAgICAgIHRoaXMubm9kZS5hZGRDbGFzcyhcImljb25TdHlsZVwiKTtcclxuICAgICAgICB0aGlzLm5vZGUuYWRkQ2xhc3MoXCJzZWxlY3RvclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5pY29uQmFja2dyb3VuUmVjdCA9IHRoaXMucGFwZXIucmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5pY29uQmFja2dyb3VuUmVjdC5hZGRDbGFzcyhcImljb25CR1JlY3RTdHlsZVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5pY29uSW1hZ2UgPSB0aGlzLnBhcGVyLmcoKTtcclxuICAgICAgICBpZiAodGhpcy5kZXNjcmlwdGlvbi5pY29uVXJsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgU25hcC5sb2FkKHRoaXMuZGVzY3JpcHRpb24uaWNvblVybCwgKGZyYWdtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25JbWFnZS5hcHBlbmQoZnJhZ21lbnQgYXMgYW55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaWNvbkltYWdlU1ZHID0gdGhpcy5pY29uSW1hZ2UuY2hpbGRyZW4oKS5maW5kKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50LnR5cGUgPT09IFwic3ZnXCIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pY29uSW1hZ2VTVkcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWNvbkltYWdlU1ZHLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWNvbkltYWdlLmFkZENsYXNzKFwiaWNvbkltYWdlU3R5bGVcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gU25hcC5wYXJzZShgPHRpdGxlPiR7dGhpcy5kZXNjcmlwdGlvbi50b29sdGlwfTwvdGl0bGU+YCk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZS5hZGQodGhpcy5pY29uQmFja2dyb3VuUmVjdCk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFkZCh0aGlzLmljb25JbWFnZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZCh0aXRsZSBhcyBhbnkpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGUuY2xpY2soKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFRvb2xiYXIgYXMgQ1RUb29sYmFyIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvVG9vbGJhci9Ub29sYmFyXCI7XHJcbmltcG9ydCB7IFJlZ2lvbnNNYW5hZ2VyIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvUmVnaW9uL1JlZ2lvbnNNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFBvaW50UmVnaW9uIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvUmVnaW9uL1BvaW50L1BvaW50UmVnaW9uXCI7XHJcbmltcG9ydCB7IFJlY3RSZWdpb24gfSBmcm9tIFwiLi9DYW52YXNUb29scy9SZWdpb24vUmVjdC9SZWN0UmVnaW9uXCI7XHJcbmltcG9ydCB7IEFyZWFTZWxlY3RvciB9IGZyb20gXCIuL0NhbnZhc1Rvb2xzL1NlbGVjdGlvbi9BcmVhU2VsZWN0b3JcIjtcclxuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZSB9IGZyb20gXCIuL0NhbnZhc1Rvb2xzL0ludGVyZmFjZS9JU2VsZWN0b3JTZXR0aW5nc1wiO1xyXG5pbXBvcnQgeyBJbnZlcnRGaWx0ZXIsIEdyYXlzY2FsZUZpbHRlciwgQmx1ckRpZmZGaWx0ZXIsIENvbnRyYXN0RmlsdGVyLFxyXG4gICAgICAgICBCcmlnaHRuZXNzRmlsdGVyLCBTYXR1cmF0aW9uRmlsdGVyIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvQ2FudmFzVG9vbHMuRmlsdGVyXCI7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tIFwiLi9DYW52YXNUb29scy9Db3JlL1JlY3RcIjtcclxuaW1wb3J0IHsgUG9pbnQyRCB9IGZyb20gXCIuL0NhbnZhc1Rvb2xzL0NvcmUvUG9pbnQyRFwiO1xyXG5pbXBvcnQgeyBSZWdpb25EYXRhIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvQ29yZS9SZWdpb25EYXRhXCI7XHJcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuL0NhbnZhc1Rvb2xzL0NvcmUvVGFnXCI7XHJcbmltcG9ydCB7IFRhZ3NEZXNjcmlwdG9yIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvQ29yZS9UYWdzRGVzY3JpcHRvclwiO1xyXG5pbXBvcnQgeyBFZGl0b3IgYXMgQ1RFZGl0b3IgfSBmcm9tIFwiLi9DYW52YXNUb29scy9DYW52YXNUb29scy5FZGl0b3JcIjtcclxuaW1wb3J0IHsgUkdCQ29sb3IgfSBmcm9tIFwiLi9DYW52YXNUb29scy9Db3JlL0NvbG9ycy9SR0JDb2xvclwiO1xyXG5pbXBvcnQgeyBMQUJDb2xvciB9IGZyb20gXCIuL0NhbnZhc1Rvb2xzL0NvcmUvQ29sb3JzL0xBQkNvbG9yXCI7XHJcbmltcG9ydCB7IFhZWkNvbG9yIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvQ29yZS9Db2xvcnMvWFlaQ29sb3JcIjtcclxuaW1wb3J0IHsgSFNMQ29sb3IgfSBmcm9tIFwiLi9DYW52YXNUb29scy9Db3JlL0NvbG9ycy9IU0xDb2xvclwiO1xyXG5pbXBvcnQgeyBQYWxldHRlIH0gZnJvbSBcIi4vQ2FudmFzVG9vbHMvQ29yZS9Db2xvcnMvUGFsZXR0ZVwiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuL0NhbnZhc1Rvb2xzL0NvcmUvQ29sb3JzL0NvbG9yXCI7XHJcblxyXG5pbXBvcnQgXCJzbmFwc3ZnLWNqc1wiO1xyXG4vKiBpbXBvcnQgKiBhcyBTTkFQU1ZHX1RZUEUgZnJvbSBcInNuYXBzdmdcIjtcclxuZGVjbGFyZSB2YXIgU25hcDogdHlwZW9mIFNOQVBTVkdfVFlQRTsgKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBDYW52YXNUb29scyB7XHJcbiAgICAvKipcclxuICAgICAqIENvcmUgaW50ZXJuYWwgY2xhc3Nlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBDb3JlID0ge1xyXG4gICAgICAgIFJlY3QsXHJcbiAgICAgICAgUG9pbnQyRCxcclxuICAgICAgICBSZWdpb25EYXRhLFxyXG4gICAgICAgIFRhZ3NEZXNjcmlwdG9yLFxyXG4gICAgICAgIFRhZyxcclxuICAgICAgICBDb2xvcnM6IHtcclxuICAgICAgICAgICAgUkdCQ29sb3IsXHJcbiAgICAgICAgICAgIExBQkNvbG9yLFxyXG4gICAgICAgICAgICBYWVpDb2xvcixcclxuICAgICAgICAgICAgSFNMQ29sb3IsXHJcbiAgICAgICAgICAgIFBhbGV0dGUsXHJcbiAgICAgICAgICAgIENvbG9yLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3NlcyBmb3IgbmV3IHJlZ2lvbiBzZWxlY3Rpb24gKGNyZWF0aW9uKS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBTZWxlY3Rpb24gPSB7XHJcbiAgICAgICAgQXJlYVNlbGVjdG9yLFxyXG4gICAgICAgIFNlbGVjdGlvbk1vZGUsXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3NlcyBmb3IgcmVnaW9ucyBtYW5hZ2VtZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFJlZ2lvbiA9IHtcclxuICAgICAgICBSZWdpb25zTWFuYWdlcixcclxuICAgICAgICBQb2ludFJlZ2lvbixcclxuICAgICAgICBSZWN0UmVnaW9uLFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzZXMgYW5kIGZ1bmN0aW9ucyB0byBhcHBseSBmaWx0ZXJzIHRvIHRoZSBzb3VyY2UgaW1hZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRmlsdGVycyA9IHtcclxuICAgICAgICBJbnZlcnRGaWx0ZXIsXHJcbiAgICAgICAgR3JheXNjYWxlRmlsdGVyLFxyXG4gICAgICAgIEJsdXJEaWZmRmlsdGVyLFxyXG4gICAgICAgIENvbnRyYXN0RmlsdGVyLFxyXG4gICAgICAgIEJyaWdodG5lc3NGaWx0ZXIsXHJcbiAgICAgICAgU2F0dXJhdGlvbkZpbHRlcixcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgRWRpdG9yIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBFZGl0b3IgPSBDVEVkaXRvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBUb29sYmFyIGNvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUb29sYmFyID0gQ1RUb29sYmFyO1xyXG59XHJcblxyXG4vKiBDU1MgKi9cclxuaW1wb3J0IFwiLi8uLi9jc3MvY2FudmFzdG9vbHMuY3NzXCI7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=